<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 13: Heap Sort - Essential Algorithms Handbook</title>
</head>
<body>
    <div class="academic-content">
        <div class="chapter-number">CHAPTER 13</div>
        <h1 class="chapter-title">Heap Sort</h1>
        
        <p class="academic-text">
            Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure. It combines the better attributes of merge sort and insertion sort: like merge sort, it has O(n log n) time complexity, and like insertion sort, it sorts in-place with O(1) auxiliary space. The algorithm works by building a max heap from the input data, then repeatedly extracting the maximum element and placing it at the end of the sorted portion.
        </p>
        
        <h2 class="section-title">Problem Statement</h2>
        
        <p class="academic-text">
            Given an array of n elements, sort the array in ascending order using the heap sort algorithm. The algorithm should build a heap from the array and repeatedly extract elements to create a sorted sequence.
        </p>
        
        <div class="definition-box">
            <strong>Input:</strong> Array arr[] of size n with comparable elements<br>
            <strong>Output:</strong> Same array sorted in ascending order<br>
            <strong>Stability:</strong> Not stable (can change relative order of equal elements)
        </div>
        
        <h2 class="section-title">Heap Properties</h2>
        
        <p class="academic-text">
            A binary heap is a complete binary tree with the heap property:
        </p>
        
        <ul>
            <li><strong>Max Heap:</strong> Parent ‚â• Children (root contains maximum element)</li>
            <li><strong>Min Heap:</strong> Parent ‚â§ Children (root contains minimum element)</li>
            <li><strong>Complete Tree:</strong> All levels filled except possibly the last, filled left to right</li>
            <li><strong>Array Representation:</strong> For node at index i, left child at 2i+1, right child at 2i+2, parent at (i-1)/2</li>
        </ul>
        
        <h2 class="section-title">Algorithm Steps</h2>
        
        <div class="code-block">
Algorithm: HeapSort(arr, n)
1. // Build max heap from array
2. for i = n/2 - 1 down to 0 do
3.     Heapify(arr, n, i)
4. end for
5. 
6. // Extract elements from heap one by one
7. for i = n-1 down to 1 do
8.     swap(arr[0], arr[i])  // Move current root to end
9.     Heapify(arr, i, 0)    // Restore heap property
10. end for

Algorithm: Heapify(arr, n, i)
1. largest = i
2. left = 2*i + 1
3. right = 2*i + 2
4. 
5. if left < n AND arr[left] > arr[largest] then
6.     largest = left
7. end if
8. if right < n AND arr[right] > arr[largest] then
9.     largest = right
10. end if
11. if largest != i then
12.     swap(arr[i], arr[largest])
13.     Heapify(arr, n, largest)
14. end if
        </div>
        
        <h2 class="section-title">Implementation</h2>
        
        <div class="code-block">
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/**
 * Heapify function - maintains heap property
 * Assumes subtrees are already heaps, fixes violation at root
 * 
 * @param arr: array representing the heap
 * @param n: size of heap
 * @param i: index of root of subtree to heapify
 */
void heapify(vector<int>& arr, int n, int i) {
    int largest = i;        // Initialize largest as root
    int left = 2 * i + 1;   // Left child
    int right = 2 * i + 2;  // Right child
    
    // If left child is larger than root
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // If largest is not root
    if (largest != i) {
        swap(arr[i], arr[largest]);
        
        // Recursively heapify the affected subtree
        heapify(arr, n, largest);
    }
}

/**
 * Heap Sort - Main function
 * Builds max heap then repeatedly extracts maximum
 */
void heapSort(vector<int>& arr) {
    int n = arr.size();
    
    // Build max heap (rearrange array)
    // Start from last non-leaf node and heapify each node
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // Extract elements from heap one by one
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(arr[0], arr[i]);
        
        // Call heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

/**
 * Iterative Heapify
 * Non-recursive version to avoid stack overflow
 */
void iterativeHeapify(vector<int>& arr, int n, int i) {
    while (true) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest == i) {
            break;  // Heap property satisfied
        }
        
        swap(arr[i], arr[largest]);
        i = largest;  // Move down the tree
    }
}

/**
 * Heap Sort with Statistics
 * Tracks comparisons, swaps, and heapify operations
 */
struct HeapSortStats {
    int comparisons;
    int swaps;
    int heapifyOperations;
    vector<vector<int>> stateHistory;
};

void heapifyWithStats(vector<int>& arr, int n, int i, HeapSortStats& stats) {
    stats.heapifyOperations++;
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n) {
        stats.comparisons++;
        if (arr[left] > arr[largest]) {
            largest = left;
        }
    }
    
    if (right < n) {
        stats.comparisons++;
        if (arr[right] > arr[largest]) {
            largest = right;
        }
    }
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        stats.swaps++;
        heapifyWithStats(arr, n, largest, stats);
    }
}

HeapSortStats heapSortWithStats(vector<int>& arr) {
    HeapSortStats stats = {0, 0, 0, {}};
    int n = arr.size();
    
    // Save initial state
    stats.stateHistory.push_back(arr);
    
    // Build max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapifyWithStats(arr, n, i, stats);
    }
    
    // Save state after heap construction
    stats.stateHistory.push_back(arr);
    
    // Extract elements from heap
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        stats.swaps++;
        
        heapifyWithStats(arr, i, 0, stats);
        
        // Save state after each extraction
        stats.stateHistory.push_back(arr);
    }
    
    return stats;
}

/**
 * Min Heap Sort (for descending order)
 * Uses min heap to sort in descending order
 */
void minHeapify(vector<int>& arr, int n, int i) {
    int smallest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && arr[left] < arr[smallest]) {
        smallest = left;
    }
    
    if (right < n && arr[right] < arr[smallest]) {
        smallest = right;
    }
    
    if (smallest != i) {
        swap(arr[i], arr[smallest]);
        minHeapify(arr, n, smallest);
    }
}

void minHeapSort(vector<int>& arr) {
    int n = arr.size();
    
    // Build min heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        minHeapify(arr, n, i);
    }
    
    // Extract elements (results in descending order)
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        minHeapify(arr, i, 0);
    }
}

/**
 * Generic Heap Sort with Custom Comparator
 */
template<typename T, typename Compare>
void genericHeapify(vector<T>& arr, int n, int i, Compare comp) {
    int target = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    if (left < n && comp(arr[target], arr[left])) {
        target = left;
    }
    
    if (right < n && comp(arr[target], arr[right])) {
        target = right;
    }
    
    if (target != i) {
        swap(arr[i], arr[target]);
        genericHeapify(arr, n, target, comp);
    }
}

template<typename T, typename Compare>
void genericHeapSort(vector<T>& arr, Compare comp) {
    int n = arr.size();
    
    // Build heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        genericHeapify(arr, n, i, comp);
    }
    
    // Extract elements
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        genericHeapify(arr, i, 0, comp);
    }
}

/**
 * Heap Sort for K Largest Elements
 * Partially sorts to find k largest elements
 */
vector<int> heapSortKLargest(vector<int>& arr, int k) {
    int n = arr.size();
    k = min(k, n);
    
    // Build max heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    vector<int> result;
    
    // Extract k largest elements
    for (int i = 0; i < k; i++) {
        result.push_back(arr[0]);
        swap(arr[0], arr[n - 1 - i]);
        heapify(arr, n - 1 - i, 0);
    }
    
    return result;
}

/**
 * Bottom-up Heap Construction (Floyd's method)
 * More efficient heap building algorithm
 */
void floydHeapConstruction(vector<int>& arr) {
    int n = arr.size();
    
    // Start from the last non-leaf node
    for (int i = (n - 2) / 2; i >= 0; i--) {
        // Sift down
        int parent = i;
        while (2 * parent + 1 < n) {
            int child = 2 * parent + 1;
            
            // Choose larger child
            if (child + 1 < n && arr[child + 1] > arr[child]) {
                child++;
            }
            
            // If heap property satisfied, stop
            if (arr[parent] >= arr[child]) {
                break;
            }
            
            swap(arr[parent], arr[child]);
            parent = child;
        }
    }
}

// Utility functions
void printArray(const vector<int>& arr, const string& label = "") {
    if (!label.empty()) cout << label << ": ";
    cout << "[";
    for (int i = 0; i < arr.size(); i++) {
        cout << arr[i];
        if (i < arr.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
}

void printHeapStructure(const vector<int>& arr) {
    int n = arr.size();
    cout << "Heap structure:" << endl;
    
    int level = 0;
    int levelSize = 1;
    int index = 0;
    
    while (index < n) {
        cout << "Level " << level << ": ";
        for (int i = 0; i < levelSize && index < n; i++, index++) {
            cout << arr[index] << " ";
        }
        cout << endl;
        level++;
        levelSize *= 2;
    }
}

// Example usage and testing
int main() {
    // Test basic heap sort
    vector<int> arr1 = {12, 11, 13, 5, 6, 7};
    cout << "=== Basic Heap Sort ===" << endl;
    printArray(arr1, "Original");
    
    heapSort(arr1);
    printArray(arr1, "Sorted");
    
    // Test heap sort with statistics
    vector<int> arr2 = {4, 10, 3, 5, 1};
    cout << "\n=== Heap Sort with Statistics ===" << endl;
    printArray(arr2, "Original");
    
    HeapSortStats stats = heapSortWithStats(arr2);
    printArray(arr2, "Sorted");
    
    cout << "Statistics:" << endl;
    cout << "  Comparisons: " << stats.comparisons << endl;
    cout << "  Swaps: " << stats.swaps << endl;
    cout << "  Heapify operations: " << stats.heapifyOperations << endl;
    
    cout << "  State history:" << endl;
    for (int i = 0; i < stats.stateHistory.size(); i++) {
        cout << "    Step " << i << ": ";
        printArray(stats.stateHistory[i], "");
    }
    
    // Test min heap sort (descending order)
    vector<int> arr3 = {64, 34, 25, 12, 22, 11, 90};
    cout << "\n=== Min Heap Sort (Descending) ===" << endl;
    printArray(arr3, "Original");
    
    minHeapSort(arr3);
    printArray(arr3, "Sorted (Descending)");
    
    // Test generic heap sort with strings
    vector<string> words = {"banana", "apple", "cherry", "date"};
    cout << "\n=== Generic Heap Sort (Strings) ===" << endl;
    cout << "Original: [";
    for (int i = 0; i < words.size(); i++) {
        cout << words[i];
        if (i < words.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    genericHeapSort(words, [](const string& a, const string& b) {
        return a < b;  // Max heap for ascending order
    });
    
    cout << "Sorted: [";
    for (int i = 0; i < words.size(); i++) {
        cout << words[i];
        if (i < words.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    // Test k largest elements
    vector<int> arr4 = {7, 10, 4, 3, 20, 15};
    int k = 3;
    cout << "\n=== Finding " << k << " Largest Elements ===" << endl;
    printArray(arr4, "Original");
    
    vector<int> kLargest = heapSortKLargest(arr4, k);
    cout << "3 Largest: [";
    for (int i = 0; i < kLargest.size(); i++) {
        cout << kLargest[i];
        if (i < kLargest.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    // Demonstrate heap structure
    vector<int> arr5 = {90, 15, 10, 7, 12, 2, 7, 3};
    cout << "\n=== Heap Structure Visualization ===" << endl;
    printArray(arr5, "Array");
    
    // Build max heap first
    for (int i = arr5.size() / 2 - 1; i >= 0; i--) {
        heapify(arr5, arr5.size(), i);
    }
    
    printArray(arr5, "Max Heap");
    printHeapStructure(arr5);
    
    return 0;
}
        </div>
        
        <h2 class="section-title">Complexity Analysis</h2>
        
        <div class="performance-summary">
            <h3>Time Complexity</h3>
            <ul>
                <li><strong>Best Case:</strong> O(n log n) - Always builds heap and extracts elements</li>
                <li><strong>Average Case:</strong> O(n log n) - Consistent performance</li>
                <li><strong>Worst Case:</strong> O(n log n) - Guaranteed performance</li>
                <li><strong>Heap Construction:</strong> O(n) using Floyd's method</li>
            </ul>
            
            <h3>Space Complexity</h3>
            <ul>
                <li><strong>Auxiliary Space:</strong> O(1) - In-place sorting</li>
                <li><strong>Recursion Stack:</strong> O(log n) - Due to heapify recursion</li>
                <li><strong>Iterative Version:</strong> O(1) - No recursion needed</li>
            </ul>
            
            <h3>Other Properties</h3>
            <ul>
                <li><strong>Stable:</strong> No - Can change relative order of equal elements</li>
                <li><strong>In-place:</strong> Yes - Sorts with constant extra space</li>
                <li><strong>Adaptive:</strong> No - Always performs same operations</li>
            </ul>
        </div>
        
        <h2 class="section-title">Example Walkthrough</h2>
        
        <p class="academic-text">
            Let's trace through heap sort on array [4, 10, 3, 5, 1]:
        </p>
        
        <div class="code-block">
Initial: [4, 10, 3, 5, 1]

Step 1: Build Max Heap
Start from last non-leaf node (index 1):
  Heapify(1): Compare 10 with children 5,1 ‚Üí no change
  Heapify(0): Compare 4 with children 10,3 ‚Üí swap 4,10
  Result: [10, 5, 3, 4, 1]

Max Heap Structure:
       10
      /  \
     5    3
    / \
   4   1

Step 2: Extract Elements
Extract 10: swap(arr[0], arr[4]) ‚Üí [1, 5, 3, 4, 10]
Heapify(0) with size 4: [5, 4, 3, 1, 10]

Extract 5: swap(arr[0], arr[3]) ‚Üí [1, 4, 3, 5, 10]
Heapify(0) with size 3: [4, 1, 3, 5, 10]

Extract 4: swap(arr[0], arr[2]) ‚Üí [3, 1, 4, 5, 10]
Heapify(0) with size 2: [3, 1, 4, 5, 10]

Extract 3: swap(arr[0], arr[1]) ‚Üí [1, 3, 4, 5, 10]

Final: [1, 3, 4, 5, 10]
        </div>
        
        <h2 class="section-title">Applications</h2>
        
        <p class="academic-text">
            Heap sort is particularly useful in these scenarios:
        </p>
        
        <ul>
            <li><strong>Memory-Constrained Systems:</strong> O(1) auxiliary space requirement</li>
            <li><strong>Guaranteed Performance:</strong> Always O(n log n), never degrades</li>
            <li><strong>Priority Queues:</strong> Foundation for heap-based priority queues</li>
            <li><strong>Selection Algorithms:</strong> Finding k largest/smallest elements</li>
            <li><strong>Real-time Systems:</strong> Predictable performance characteristics</li>
            <li><strong>External Sorting:</strong> When combined with external merge techniques</li>
        </ul>
        
        <h2 class="section-title">Optimizations and Variations</h2>
        
        <h3>1. Bottom-up Heap Construction</h3>
        <div class="code-block">
// Floyd's method - O(n) heap construction
void efficientHeapBuild(vector<int>& arr) {
    int n = arr.size();
    
    // Start from last internal node
    for (int i = (n - 2) / 2; i >= 0; i--) {
        int parent = i;
        
        // Sift down without recursion
        while (2 * parent + 1 < n) {
            int child = 2 * parent + 1;
            
            if (child + 1 < n && arr[child + 1] > arr[child]) {
                child++;
            }
            
            if (arr[parent] >= arr[child]) break;
            
            swap(arr[parent], arr[child]);
            parent = child;
        }
    }
}
        </div>
        
        <h3>2. Ternary Heap Sort</h3>
        <div class="code-block">
// Uses ternary heap (3 children per node)
void ternaryHeapify(vector<int>& arr, int n, int i) {
    int largest = i;
    
    for (int child = 3 * i + 1; child <= 3 * i + 3 && child < n; child++) {
        if (arr[child] > arr[largest]) {
            largest = child;
        }
    }
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        ternaryHeapify(arr, n, largest);
    }
}
        </div>
        
        <h2 class="section-title">When to Use Heap Sort</h2>
        
        <div class="definition-box">
            <strong>Use Heap Sort When:</strong><br>
            ‚Ä¢ Memory usage must be minimal (O(1) auxiliary space)<br>
            ‚Ä¢ Guaranteed O(n log n) performance is required<br>
            ‚Ä¢ You need to find k largest/smallest elements<br>
            ‚Ä¢ Working with priority queue applications<br>
            ‚Ä¢ Stability is not required<br><br>
            
            <strong>Don't Use Heap Sort When:</strong><br>
            ‚Ä¢ Stability is required (use merge sort)<br>
            ‚Ä¢ Cache performance is critical (quick sort often better)<br>
            ‚Ä¢ Working with small datasets (insertion sort better)<br>
            ‚Ä¢ Average-case performance is more important than worst-case
        </div>
        
        <h2 class="section-title">Common Pitfalls ‚ö†Ô∏è</h2>
        
        <ul>
            <li><strong>Index Calculations:</strong> Remember parent=(i-1)/2, children=2i+1, 2i+2</li>
            <li><strong>Heap Property:</strong> Ensure max heap for ascending sort, min heap for descending</li>
            <li><strong>Boundary Conditions:</strong> Check array bounds in heapify function</li>
            <li><strong>Recursion Depth:</strong> Use iterative heapify for very large arrays</li>
            <li><strong>Not Stable:</strong> Don't use when stability is required</li>
        </ul>
        
        <h2 class="section-title">Interview Tips üéØ</h2>
        
        <ul>
            <li><strong>Guaranteed Performance:</strong> Always O(n log n), unlike quick sort</li>
            <li><strong>In-place Sorting:</strong> Uses only O(1) extra space</li>
            <li><strong>Heap Property:</strong> Explain parent-child relationship clearly</li>
            <li><strong>Two Phases:</strong> Heap construction (O(n)) + extraction (O(n log n))</li>
            <li><strong>Applications:</strong> Mention priority queues and selection algorithms</li>
            <li><strong>Comparison:</strong> Contrast with merge sort (stable, O(n) space) and quick sort (average faster)</li>
        </ul>
        
        <div class="completion-summary">
            <h3>Key Takeaways</h3>
            <ul>
                <li>Heap sort guarantees O(n log n) time complexity in all cases</li>
                <li>In-place sorting algorithm with O(1) auxiliary space</li>
                <li>Not stable but has predictable performance characteristics</li>
                <li>Based on binary heap data structure with parent-child relationships</li>
                <li>Excellent for finding k largest/smallest elements</li>
                <li>Foundation for priority queue implementations</li>
                <li>Two-phase algorithm: heap construction + element extraction</li>
            </ul>
        </div>
    </div>
</body>
</html>
