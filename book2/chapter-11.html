<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 11: Merge Sort - Essential Algorithms Handbook</title>
</head>
<body>
    <div class="academic-content">
        <div class="chapter-number">CHAPTER 11</div>
        <h1 class="chapter-title">Merge Sort</h1>
        
        <p class="academic-text">
            Merge sort is a divide-and-conquer algorithm that divides the array into two halves, recursively sorts them, and then merges the sorted halves. It's one of the most efficient stable sorting algorithms with guaranteed O(n log n) time complexity, making it ideal for large datasets and external sorting scenarios.
        </p>
        
        <h2 class="section-title">Problem Statement</h2>
        
        <p class="academic-text">
            Given an array of n elements, sort the array in ascending order using the merge sort algorithm. The algorithm should divide the problem into smaller subproblems, solve them recursively, and combine the results.
        </p>
        
        <div class="definition-box">
            <strong>Input:</strong> Array arr[] of size n with comparable elements<br>
            <strong>Output:</strong> Same array sorted in ascending order<br>
            <strong>Stability:</strong> Stable sorting algorithm (maintains relative order of equal elements)
        </div>
        
        <h2 class="section-title">Approach</h2>
        
        <p class="academic-text">
            Merge sort follows the divide-and-conquer paradigm:
        </p>
        
        <ol>
            <li><strong>Divide:</strong> Split the array into two halves</li>
            <li><strong>Conquer:</strong> Recursively sort both halves</li>
            <li><strong>Combine:</strong> Merge the two sorted halves into a single sorted array</li>
        </ol>
        
        <h2 class="section-title">Algorithm Steps</h2>
        
        <div class="code-block">
Algorithm: MergeSort(arr, left, right)
1. if left < right then
2.     mid = (left + right) / 2
3.     MergeSort(arr, left, mid)
4.     MergeSort(arr, mid+1, right)
5.     Merge(arr, left, mid, right)
6. end if

Algorithm: Merge(arr, left, mid, right)
1. Create temporary arrays L[] and R[]
2. Copy data to temp arrays
3. i = 0, j = 0, k = left
4. while i < n1 AND j < n2 do
5.     if L[i] <= R[j] then
6.         arr[k] = L[i]; i++
7.     else
8.         arr[k] = R[j]; j++
9.     end if
10.    k++
11. end while
12. Copy remaining elements
        </div>
        
        <h2 class="section-title">Implementation</h2>
        
        <div class="code-block">
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/**
 * Merge function - combines two sorted subarrays
 * Merges arr[left..mid] and arr[mid+1..right]
 */
void merge(vector<int>& arr, int left, int mid, int right) {
    // Calculate sizes of two subarrays
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // Create temporary arrays
    vector<int> leftArr(n1), rightArr(n2);
    
    // Copy data to temporary arrays
    for (int i = 0; i < n1; i++)
        leftArr[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        rightArr[j] = arr[mid + 1 + j];
    
    // Merge the temporary arrays back into arr[left..right]
    int i = 0, j = 0, k = left;
    
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k] = leftArr[i];
            i++;
        } else {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }
    
    // Copy remaining elements of leftArr[], if any
    while (i < n1) {
        arr[k] = leftArr[i];
        i++;
        k++;
    }
    
    // Copy remaining elements of rightArr[], if any
    while (j < n2) {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}

/**
 * Merge Sort - Main function
 * Recursively sorts array using divide and conquer
 */
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        // Find the middle point
        int mid = left + (right - left) / 2;
        
        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
}

/**
 * Merge Sort with Statistics
 * Tracks recursive calls and merge operations
 */
struct MergeSortStats {
    int recursiveCalls;
    int mergeOperations;
    int comparisons;
    int arrayAccesses;
    vector<vector<int>> stateHistory;
};

MergeSortStats mergeSortWithStats(vector<int>& arr, int left, int right, MergeSortStats& stats) {
    stats.recursiveCalls++;
    
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        mergeSortWithStats(arr, left, mid, stats);
        mergeSortWithStats(arr, mid + 1, right, stats);
        
        // Merge with statistics
        stats.mergeOperations++;
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        vector<int> leftArr(n1), rightArr(n2);
        
        for (int i = 0; i < n1; i++) {
            leftArr[i] = arr[left + i];
            stats.arrayAccesses++;
        }
        for (int j = 0; j < n2; j++) {
            rightArr[j] = arr[mid + 1 + j];
            stats.arrayAccesses++;
        }
        
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            stats.comparisons++;
            if (leftArr[i] <= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
            stats.arrayAccesses++;
        }
        
        while (i < n1) {
            arr[k] = leftArr[i];
            i++; k++;
            stats.arrayAccesses++;
        }
        while (j < n2) {
            arr[k] = rightArr[j];
            j++; k++;
            stats.arrayAccesses++;
        }
        
        stats.stateHistory.push_back(arr);
    }
    
    return stats;
}

/**
 * Iterative Merge Sort
 * Bottom-up approach without recursion
 */
void iterativeMergeSort(vector<int>& arr) {
    int n = arr.size();
    
    // Merge subarrays in bottom-up manner
    for (int currSize = 1; currSize <= n - 1; currSize = 2 * currSize) {
        // Pick starting point of left sub array
        for (int leftStart = 0; leftStart < n - 1; leftStart += 2 * currSize) {
            // Calculate mid and right points
            int mid = min(leftStart + currSize - 1, n - 1);
            int rightEnd = min(leftStart + 2 * currSize - 1, n - 1);
            
            // Merge subarrays if mid is smaller than rightEnd
            if (mid < rightEnd) {
                merge(arr, leftStart, mid, rightEnd);
            }
        }
    }
}

/**
 * In-place Merge Sort
 * Reduces space complexity using in-place merging
 */
void inPlaceMerge(vector<int>& arr, int start, int mid, int end) {
    int start2 = mid + 1;
    
    // If the direct merge is already sorted
    if (arr[mid] <= arr[start2]) {
        return;
    }
    
    // Two pointers to maintain start of both arrays to merge
    while (start <= mid && start2 <= end) {
        // If element 1 is in right place
        if (arr[start] <= arr[start2]) {
            start++;
        } else {
            int value = arr[start2];
            int index = start2;
            
            // Shift all elements between element 1 and element 2, right by 1
            while (index != start) {
                arr[index] = arr[index - 1];
                index--;
            }
            arr[start] = value;
            
            // Update all the pointers
            start++;
            mid++;
            start2++;
        }
    }
}

void inPlaceMergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        inPlaceMergeSort(arr, left, mid);
        inPlaceMergeSort(arr, mid + 1, right);
        
        inPlaceMerge(arr, left, mid, right);
    }
}

// Example usage and testing
int main() {
    // Test basic merge sort
    vector<int> arr1 = {12, 11, 13, 5, 6, 7};
    cout << "=== Basic Merge Sort ===" << endl;
    cout << "Original: [";
    for (int i = 0; i < arr1.size(); i++) {
        cout << arr1[i];
        if (i < arr1.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    mergeSort(arr1, 0, arr1.size() - 1);
    
    cout << "Sorted: [";
    for (int i = 0; i < arr1.size(); i++) {
        cout << arr1[i];
        if (i < arr1.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    // Test merge sort with statistics
    vector<int> arr2 = {38, 27, 43, 3, 9, 82, 10};
    cout << "\n=== Merge Sort with Statistics ===" << endl;
    cout << "Original: [";
    for (int i = 0; i < arr2.size(); i++) {
        cout << arr2[i];
        if (i < arr2.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    MergeSortStats stats = {0, 0, 0, 0, {}};
    mergeSortWithStats(arr2, 0, arr2.size() - 1, stats);
    
    cout << "Sorted: [";
    for (int i = 0; i < arr2.size(); i++) {
        cout << arr2[i];
        if (i < arr2.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    cout << "Statistics:" << endl;
    cout << "  Recursive calls: " << stats.recursiveCalls << endl;
    cout << "  Merge operations: " << stats.mergeOperations << endl;
    cout << "  Comparisons: " << stats.comparisons << endl;
    cout << "  Array accesses: " << stats.arrayAccesses << endl;
    
    // Test iterative merge sort
    vector<int> arr3 = {64, 34, 25, 12, 22, 11, 90};
    cout << "\n=== Iterative Merge Sort ===" << endl;
    cout << "Original: [";
    for (int i = 0; i < arr3.size(); i++) {
        cout << arr3[i];
        if (i < arr3.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    iterativeMergeSort(arr3);
    
    cout << "Sorted: [";
    for (int i = 0; i < arr3.size(); i++) {
        cout << arr3[i];
        if (i < arr3.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    return 0;
}
        </div>
        
        <h2 class="section-title">Complexity Analysis</h2>
        
        <div class="performance-summary">
            <h3>Time Complexity</h3>
            <ul>
                <li><strong>Best Case:</strong> O(n log n) - Always divides and merges</li>
                <li><strong>Average Case:</strong> O(n log n) - Consistent performance</li>
                <li><strong>Worst Case:</strong> O(n log n) - Guaranteed performance</li>
            </ul>
            
            <h3>Space Complexity</h3>
            <ul>
                <li><strong>Auxiliary Space:</strong> O(n) - Temporary arrays for merging</li>
                <li><strong>Recursion Stack:</strong> O(log n) - Due to recursive calls</li>
                <li><strong>Total Space:</strong> O(n) - Dominated by auxiliary space</li>
            </ul>
            
            <h3>Other Properties</h3>
            <ul>
                <li><strong>Stable:</strong> Yes - Equal elements maintain their relative order</li>
                <li><strong>Adaptive:</strong> No - Always performs the same number of operations</li>
                <li><strong>External Sorting:</strong> Yes - Excellent for sorting large files</li>
            </ul>
        </div>
        
        <h2 class="section-title">Example Walkthrough</h2>
        
        <p class="academic-text">
            Let's trace through merge sort on array [38, 27, 43, 3]:
        </p>
        
        <div class="code-block">
Initial: [38, 27, 43, 3]

Step 1: Divide
[38, 27, 43, 3] â†’ [38, 27] and [43, 3]

Step 2: Divide further
[38, 27] â†’ [38] and [27]
[43, 3] â†’ [43] and [3]

Step 3: Merge [38] and [27]
Compare 38 and 27: 27 < 38
Result: [27, 38]

Step 4: Merge [43] and [3]
Compare 43 and 3: 3 < 43
Result: [3, 43]

Step 5: Merge [27, 38] and [3, 43]
Compare 27 and 3: 3 < 27 â†’ [3, ...]
Compare 27 and 43: 27 < 43 â†’ [3, 27, ...]
Compare 38 and 43: 38 < 43 â†’ [3, 27, 38, ...]
Remaining: 43 â†’ [3, 27, 38, 43]

Final: [3, 27, 38, 43]
        </div>
        
        <h2 class="section-title">Applications</h2>
        
        <p class="academic-text">
            Merge sort is particularly useful in these scenarios:
        </p>
        
        <ul>
            <li><strong>Large Datasets:</strong> Guaranteed O(n log n) performance</li>
            <li><strong>External Sorting:</strong> Sorting data that doesn't fit in memory</li>
            <li><strong>Stable Sorting:</strong> When relative order of equal elements matters</li>
            <li><strong>Linked Lists:</strong> Natural fit for linked list sorting</li>
            <li><strong>Parallel Processing:</strong> Can be easily parallelized</li>
            <li><strong>Database Systems:</strong> Used in database sorting operations</li>
        </ul>
        
        <h2 class="section-title">Interview Tips ðŸŽ¯</h2>
        
        <ul>
            <li><strong>Guaranteed Performance:</strong> Always O(n log n), never degrades</li>
            <li><strong>Stability:</strong> Maintains relative order of equal elements</li>
            <li><strong>Divide and Conquer:</strong> Classic example of the paradigm</li>
            <li><strong>Space Trade-off:</strong> Uses O(n) extra space for guaranteed performance</li>
            <li><strong>External Sorting:</strong> Excellent for sorting large files</li>
        </ul>
        
        <div class="completion-summary">
            <h3>Key Takeaways</h3>
            <ul>
                <li>Merge sort guarantees O(n log n) time complexity in all cases</li>
                <li>Stable sorting algorithm that preserves relative order</li>
                <li>Uses O(n) auxiliary space for temporary arrays</li>
                <li>Excellent for external sorting and large datasets</li>
                <li>Can be implemented both recursively and iteratively</li>
                <li>Foundation for many advanced sorting algorithms</li>
            </ul>
        </div>
    </div>
</body>
</html>
