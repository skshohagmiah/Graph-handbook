<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1: Linear Search - Essential Algorithms Handbook</title>
</head>
<body>
    <div class="academic-content">
        <div class="chapter-number">CHAPTER 1</div>
        <h1 class="chapter-title">Linear Search</h1>
        
        <p class="academic-text">
            Linear search, also known as sequential search, is the simplest searching algorithm. It examines each element in a collection sequentially until the target element is found or the entire collection has been searched.
        </p>
        
        <h2 class="section-title">Problem Statement</h2>
        
        <p class="academic-text">
            Given an array of n elements and a target value, find the index of the target value in the array. If the target is not present, return -1.
        </p>
        
        <div class="definition-box">
            <strong>Input:</strong> Array arr[] of size n, target value x<br>
            <strong>Output:</strong> Index of x in arr[], or -1 if not found<br>
            <strong>Constraint:</strong> Array can be sorted or unsorted
        </div>
        
        <h2 class="section-title">Approach</h2>
        
        <p class="academic-text">
            The linear search algorithm follows a straightforward approach:
        </p>
        
        <ol>
            <li>Start from the first element of the array</li>
            <li>Compare the current element with the target value</li>
            <li>If they match, return the current index</li>
            <li>If they don't match, move to the next element</li>
            <li>Repeat until the target is found or the array is exhausted</li>
            <li>If the array is exhausted without finding the target, return -1</li>
        </ol>
        
        <h2 class="section-title">Algorithm Steps</h2>
        
        <div class="code-block">
Algorithm: LinearSearch(arr, n, x)
1. for i = 0 to n-1 do
2.     if arr[i] == x then
3.         return i
4.     end if
5. end for
6. return -1
        </div>
        
        <h2 class="section-title">Implementation</h2>
        
        <div class="code-block">
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

/**
 * Linear Search Algorithm
 * Searches for a target element in an array sequentially
 * 
 * @param arr: input array
 * @param target: element to search for
 * @return: index of target element, -1 if not found
 */
int linearSearch(const vector&lt;int&gt;&amp; arr, int target) {
    int n = arr.size();
    
    // Traverse the array from left to right
    for (int i = 0; i &lt; n; i++) {
        // Check if current element matches target
        if (arr[i] == target) {
            return i;  // Return index if found
        }
    }
    
    return -1;  // Return -1 if target not found
}

/**
 * Linear Search with early termination for sorted arrays
 * Optimized version that stops early if target is smaller than current element
 */
int linearSearchOptimized(const vector&lt;int&gt;&amp; arr, int target) {
    int n = arr.size();
    
    for (int i = 0; i &lt; n; i++) {
        if (arr[i] == target) {
            return i;
        }
        // Early termination for sorted arrays
        if (arr[i] > target) {
            break;
        }
    }
    
    return -1;
}

/**
 * Linear Search from both ends (bidirectional)
 * Searches from both ends simultaneously
 */
int linearSearchBidirectional(const vector&lt;int&gt;&amp; arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left &lt;= right) {
        // Check left end
        if (arr[left] == target) {
            return left;
        }
        
        // Check right end
        if (arr[right] == target) {
            return right;
        }
        
        left++;
        right--;
    }
    
    return -1;
}

// Example usage and testing
int main() {
    vector&lt;int&gt; arr = {64, 34, 25, 12, 22, 11, 90};
    int target = 22;
    
    cout &lt;&lt; "Array: ";
    for (int x : arr) {
        cout &lt;&lt; x &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    int result = linearSearch(arr, target);
    
    if (result != -1) {
        cout &lt;&lt; "Element " &lt;&lt; target &lt;&lt; " found at index " &lt;&lt; result &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Element " &lt;&lt; target &lt;&lt; " not found" &lt;&lt; endl;
    }
    
    return 0;
}
        </div>
        
        <h2 class="section-title">Complexity Analysis</h2>
        
        <div class="performance-summary">
            <h3>Time Complexity</h3>
            <ul>
                <li><strong>Best Case:</strong> O(1) - Target is the first element</li>
                <li><strong>Average Case:</strong> O(n) - Target is in the middle</li>
                <li><strong>Worst Case:</strong> O(n) - Target is the last element or not present</li>
            </ul>
            
            <h3>Space Complexity</h3>
            <ul>
                <li><strong>Auxiliary Space:</strong> O(1) - Only uses a constant amount of extra space</li>
            </ul>
        </div>
        
        <h2 class="section-title">Example Walkthrough</h2>
        
        <p class="academic-text">
            Let's trace through the algorithm with the array [64, 34, 25, 12, 22, 11, 90] searching for target = 22:
        </p>
        
        <div class="code-block">
Array: [64, 34, 25, 12, 22, 11, 90]
Target: 22

Step 1: i=0, arr[0]=64, 64 â‰  22, continue
Step 2: i=1, arr[1]=34, 34 â‰  22, continue  
Step 3: i=2, arr[2]=25, 25 â‰  22, continue
Step 4: i=3, arr[3]=12, 12 â‰  22, continue
Step 5: i=4, arr[4]=22, 22 = 22, FOUND! Return index 4

Result: Element found at index 4
        </div>
        
        <h2 class="section-title">Applications</h2>
        
        <p class="academic-text">
            Linear search is useful in the following scenarios:
        </p>
        
        <ul>
            <li><strong>Unsorted Data:</strong> When the data is not sorted and sorting would be too expensive</li>
            <li><strong>Small Datasets:</strong> For small arrays where the overhead of more complex algorithms isn't justified</li>
            <li><strong>Linked Lists:</strong> When random access is not available (e.g., linked lists)</li>
            <li><strong>Real-time Systems:</strong> When predictable performance is more important than optimal performance</li>
            <li><strong>Finding All Occurrences:</strong> When you need to find all instances of a value</li>
            <li><strong>Database Table Scans:</strong> When no suitable index exists</li>
        </ul>
        
        <h2 class="section-title">Variations</h2>
        
        <h3>1. Find All Occurrences</h3>
        <div class="code-block">
vector&lt;int&gt; findAllOccurrences(const vector&lt;int&gt;&amp; arr, int target) {
    vector&lt;int&gt; indices;
    
    for (int i = 0; i &lt; arr.size(); i++) {
        if (arr[i] == target) {
            indices.push_back(i);
        }
    }
    
    return indices;
}
        </div>
        
        <h3>2. Linear Search with Sentinel</h3>
        <div class="code-block">
int linearSearchSentinel(vector&lt;int&gt;&amp; arr, int target) {
    int n = arr.size();
    int last = arr[n-1];  // Store last element
    arr[n-1] = target;    // Set sentinel
    
    int i = 0;
    while (arr[i] != target) {
        i++;
    }
    
    arr[n-1] = last;  // Restore last element
    
    if (i &lt; n-1 || arr[n-1] == target) {
        return i;
    }
    return -1;
}
        </div>
        
        <h2 class="section-title">Advantages and Disadvantages</h2>
        
        <div class="definition-box">
            <strong>Advantages:</strong><br>
            â€¢ Simple to understand and implement<br>
            â€¢ Works on both sorted and unsorted arrays<br>
            â€¢ No preprocessing required<br>
            â€¢ Memory efficient (O(1) space)<br>
            â€¢ Stable performance characteristics<br><br>
            
            <strong>Disadvantages:</strong><br>
            â€¢ Inefficient for large datasets (O(n) time)<br>
            â€¢ Cannot take advantage of sorted data<br>
            â€¢ Not suitable for frequently searched data
        </div>
        
        <h2 class="section-title">Interview Tips ðŸŽ¯</h2>
        
        <ul>
            <li><strong>When to Use:</strong> Mention that linear search is optimal for unsorted data or when you need to find all occurrences</li>
            <li><strong>Optimization:</strong> Discuss the bidirectional search variant for potentially better average case</li>
            <li><strong>Trade-offs:</strong> Compare with binary search - linear search works on unsorted data but is slower</li>
            <li><strong>Edge Cases:</strong> Handle empty arrays, single element arrays, and null inputs</li>
            <li><strong>Follow-up:</strong> Be prepared to implement variations like finding the last occurrence or counting occurrences</li>
        </ul>
        
        <div class="completion-summary">
            <h3>Key Takeaways</h3>
            <ul>
                <li>Linear search is the foundation of all searching algorithms</li>
                <li>Time complexity is O(n), space complexity is O(1)</li>
                <li>Best choice for unsorted data and small datasets</li>
                <li>Simple implementation makes it reliable and predictable</li>
                <li>Can be optimized with early termination and bidirectional searching</li>
            </ul>
        </div>
    </div>
</body>
</html>
