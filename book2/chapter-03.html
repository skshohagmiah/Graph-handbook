<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Ternary Search - Essential Algorithms Handbook</title>
</head>
<body>
    <div class="academic-content">
        <div class="chapter-number">CHAPTER 3</div>
        <h1 class="chapter-title">Ternary Search</h1>
        
        <p class="academic-text">
            Ternary search is a divide-and-conquer algorithm that divides the search space into three parts instead of two (like binary search). It's particularly useful for finding the maximum or minimum of a unimodal function, but can also be used for searching in sorted arrays.
        </p>
        
        <h2 class="section-title">Problem Statement</h2>
        
        <p class="academic-text">
            Given a sorted array of n elements and a target value, find the index of the target value. Additionally, ternary search can find the maximum/minimum of a unimodal function over a continuous range.
        </p>
        
        <div class="definition-box">
            <strong>Input:</strong> Sorted array arr[] of size n, target value x<br>
            <strong>Output:</strong> Index of x in arr[], or -1 if not found<br>
            <strong>Alternative Use:</strong> Find extremum of unimodal function f(x) in range [left, right]
        </div>
        
        <h2 class="section-title">Approach</h2>
        
        <p class="academic-text">
            Ternary search works by dividing the search space into three equal parts using two midpoints:
        </p>
        
        <ol>
            <li>Calculate two midpoints: mid1 and mid2 that divide the range into three parts</li>
            <li>Compare the target with elements at both midpoints</li>
            <li>Eliminate one-third of the search space based on comparisons</li>
            <li>Repeat until the target is found or search space is exhausted</li>
        </ol>
        
        <h2 class="section-title">Algorithm Steps</h2>
        
        <div class="code-block">
Algorithm: TernarySearch(arr, left, right, x)
1. if right >= left then
2.     mid1 = left + (right - left) / 3
3.     mid2 = right - (right - left) / 3
4.     
5.     if arr[mid1] == x then
6.         return mid1
7.     if arr[mid2] == x then
8.         return mid2
9.     
10.    if x < arr[mid1] then
11.        return TernarySearch(arr, left, mid1-1, x)
12.    else if x > arr[mid2] then
13.        return TernarySearch(arr, mid2+1, right, x)
14.    else
15.        return TernarySearch(arr, mid1+1, mid2-1, x)
16. end if
17. return -1
        </div>
        
        <h2 class="section-title">Implementation</h2>
        
        <div class="code-block">
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

/**
 * Ternary Search - Iterative Implementation
 * Searches for target in a sorted array using ternary search
 * 
 * @param arr: sorted input array
 * @param target: element to search for
 * @return: index of target element, -1 if not found
 */
int ternarySearch(const vector<int>& arr, int target) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        // Calculate two midpoints
        int mid1 = left + (right - left) / 3;
        int mid2 = right - (right - left) / 3;
        
        // Check if target is at either midpoint
        if (arr[mid1] == target) {
            return mid1;
        }
        if (arr[mid2] == target) {
            return mid2;
        }
        
        // Determine which third to search
        if (target < arr[mid1]) {
            // Target is in the left third
            right = mid1 - 1;
        }
        else if (target > arr[mid2]) {
            // Target is in the right third
            left = mid2 + 1;
        }
        else {
            // Target is in the middle third
            left = mid1 + 1;
            right = mid2 - 1;
        }
    }
    
    return -1;  // Target not found
}

/**
 * Ternary Search - Recursive Implementation
 * Recursive version of ternary search
 */
int ternarySearchRecursive(const vector<int>& arr, int left, int right, int target) {
    // Base case: search space is empty
    if (left > right) {
        return -1;
    }
    
    // Calculate two midpoints
    int mid1 = left + (right - left) / 3;
    int mid2 = right - (right - left) / 3;
    
    // Check if target is found
    if (arr[mid1] == target) {
        return mid1;
    }
    if (arr[mid2] == target) {
        return mid2;
    }
    
    // Recursive calls based on target location
    if (target < arr[mid1]) {
        return ternarySearchRecursive(arr, left, mid1 - 1, target);
    }
    else if (target > arr[mid2]) {
        return ternarySearchRecursive(arr, mid2 + 1, right, target);
    }
    else {
        return ternarySearchRecursive(arr, mid1 + 1, mid2 - 1, target);
    }
}

/**
 * Ternary Search for Maximum of Unimodal Function
 * Finds the maximum value of a unimodal function in given range
 * 
 * @param f: unimodal function
 * @param left: left boundary
 * @param right: right boundary
 * @param eps: precision epsilon
 * @return: x value where f(x) is maximum
 */
double ternarySearchMax(function<double(double)> f, double left, double right, double eps = 1e-9) {
    while (right - left > eps) {
        double mid1 = left + (right - left) / 3.0;
        double mid2 = right - (right - left) / 3.0;
        
        if (f(mid1) < f(mid2)) {
            // Maximum is in the right 2/3
            left = mid1;
        } else {
            // Maximum is in the left 2/3
            right = mid2;
        }
    }
    
    return (left + right) / 2.0;
}

/**
 * Ternary Search for Minimum of Unimodal Function
 * Finds the minimum value of a unimodal function in given range
 */
double ternarySearchMin(function<double(double)> f, double left, double right, double eps = 1e-9) {
    while (right - left > eps) {
        double mid1 = left + (right - left) / 3.0;
        double mid2 = right - (right - left) / 3.0;
        
        if (f(mid1) > f(mid2)) {
            // Minimum is in the right 2/3
            left = mid1;
        } else {
            // Minimum is in the left 2/3
            right = mid2;
        }
    }
    
    return (left + right) / 2.0;
}

/**
 * Example: Find peak element in array using ternary search concept
 * A peak element is greater than or equal to its neighbors
 */
int findPeakElement(const vector<int>& arr) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left < right) {
        int mid1 = left + (right - left) / 3;
        int mid2 = right - (right - left) / 3;
        
        if (arr[mid1] < arr[mid2]) {
            // Peak is more likely in the right part
            left = mid1 + 1;
        } else {
            // Peak is more likely in the left part
            right = mid2 - 1;
        }
    }
    
    return left;
}

// Example usage and testing
int main() {
    // Test ternary search on sorted array
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
    int target = 11;
    
    cout << "Sorted Array: ";
    for (int x : arr) {
        cout << x << " ";
    }
    cout << endl;
    
    int result = ternarySearch(arr, target);
    if (result != -1) {
        cout << "Element " << target << " found at index " << result << endl;
    } else {
        cout << "Element " << target << " not found" << endl;
    }
    
    // Test recursive version
    int recursiveResult = ternarySearchRecursive(arr, 0, arr.size() - 1, target);
    cout << "Recursive result: " << recursiveResult << endl;
    
    // Test ternary search for function maximum
    // Example: f(x) = -(x-5)^2 + 25 (parabola with maximum at x=5)
    auto quadraticFunction = [](double x) {
        return -(x - 5) * (x - 5) + 25;
    };
    
    double maxX = ternarySearchMax(quadraticFunction, 0.0, 10.0);
    cout << "\nMaximum of f(x) = -(x-5)^2 + 25 occurs at x = " << maxX << endl;
    cout << "Maximum value = " << quadraticFunction(maxX) << endl;
    
    // Test peak finding
    vector<int> peakArray = {1, 3, 20, 4, 1, 0};
    int peakIndex = findPeakElement(peakArray);
    cout << "\nPeak element in array: ";
    for (int x : peakArray) {
        cout << x << " ";
    }
    cout << "\nPeak found at index " << peakIndex << " with value " << peakArray[peakIndex] << endl;
    
    return 0;
}
        </div>
        
        <h2 class="section-title">Complexity Analysis</h2>
        
        <div class="performance-summary">
            <h3>Time Complexity</h3>
            <ul>
                <li><strong>Best Case:</strong> O(1) - Target is at one of the midpoints</li>
                <li><strong>Average Case:</strong> O(log‚ÇÉ n) - Eliminates 1/3 of search space each iteration</li>
                <li><strong>Worst Case:</strong> O(log‚ÇÉ n) - Same as average case</li>
            </ul>
            
            <h3>Space Complexity</h3>
            <ul>
                <li><strong>Iterative:</strong> O(1) - Constant extra space</li>
                <li><strong>Recursive:</strong> O(log‚ÇÉ n) - Due to recursion stack</li>
            </ul>
            
            <h3>Comparison with Binary Search</h3>
            <ul>
                <li><strong>Ternary Search:</strong> ~1.26 * log‚ÇÇ n comparisons</li>
                <li><strong>Binary Search:</strong> log‚ÇÇ n comparisons</li>
                <li><strong>Verdict:</strong> Binary search is more efficient for searching</li>
            </ul>
        </div>
        
        <h2 class="section-title">Example Walkthrough</h2>
        
        <p class="academic-text">
            Let's trace through ternary search on array [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] searching for target = 11:
        </p>
        
        <div class="code-block">
Array: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]  (indices 0-9)
Target: 11

Iteration 1:
  left=0, right=9
  mid1 = 0 + (9-0)/3 = 3, arr[3] = 7
  mid2 = 9 - (9-0)/3 = 6, arr[6] = 13
  target=11: 7 < 11 < 13, search middle third
  left=4, right=5

Iteration 2:
  left=4, right=5
  mid1 = 4 + (5-4)/3 = 4, arr[4] = 9
  mid2 = 5 - (5-4)/3 = 5, arr[5] = 11
  arr[5] == target, FOUND! Return index 5

Result: Element found at index 5
        </div>
        
        <h2 class="section-title">Applications</h2>
        
        <p class="academic-text">
            Ternary search has several important applications:
        </p>
        
        <ul>
            <li><strong>Unimodal Function Optimization:</strong> Finding maximum/minimum of functions with single peak/valley</li>
            <li><strong>Mathematical Optimization:</strong> Solving optimization problems in continuous domains</li>
            <li><strong>Computer Graphics:</strong> Finding optimal parameters in rendering algorithms</li>
            <li><strong>Machine Learning:</strong> Hyperparameter optimization for unimodal cost functions</li>
            <li><strong>Physics Simulations:</strong> Finding equilibrium points in physical systems</li>
            <li><strong>Game Theory:</strong> Finding optimal strategies in certain game scenarios</li>
        </ul>
        
        <h2 class="section-title">Advanced Variations</h2>
        
        <h3>1. Ternary Search with Custom Comparator</h3>
        <div class="code-block">
template<typename T, typename Compare>
int ternarySearchCustom(const vector<T>& arr, const T& target, Compare comp) {
    int left = 0;
    int right = arr.size() - 1;
    
    while (left <= right) {
        int mid1 = left + (right - left) / 3;
        int mid2 = right - (right - left) / 3;
        
        if (arr[mid1] == target) return mid1;
        if (arr[mid2] == target) return mid2;
        
        if (comp(target, arr[mid1])) {
            right = mid1 - 1;
        }
        else if (comp(arr[mid2], target)) {
            left = mid2 + 1;
        }
        else {
            left = mid1 + 1;
            right = mid2 - 1;
        }
    }
    
    return -1;
}
        </div>
        
        <h3>2. Discrete Ternary Search for Integer Functions</h3>
        <div class="code-block">
/**
 * Ternary search for discrete unimodal functions
 * Useful when function domain is integers
 */
int discreteTernarySearch(function<int(int)> f, int left, int right) {
    while (right - left > 2) {
        int mid1 = left + (right - left) / 3;
        int mid2 = right - (right - left) / 3;
        
        if (f(mid1) < f(mid2)) {
            left = mid1;
        } else {
            right = mid2;
        }
    }
    
    // Check remaining candidates
    int maxVal = f(left);
    int maxPos = left;
    
    for (int i = left + 1; i <= right; i++) {
        if (f(i) > maxVal) {
            maxVal = f(i);
            maxPos = i;
        }
    }
    
    return maxPos;
}
        </div>
        
        <h3>3. Parallel Ternary Search</h3>
        <div class="code-block">
/**
 * Parallel evaluation of function at both midpoints
 * Useful for expensive function evaluations
 */
double parallelTernarySearch(function<double(double)> f, double left, double right, double eps = 1e-9) {
    while (right - left > eps) {
        double mid1 = left + (right - left) / 3.0;
        double mid2 = right - (right - left) / 3.0;
        
        // These can be computed in parallel
        double f1 = f(mid1);
        double f2 = f(mid2);
        
        if (f1 < f2) {
            left = mid1;
        } else {
            right = mid2;
        }
    }
    
    return (left + right) / 2.0;
}
        </div>
        
        <h2 class="section-title">When to Use Ternary Search</h2>
        
        <div class="definition-box">
            <strong>Use Ternary Search When:</strong><br>
            ‚Ä¢ Finding extrema of unimodal functions<br>
            ‚Ä¢ Working with continuous optimization problems<br>
            ‚Ä¢ Function evaluation is expensive (fewer evaluations than golden section search)<br>
            ‚Ä¢ You need to find maximum/minimum in a specific range<br><br>
            
            <strong>Don't Use Ternary Search When:</strong><br>
            ‚Ä¢ Simple array searching (binary search is more efficient)<br>
            ‚Ä¢ Function has multiple peaks/valleys<br>
            ‚Ä¢ Working with discrete data where binary search applies
        </div>
        
        <h2 class="section-title">Common Pitfalls ‚ö†Ô∏è</h2>
        
        <ul>
            <li><strong>Non-Unimodal Functions:</strong> Ternary search only works on unimodal functions</li>
            <li><strong>Precision Issues:</strong> Use appropriate epsilon for floating-point comparisons</li>
            <li><strong>Integer Overflow:</strong> Be careful with midpoint calculations for large ranges</li>
            <li><strong>Boundary Conditions:</strong> Handle edge cases where search space becomes very small</li>
            <li><strong>Function Evaluation Cost:</strong> Consider the cost of function evaluations vs. search efficiency</li>
        </ul>
        
        <h2 class="section-title">Interview Tips üéØ</h2>
        
        <ul>
            <li><strong>Understand the Difference:</strong> Explain when to use ternary vs binary search</li>
            <li><strong>Unimodal Functions:</strong> Be able to identify and work with unimodal functions</li>
            <li><strong>Optimization Problems:</strong> Recognize when a problem can be solved using ternary search</li>
            <li><strong>Implementation Details:</strong> Handle both discrete and continuous cases</li>
            <li><strong>Complexity Analysis:</strong> Explain why binary search is better for simple searching</li>
        </ul>
        
        <div class="completion-summary">
            <h3>Key Takeaways</h3>
            <ul>
                <li>Ternary search divides search space into three parts instead of two</li>
                <li>Time complexity is O(log‚ÇÉ n), which is slightly worse than binary search for searching</li>
                <li>Excellent for finding extrema of unimodal functions</li>
                <li>Can work with both discrete and continuous domains</li>
                <li>Requires fewer function evaluations than some other optimization methods</li>
                <li>Not suitable for multimodal functions or general array searching</li>
            </ul>
        </div>
    </div>
</body>
</html>
