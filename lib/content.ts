// Content management utilities
export interface Chapter {
  id: string
  chapter: number
  title: string
  slug: string
  part: string
  partNumber: number
  pages: number
  description: string
  keywords: string[]
  lifeInsight: string
  objectives: string[]
  prerequisites: string[]
  diagrams: string[]
  codeExamples: string[]
  exercises: number
  difficulty: "beginner" | "intermediate" | "advanced"
  readingTime: number
  content?: string
}

export interface BookMetadata {
  title: string
  subtitle: string
  author: string
  version: string
  totalPages: number
  description: string
}

// Mock data - will be replaced with actual markdown files
export const bookMetadata: BookMetadata = {
  title: "Graphs, Trees & Algorithms Handbook",
  subtitle: "A Practical Guide to Data Structures, Problem Solving, and Real-World Thinking",
  author: "Shohag Miah",
  version: "1.0.0",
  totalPages: 108,
  description: "Bridge the gap between graph algorithms and real-world thinking",
}

export const chapters: Chapter[] = [
  {
    id: "1",
    chapter: 1,
    title: "What Are Graphs, Really?",
    slug: "what-are-graphs",
    part: "Part I - The Foundations of Graph Thinking",
    partNumber: 1,
    pages: 6,
    description: "Think of graphs as a way to show how things are connected - like a map of relationships in the world around us.",
    keywords: ["graphs", "nodes", "edges", "adjacency"],
    lifeInsight: "Your relationships and goals form an invisible graph",
    objectives: [
      "Understand graph fundamentals",
      "Learn different graph representations",
      "Identify graph types in real-world scenarios",
    ],
    prerequisites: [],
    diagrams: ["graph-types.svg", "adjacency-list-vs-matrix.svg"],
    codeExamples: ["graph-class.py", "graph-class.cpp"],
    exercises: 3,
    difficulty: "beginner",
    readingTime: 15,
  },
  {
    id: "2",
    chapter: 2,
    title: "Graph Properties & Special Types",
    slug: "graph-properties",
    part: "Part I - The Foundations of Graph Thinking",
    partNumber: 1,
    pages: 6,
    description: "Not all graphs are created equal - understanding their special properties unlocks the right algorithms and solutions.",
    keywords: ["connectivity", "cycles", "bipartite", "density"],
    lifeInsight: "Understanding relationships helps you navigate complex systems",
    objectives: [
      "Identify connected and disconnected graphs",
      "Understand cycles and their implications",
      "Recognize bipartite graph structures",
    ],
    prerequisites: ["what-are-graphs"],
    diagrams: ["connectivity-examples.svg", "bipartite-graph.svg"],
    codeExamples: ["connectivity-check.py", "bipartite-detection.cpp"],
    exercises: 4,
    difficulty: "beginner",
    readingTime: 18,
  },
  {
    id: "3",
    chapter: 3,
    title: "Trees â€” The Simplest Graphs",
    slug: "trees",
    part: "Part I - The Foundations of Graph Thinking",
    partNumber: 1,
    pages: 6,
    description: "Trees are everywhere - from your family tree to your computer's file system. They're the most useful special case of graphs.",
    keywords: ["trees", "traversal", "binary trees"],
    lifeInsight: "Trees represent hierarchies of decisions and priorities",
    objectives: [
      "Understand tree structure and properties",
      "Implement tree traversals",
      "Apply trees to real-world problems",
    ],
    prerequisites: ["what-are-graphs"],
    diagrams: ["tree-anatomy.svg", "traversal-animations.svg"],
    codeExamples: ["tree-traversal.py", "tree-traversal.cpp"],
    exercises: 3,
    difficulty: "beginner",
    readingTime: 18,
  },
  {
    id: "4",
    chapter: 4,
    title: "Tries and Prefix Structures",
    slug: "tries",
    part: "Part I - The Foundations of Graph Thinking",
    partNumber: 1,
    pages: 7,
    description: "Tries are the secret behind autocomplete, spell checkers, and fast string searches. They're trees specialized for text!",
    keywords: ["tries", "prefix", "autocomplete", "strings"],
    lifeInsight: "Efficient organization leads to faster discovery",
    objectives: [
      "Build and traverse trie data structures",
      "Implement autocomplete functionality",
      "Optimize string search operations",
    ],
    prerequisites: ["trees"],
    diagrams: ["trie-structure.svg", "autocomplete-demo.svg"],
    codeExamples: ["trie-implementation.py", "autocomplete.cpp"],
    exercises: 4,
    difficulty: "intermediate",
    readingTime: 20,
  },
  {
    id: "5",
    chapter: 5,
    title: "Heaps and Priority Structures",
    slug: "heaps",
    part: "Part I - The Foundations of Graph Thinking",
    partNumber: 1,
    pages: 7,
    description: "Heaps are the secret sauce behind priority queues, efficient sorting, and many graph algorithms like Dijkstra's shortest path!",
    keywords: ["heaps", "priority queue", "sorting"],
    lifeInsight: "Prioritizing effectively helps you focus on what matters most",
    objectives: [
      "Understand heap properties and operations",
      "Implement priority queues",
      "Apply heaps to sorting and graph algorithms",
    ],
    prerequisites: ["trees"],
    diagrams: ["heap-structure.svg", "heap-operations.svg"],
    codeExamples: ["heap-implementation.py", "priority-queue.cpp"],
    exercises: 4,
    difficulty: "intermediate",
    readingTime: 22,
  },
  {
    id: "6",
    chapter: 6,
    title: "Traversal Algorithms",
    slug: "traversal-algorithms",
    part: "Part II - Core Algorithms",
    partNumber: 2,
    pages: 8,
    description: "Graph traversal is like exploring a maze - you need systematic strategies to visit every room without getting lost.",
    keywords: ["BFS", "DFS", "traversal", "cycle detection"],
    lifeInsight: "BFS = explore broadly; DFS = commit deeply; Cycles = stuck loops",
    objectives: ["Implement BFS and DFS", "Detect cycles in graphs", "Apply traversals to real problems"],
    prerequisites: ["what-are-graphs"],
    diagrams: ["bfs-animation.svg", "dfs-animation.svg", "cycle-detection-states.svg"],
    codeExamples: ["bfs.py", "dfs.py", "cycle-detection.cpp"],
    exercises: 5,
    difficulty: "intermediate",
    readingTime: 25,
  },
  {
    id: "7",
    chapter: 7,
    title: "Shortest Path Algorithms",
    slug: "shortest-path-algorithms",
    part: "Part II - Core Algorithms",
    partNumber: 2,
    pages: 10,
    description: "Finding the shortest path is one of the most fundamental problems in computer science - from GPS navigation to network routing to game AI.",
    keywords: ["dijkstra", "bellman-ford", "a-star", "floyd-warshall"],
    lifeInsight: "The shortest path isn't always the fastest - consider all costs",
    objectives: ["Master Dijkstra's algorithm", "Handle negative weights with Bellman-Ford", "Apply A* for heuristic search"],
    prerequisites: ["traversal-algorithms", "heaps"],
    diagrams: ["dijkstra-demo.svg", "bellman-ford-example.svg", "a-star-heuristic.svg"],
    codeExamples: ["dijkstra.py", "bellman-ford.cpp", "a-star.py"],
    exercises: 6,
    difficulty: "intermediate",
    readingTime: 30,
  },
  {
    id: "8",
    chapter: 8,
    title: "Minimum Spanning Trees",
    slug: "minimum-spanning-trees",
    part: "Part II - Core Algorithms",
    partNumber: 2,
    pages: 8,
    description: "Minimum spanning trees find the cheapest way to connect all nodes in a network - essential for designing efficient infrastructure.",
    keywords: ["kruskal", "prim", "union-find", "mst"],
    lifeInsight: "Efficient connections create strong networks with minimal cost",
    objectives: ["Implement Kruskal's and Prim's algorithms", "Master Union-Find data structure", "Design efficient network infrastructures"],
    prerequisites: ["traversal-algorithms"],
    diagrams: ["kruskal-demo.svg", "prim-demo.svg", "union-find-operations.svg"],
    codeExamples: ["kruskal.py", "prim.cpp", "union-find.py"],
    exercises: 5,
    difficulty: "intermediate",
    readingTime: 28,
  },
  {
    id: "9",
    chapter: 9,
    title: "Topological Sorting & Dynamic Programming on DAGs",
    slug: "topological-sorting",
    part: "Part II - Core Algorithms",
    partNumber: 2,
    pages: 9,
    description: "Topological sorting solves dependency problems - from course prerequisites to build systems to project scheduling.",
    keywords: ["topological sort", "DAG", "dynamic programming", "dependencies"],
    lifeInsight: "Understanding dependencies helps you plan and execute complex projects",
    objectives: ["Master topological sorting algorithms", "Apply DP to DAG problems", "Solve scheduling and dependency problems"],
    prerequisites: ["traversal-algorithms"],
    diagrams: ["topological-sort-demo.svg", "dag-dp-example.svg", "project-scheduling.svg"],
    codeExamples: ["topological-sort.py", "dag-dp.cpp", "project-scheduler.py"],
    exercises: 5,
    difficulty: "advanced",
    readingTime: 32,
  },
  {
    id: "10",
    chapter: 10,
    title: "Flow Networks and Optimization",
    slug: "flow-networks",
    part: "Part III - Advanced Topics",
    partNumber: 3,
    pages: 8,
    description: "Flow networks model how resources move through systems - from water in pipes to data in networks to goods in supply chains.",
    keywords: ["max flow", "min cut", "ford-fulkerson", "edmonds-karp", "network flow"],
    lifeInsight: "Understanding bottlenecks helps you optimize resource allocation and identify system vulnerabilities",
    objectives: ["Understand max flow and min-cut theorem", "Implement Ford-Fulkerson and Edmonds-Karp algorithms", "Apply flow networks to real-world optimization problems"],
    prerequisites: ["traversal-algorithms", "shortest-path-algorithms"],
    diagrams: ["flow-network-example.svg", "residual-graph.svg", "min-cut-visualization.svg"],
    codeExamples: ["ford-fulkerson.cpp", "edmonds-karp.py", "bipartite-matching.cpp"],
    exercises: 5,
    difficulty: "advanced",
    readingTime: 35,
  },
  {
    id: "11",
    chapter: 11,
    title: "Graph Coloring & Matching",
    slug: "graph-coloring",
    part: "Part III - Advanced Topics",
    partNumber: 3,
    pages: 7,
    description: "Graph coloring solves scheduling conflicts, while matching pairs resources optimally - two fundamental problems in optimization.",
    keywords: ["graph coloring", "chromatic number", "matching", "bipartite matching", "scheduling"],
    lifeInsight: "Optimal assignment and conflict resolution are key to efficient resource management",
    objectives: ["Master greedy coloring algorithms", "Implement bipartite and maximum matching", "Apply coloring and matching to scheduling problems"],
    prerequisites: ["graph-properties", "flow-networks"],
    diagrams: ["graph-coloring-example.svg", "bipartite-matching.svg", "exam-scheduling.svg"],
    codeExamples: ["greedy-coloring.cpp", "bipartite-matching.py", "exam-scheduler.cpp"],
    exercises: 5,
    difficulty: "advanced",
    readingTime: 30,
  },
  {
    id: "12",
    chapter: 12,
    title: "Advanced Graph Concepts",
    slug: "advanced-concepts",
    part: "Part III - Advanced Topics",
    partNumber: 3,
    pages: 6,
    description: "Understanding critical connections, strongly connected components, and special paths reveals the deep structure and vulnerabilities of networks.",
    keywords: ["articulation points", "bridges", "tarjan", "scc", "eulerian", "hamiltonian"],
    lifeInsight: "Identifying critical points and connections helps you understand system vulnerabilities and robustness",
    objectives: ["Find articulation points and bridges", "Implement Tarjan's SCC algorithm", "Understand Eulerian and Hamiltonian paths", "Analyze network reliability"],
    prerequisites: ["traversal-algorithms", "graph-properties"],
    diagrams: ["articulation-points.svg", "scc-example.svg", "eulerian-path.svg"],
    codeExamples: ["articulation-points.cpp", "tarjan-scc.cpp", "eulerian-path.py"],
    exercises: 5,
    difficulty: "advanced",
    readingTime: 28,
  },
  {
    id: "13",
    chapter: 13,
    title: "Graphs in Computer Science",
    slug: "graphs-in-cs",
    part: "Part IV - Applied Graph Thinking",
    partNumber: 4,
    pages: 6,
    description: "Graphs are the invisible backbone of computer science - from compilers to operating systems to AI.",
    keywords: ["compilers", "ast", "operating systems", "deadlock", "databases", "neural networks", "pagerank"],
    lifeInsight: "Understanding how graphs power real systems reveals the deep connections in computer science",
    objectives: ["Understand AST and compiler graphs", "Detect deadlocks in operating systems", "Learn graph database concepts", "See neural networks as graphs", "Understand PageRank algorithm"],
    prerequisites: ["traversal-algorithms", "topological-sorting"],
    diagrams: ["ast-example.svg", "deadlock-graph.svg", "neural-network-dag.svg"],
    codeExamples: ["ast-node.cpp", "deadlock-detector.cpp", "pagerank.py"],
    exercises: 4,
    difficulty: "intermediate",
    readingTime: 25,
  },
  {
    id: "14",
    chapter: 14,
    title: "Pattern Recognition in Graphs",
    slug: "pattern-recognition",
    part: "Part IV - Applied Graph Thinking",
    partNumber: 4,
    pages: 5,
    description: "Finding patterns in graphs reveals hidden structures - from tight-knit communities to influential clusters.",
    keywords: ["cliques", "community detection", "clustering", "modularity", "social networks"],
    lifeInsight: "Recognizing patterns in networks helps you understand group dynamics and hidden structures",
    objectives: ["Find cliques and complete subgraphs", "Detect communities using modularity", "Apply clustering techniques", "Analyze social networks"],
    prerequisites: ["graph-properties", "traversal-algorithms"],
    diagrams: ["clique-example.svg", "community-structure.svg"],
    codeExamples: ["bron-kerbosch.cpp", "louvain-method.cpp"],
    exercises: 4,
    difficulty: "advanced",
    readingTime: 22,
  },
  {
    id: "15",
    chapter: 15,
    title: "Graphs in Real Life & Human Decisions",
    slug: "real-life-decisions",
    part: "Part IV - Applied Graph Thinking",
    partNumber: 4,
    pages: 6,
    description: "The algorithms you've learned aren't just for computers - they're mental models for navigating life's complex decisions.",
    keywords: ["career planning", "decision making", "life optimization", "goal setting", "time management"],
    lifeInsight: "Graph algorithms provide mental models for optimizing your career, relationships, and daily decisions",
    objectives: ["Apply Dijkstra's to career planning", "Use MST for relationship management", "Apply topological sort to goals", "Use graph coloring for scheduling", "Make better decisions with graph thinking"],
    prerequisites: ["shortest-path-algorithms", "minimum-spanning-trees", "topological-sorting", "graph-coloring"],
    diagrams: ["career-path.svg", "social-network-mst.svg", "goal-dependencies.svg"],
    codeExamples: ["career-planner.cpp"],
    exercises: 5,
    difficulty: "beginner",
    readingTime: 20,
  },
  {
    id: "16",
    chapter: 16,
    title: "Building the Graph Mindset",
    slug: "graph-mindset",
    part: "Part IV - Applied Graph Thinking",
    partNumber: 4,
    pages: 5,
    description: "Once you see the world as graphs, you can't unsee it. Transform how you think about systems, patterns, and problems.",
    keywords: ["systems thinking", "mental models", "pattern recognition", "optimization", "graph mindset"],
    lifeInsight: "The graph mindset is a meta-skill that transforms how you see and solve complex problems",
    objectives: ["Develop systems thinking", "Recognize universal graph patterns", "Apply graph analysis framework", "Build the graph mindset", "Navigate life as a graph"],
    prerequisites: ["all-previous-chapters"],
    diagrams: ["systems-graph.svg", "feedback-loops.svg", "bottleneck-example.svg"],
    codeExamples: [],
    exercises: 3,
    difficulty: "beginner",
    readingTime: 18,
  },
  
  // APPENDICES
  {
    id: "A",
    chapter: 17,
    title: "Appendix A: Graph Terminology Reference",
    slug: "terminology-reference",
    part: "Appendices",
    partNumber: 5,
    pages: 2,
    description: "Complete glossary of graph theory terms - your quick reference guide.",
    keywords: ["glossary", "terminology", "definitions", "reference"],
    lifeInsight: "Having precise terminology helps you think clearly about complex problems",
    objectives: ["Understand all graph theory terms", "Quick reference lookup"],
    prerequisites: [],
    diagrams: [],
    codeExamples: [],
    exercises: 0,
    difficulty: "beginner",
    readingTime: 10,
  },
  {
    id: "B",
    chapter: 18,
    title: "Appendix B: Algorithm Complexity Table",
    slug: "complexity-table",
    part: "Appendices",
    partNumber: 5,
    pages: 2,
    description: "Time and space complexity for all algorithms with decision matrix.",
    keywords: ["complexity", "big-o", "performance", "algorithm selection"],
    lifeInsight: "Knowing complexity helps you choose the right algorithm for the job",
    objectives: ["Understand algorithm complexities", "Choose optimal algorithms"],
    prerequisites: [],
    diagrams: [],
    codeExamples: [],
    exercises: 0,
    difficulty: "beginner",
    readingTime: 8,
  },
  {
    id: "C",
    chapter: 19,
    title: "Appendix C: Practice Problems & Solutions",
    slug: "practice-problems",
    part: "Appendices",
    partNumber: 5,
    pages: 3,
    description: "30 curated problems from easy to hard with solutions and platform links.",
    keywords: ["practice", "problems", "leetcode", "exercises"],
    lifeInsight: "Deliberate practice is the only way to master graph algorithms",
    objectives: ["Practice graph algorithms", "Build problem-solving skills"],
    prerequisites: [],
    diagrams: [],
    codeExamples: [],
    exercises: 30,
    difficulty: "intermediate",
    readingTime: 15,
  },
  {
    id: "D",
    chapter: 20,
    title: "Appendix D: Visual Cheatsheet",
    slug: "visual-cheatsheet",
    part: "Appendices",
    partNumber: 5,
    pages: 2,
    description: "One-page summaries of graph types, algorithms, and common patterns.",
    keywords: ["cheatsheet", "visual", "patterns", "quick reference"],
    lifeInsight: "Visual patterns help you recognize problems and solutions instantly",
    objectives: ["Recognize graph patterns", "Quick algorithm selection"],
    prerequisites: [],
    diagrams: ["graph-types.svg", "decision-tree.svg"],
    codeExamples: [],
    exercises: 0,
    difficulty: "beginner",
    readingTime: 12,
  },
  {
    id: "E",
    chapter: 21,
    title: "Appendix E: Further Reading & Resources",
    slug: "further-reading",
    part: "Appendices",
    partNumber: 5,
    pages: 2,
    description: "Books, online tools, and research topics to continue your journey.",
    keywords: ["resources", "books", "tools", "research"],
    lifeInsight: "Learning never stops - these resources will take you deeper",
    objectives: ["Discover advanced resources", "Continue learning journey"],
    prerequisites: [],
    diagrams: [],
    codeExamples: [],
    exercises: 0,
    difficulty: "beginner",
    readingTime: 10,
  },
]

export function getChapterBySlug(slug: string): Chapter | undefined {
  return chapters.find((ch) => ch.slug === slug)
}

export function getChapterIndex(slug: string): number {
  return chapters.findIndex((ch) => ch.slug === slug)
}

export function getPreviousChapter(slug: string): Chapter | undefined {
  const index = getChapterIndex(slug)
  return index > 0 ? chapters[index - 1] : undefined
}

export function getNextChapter(slug: string): Chapter | undefined {
  const index = getChapterIndex(slug)
  return index < chapters.length - 1 ? chapters[index + 1] : undefined
}
