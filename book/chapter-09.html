<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 9: Topological Sorting & Dynamic Programming on DAGs</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 9</div>
    <h1 class="chapter-title">Topological Sorting & Dynamic Programming on DAGs</h1>
    
    <div class="definition-box">
        "Topological sorting solves dependency problems - from course prerequisites to build systems to project scheduling."
    </div>

    <p class="academic-text">Ever wonder how your computer knows which files to compile first? Or how project managers schedule tasks with dependencies? The answer is topological sorting! It's the algorithm that puts things in the right order when some things must come before others.</p>
    
    <p class="academic-text"><strong>What is topological sorting?</strong> It's a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u,v), vertex u comes before v in the ordering.</p>
    
    <p class="academic-text"><strong>Real-world applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Course scheduling:</strong> Taking prerequisites before advanced courses</li>
        <li class="academic-text"><strong>Build systems:</strong> Compiling dependencies before main programs</li>
        <li class="academic-text"><strong>Project management:</strong> Scheduling tasks with dependencies</li>
        <li class="academic-text"><strong>Package managers:</strong> Installing dependencies in correct order</li>
    </ul>

    <h2 class="section-title" id="ch9-1">9.1 Topological Ordering and Kahn's Algorithm</h2>
    
    <p class="academic-text">Kahn's algorithm is an intuitive approach to topological sorting. It repeatedly removes vertices with no incoming edges, which represents tasks that have no remaining dependencies.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üìã Kahn's Algorithm Strategy</h3>
        <p class="academic-text"><strong>Kahn's Algorithm</strong> builds topological order by removing vertices with no dependencies.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Track in-degrees:</strong> Count incoming edges for each vertex</li>
            <li class="academic-text"><strong>Start with zero in-degree:</strong> Process vertices with no dependencies first</li>
            <li class="academic-text"><strong>Remove and update:</strong> Remove vertex and decrease neighbors' in-degrees</li>
            <li class="academic-text"><strong>Cycle detection:</strong> If we can't process all vertices, there's a cycle</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Course Prerequisites Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> C[Physics 201]
            B[CS 101] --> D[Data Structures]
            A --> D
            C --> E[Advanced Physics]
            D --> F[Algorithms]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Valid order: Math 101, CS 101, Physics 201, Data Structures, Advanced Physics, Algorithms</p>
    </div>

    <pre class="code-block">// Kahn's Algorithm Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

class TopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> inDegree;
    int numVertices;
    
public:
    TopologicalSort(int n) : numVertices(n), graph(n), inDegree(n, 0) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
        inDegree[to]++;
    }
    
    // Kahn's algorithm for topological sorting
    vector<int> kahnSort() {
        vector<int> result;
        queue<int> zeroInDegree;
        
        // Find all vertices with no incoming edges
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                zeroInDegree.push(i);
            }
        }
        
        while (!zeroInDegree.empty()) {
            int current = zeroInDegree.front();
            zeroInDegree.pop();
            result.push_back(current);
            
            // Remove current vertex and update in-degrees
            for (int neighbor : graph[current]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    zeroInDegree.push(neighbor);
                }
            }
        }
        
        // Check for cycles
        if (result.size() != numVertices) {
            return {}; // Cycle detected - no valid topological order
        }
        
        return result;
    }
    
    // Check if graph is a DAG
    bool isDAG() {
        return kahnSort().size() == numVertices;
    }
};</pre>

    <h2 class="section-title" id="ch9-2">9.2 DFS-Based Topological Sort</h2>
    
    <p class="academic-text">Another approach to topological sorting uses DFS. The key insight is that in a DFS traversal of a DAG, a vertex should appear in the topological order after all vertices in its DFS subtree.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîç DFS Topological Strategy</h3>
        <p class="academic-text"><strong>DFS Topological Sort</strong> uses post-order DFS traversal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Post-order traversal:</strong> Add vertex to result after visiting all descendants</li>
            <li class="academic-text"><strong>Reverse order:</strong> Reverse the post-order to get topological order</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use three colors to detect back edges</li>
            <li class="academic-text"><strong>Recursive approach:</strong> Natural recursive implementation</li>
        </ul>
    </div>

    <pre class="code-block">// DFS-Based Topological Sort
class DFSTopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> color; // 0: white, 1: gray, 2: black
    vector<int> result;
    bool hasCycle;
    
    void dfsVisit(int vertex) {
        color[vertex] = 1; // Mark as gray (processing)
        
        for (int neighbor : graph[vertex]) {
            if (color[neighbor] == 1) {
                hasCycle = true; // Back edge found - cycle detected
                return;
            }
            if (color[neighbor] == 0) {
                dfsVisit(neighbor);
            }
        }
        
        color[vertex] = 2; // Mark as black (finished)
        result.push_back(vertex); // Add to result in post-order
    }
    
public:
    DFSTopologicalSort(int n) : graph(n), color(n, 0), hasCycle(false) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
    }
    
    vector<int> topologicalSort() {
        result.clear();
        hasCycle = false;
        fill(color.begin(), color.end(), 0);
        
        // Start DFS from all unvisited vertices
        for (int i = 0; i < graph.size(); i++) {
            if (color[i] == 0) {
                dfsVisit(i);
                if (hasCycle) return {}; // Cycle detected
            }
        }
        
        // Reverse to get correct topological order
        reverse(result.begin(), result.end());
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch9-3">9.3 Dynamic Programming on DAGs</h2>
    
    <p class="academic-text">DAGs have a special property that makes dynamic programming very natural: they have no cycles, so we can process vertices in topological order and guarantee that when we process a vertex, all its dependencies have already been computed.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">‚ö° DP on DAGs Strategy</h3>
        <p class="academic-text"><strong>Dynamic Programming on DAGs</strong> leverages topological ordering for optimal substructure.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Topological order:</strong> Process vertices in dependency order</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Solution depends on optimal solutions to subproblems</li>
            <li class="academic-text"><strong>No cycles:</strong> No need to worry about circular dependencies</li>
            <li class="academic-text"><strong>Memoization:</strong> Store computed results to avoid recomputation</li>
        </ul>
    </div>

    <pre class="code-block">// Dynamic Programming on DAGs
class DAGDynamicProgramming {
private:
    vector<vector<pair<int, int>>> graph; // adjacency list with weights
    vector<int> dp;
    vector<bool> visited;
    
public:
    DAGDynamicProgramming(int n) : graph(n), dp(n, -1), visited(n, false) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back({to, weight});
    }
    
    // Find longest path from source using DP
    int longestPath(int source, int target) {
        if (source == target) return 0;
        if (visited[source]) return dp[source];
        
        visited[source] = true;
        dp[source] = INT_MIN; // Initialize to negative infinity
        
        for (auto [neighbor, weight] : graph[source]) {
            int pathLength = longestPath(neighbor, target);
            if (pathLength != INT_MIN) {
                dp[source] = max(dp[source], weight + pathLength);
            }
        }
        
        return dp[source];
    }
    
    // Count number of paths from source to target
    int countPaths(int source, int target) {
        if (source == target) return 1;
        
        vector<int> pathCount(graph.size(), -1);
        return countPathsHelper(source, target, pathCount);
    }
    
private:
    int countPathsHelper(int current, int target, vector<int>& pathCount) {
        if (current == target) return 1;
        if (pathCount[current] != -1) return pathCount[current];
        
        pathCount[current] = 0;
        for (auto [neighbor, weight] : graph[current]) {
            pathCount[current] += countPathsHelper(neighbor, target, pathCount);
        }
        
        return pathCount[current];
    }
};</pre>

    <h2 class="section-title" id="ch9-4">9.4 Longest and Shortest Paths in DAGs</h2>
    
    <p class="academic-text">Finding longest and shortest paths in general graphs can be complex, but in DAGs, we can solve these problems efficiently using topological sorting and dynamic programming.</p>

    <pre class="code-block">// Longest and Shortest Paths in DAGs
class DAGPaths {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    DAGPaths(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Find shortest paths from source using topological sort
    vector<int> shortestPaths(int source) {
        vector<int> dist(numVertices, INT_MAX);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MAX) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight < dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
    // Find longest paths from source
    vector<int> longestPaths(int source) {
        vector<int> dist(numVertices, INT_MIN);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MIN) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight > dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
private:
    vector<int> getTopologicalOrder() {
        vector<int> inDegree(numVertices, 0);
        for (int u = 0; u < numVertices; u++) {
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]++;
            }
        }
        
        queue<int> q;
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        vector<int> topoOrder;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            topoOrder.push_back(u);
            
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]--;
                if (inDegree[edge.to] == 0) {
                    q.push(edge.to);
                }
            }
        }
        
        return topoOrder;
    }
    
public:
    // Demo function for project scheduling
    static void demo() {
        DAGPaths scheduler(6);
        
        // Project tasks with durations (weights)
        scheduler.addEdge(0, 1, 3);  // Task A -> B (3 days)
        scheduler.addEdge(0, 2, 2);  // Task A -> C (2 days)
        scheduler.addEdge(1, 3, 4);  // Task B -> D (4 days)
        scheduler.addEdge(2, 3, 1);  // Task C -> D (1 day)
        scheduler.addEdge(3, 4, 2);  // Task D -> E (2 days)
        scheduler.addEdge(1, 5, 3);  // Task B -> F (3 days)
        
        vector<int> longest = scheduler.longestPaths(0);
        
        cout << "Critical path analysis:" << endl;
        char labels[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        for (int i = 0; i < 6; i++) {
            cout << "Task " << labels[i] << ": " << longest[i] << " days" << endl;
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üìä Topological Sorting Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kahn's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Approach:</strong> Remove vertices with no dependencies</li>
                    <li class="academic-text"><strong>Intuitive:</strong> Mirrors real-world scheduling</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS-Based Sort</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Approach:</strong> Post-order DFS traversal</li>
                    <li class="academic-text"><strong>Natural:</strong> Recursive implementation</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 9 Complete!</h3>
        <p class="academic-text">You've mastered topological sorting and DAG algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Kahn's Algorithm</strong> - intuitive dependency-based sorting</li>
            <li class="academic-text">‚úÖ <strong>DFS Topological Sort</strong> - recursive post-order approach</li>
            <li class="academic-text">‚úÖ <strong>Dynamic Programming on DAGs</strong> - leveraging topological order</li>
            <li class="academic-text">‚úÖ <strong>Path Problems in DAGs</strong> - longest/shortest paths efficiently</li>
        </ul>
        
        <p class="academic-text">These algorithms solve fundamental scheduling and dependency problems that appear everywhere in computer science and project management. You now have the complete toolkit for core graph algorithms!</p>
    </div>
</body>
</html>
