<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Trees â€” The Simplest Graphs</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 3</div>
    <h1 class="chapter-title">Trees â€” The Simplest Graphs</h1>
    
    <div class="definition-box">
        "Trees are everywhere - from your family tree to your computer's file system. They're the most useful special case of graphs."
    </div>

    <p class="academic-text">Trees represent one of the most elegant and powerful structures in computer science - they're connected graphs with no cycles, creating a perfect balance of structure and simplicity that makes them indispensable for organizing, searching, and processing hierarchical data. This seemingly simple constraint - being connected yet acyclic - gives trees remarkable mathematical properties and makes them the foundation for countless algorithms and data structures.</p>
    
    <p class="academic-text">The beauty of trees lies in their natural ability to model hierarchical relationships that pervade both the digital and physical world. Unlike general graphs where relationships can be complex and multidirectional, trees impose a clear structure: there's exactly one path between any two nodes, creating unambiguous parent-child relationships that mirror how we naturally think about organization, classification, and decision-making processes.</p>

    <p class="academic-text">Trees are fundamental to computer science because they solve the critical problem of organizing data in ways that enable efficient searching, sorting, and retrieval. They provide the mathematical foundation for databases, file systems, compilers, artificial intelligence, and countless other applications. Understanding trees is essential because they appear everywhere - from the simple decision trees that power recommendation algorithms to the complex B-trees that make database queries lightning-fast.</p>
    
    <p class="academic-text"><strong>Trees surround you in daily digital life:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>File systems:</strong> Every folder and file on your computer forms a tree structure, enabling efficient navigation and organization of millions of files</li>
        <li class="academic-text"><strong>Family genealogy:</strong> Ancestry relationships naturally form trees, allowing us to trace lineage and understand genetic inheritance patterns</li>
        <li class="academic-text"><strong>Corporate hierarchies:</strong> Organization charts use tree structures to define reporting relationships and decision-making authority</li>
        <li class="academic-text"><strong>Decision processes:</strong> From medical diagnosis to financial planning, decision trees help break complex choices into manageable, sequential decisions</li>
        <li class="academic-text"><strong>Web technologies:</strong> HTML DOM structures, XML documents, and JSON data all use tree formats for organizing and parsing information</li>
        <li class="academic-text"><strong>Search engines:</strong> Google's search algorithms use tree structures to index and rapidly retrieve information from billions of web pages</li>
    </ul>

    <h2 class="section-title" id="ch3-1">3.1 Tree Properties and Terminology</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸŒ³ Tree Definition</h3>
        <p class="academic-text">A <strong>tree</strong> is a connected graph with no cycles.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Connected:</strong> You can reach any node from any other node</li>
            <li class="academic-text"><strong>Acyclic:</strong> No circular paths - there's exactly one path between any two nodes</li>
            <li class="academic-text"><strong>Minimal:</strong> Remove any edge and it becomes disconnected</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>The mathematical elegance of trees:</strong> The simple definition of trees as connected acyclic graphs leads to a cascade of remarkable mathematical properties that make them incredibly useful and predictable. These properties aren't just theoretical curiosities - they're the foundation for designing efficient algorithms and understanding why trees work so well for organizing data.</p>

    <p class="academic-text">Understanding these properties is crucial because they tell us exactly what we can expect from any tree structure, regardless of its size or application. They provide guarantees about connectivity, uniqueness of paths, and structural constraints that algorithms can rely on. This predictability is what makes trees so powerful for computer science applications.</p>
    
    <p class="academic-text"><strong>Fundamental tree properties with profound implications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Exact edge count:</strong> A tree with n vertices has exactly n-1 edges - no more, no less. This precise relationship means trees are "minimally connected" - they have just enough edges to stay connected, with no redundancy.</li>
        <li class="academic-text"><strong>Unique path property:</strong> There's exactly one path between any two vertices. This eliminates ambiguity in navigation and makes algorithms deterministic - there's never a question about which route to take.</li>
        <li class="academic-text"><strong>Cycle creation:</strong> Adding any single edge to a tree creates exactly one cycle. This property is fundamental to algorithms that build minimum spanning trees and detect when graphs become cyclic.</li>
        <li class="academic-text"><strong>Fragility property:</strong> Removing any edge disconnects the tree into exactly two components. This makes trees vulnerable to edge failures but also enables efficient tree-cutting algorithms.</li>
        <li class="academic-text"><strong>Minimality:</strong> Trees are minimal connected graphs - you can't remove any edge without losing connectivity, making them the most efficient way to connect n vertices.</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Example (Family Tree):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Grandpa] --> B[Dad]
            A --> C[Uncle]
            B --> D[You]
            B --> E[Sister]
            C --> F[Cousin]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">6 nodes, 5 edges - exactly n-1 edges for n nodes!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A tree is a connected acyclic graph. For n vertices, it has exactly n-1 edges.
        </div>
    </div>

    <p class="academic-text"><strong>Tree Terminology:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Root:</strong> The top node (Grandpa in our example)</li>
        <li class="academic-text"><strong>Parent:</strong> Node directly above (Dad is parent of You)</li>
        <li class="academic-text"><strong>Child:</strong> Node directly below (You are child of Dad)</li>
        <li class="academic-text"><strong>Leaf:</strong> Node with no children (You, Sister, Cousin)</li>
        <li class="academic-text"><strong>Height:</strong> Longest path from root to leaf (3 levels)</li>
        <li class="academic-text"><strong>Depth:</strong> Distance from root to a node</li>
    </ul>

    <pre class="code-block">// Simple Node structure
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

// Simple node - just holds data and connections
struct Node {
    string data;
    vector<Node*> children;
    
    Node(string value) : data(value) {}
};

// Tree builder functions
class TreeBuilder {
public:
    // Create a simple family tree from arrays
    static Node* buildFamilyTree() {
        Node* grandpa = new Node("Grandpa");
        Node* dad = new Node("Dad");
        Node* uncle = new Node("Uncle");
        Node* you = new Node("You");
        Node* sister = new Node("Sister");
        Node* cousin = new Node("Cousin");
        
        // Build the tree structure
        grandpa->children = {dad, uncle};
        dad->children = {you, sister};
        uncle->children = {cousin};
        
        return grandpa;
    }
    
    // Build tree from parent-child pairs
    static Node* buildFromPairs(vector<pair<string, string>> relationships) {
        // relationships = {("parent", "child"), ("parent", "child2"), ...}
        // Implementation would map relationships to tree structure
        // Simplified for clarity
        return nullptr;
    }
    
    // Print tree in a simple way
    static void printTree(Node* root, int indent = 0) {
        if (root == nullptr) return;
        
        for (int i = 0; i < indent; i++) cout << "  ";
        cout << root->data << endl;
        
        for (Node* child : root->children) {
            printTree(child, indent + 1);
        }
    }
    
    // Check if node is a leaf (no children)
    static bool isLeaf(Node* node) {
        return node->children.empty();
    }
};</pre>

    <h2 class="section-title" id="ch3-2">3.2 Binary Trees, N-ary Trees, Binary Search Trees</h2>

    <p class="academic-text"><strong>Binary Trees: The Foundation of Efficient Data Structures</strong></p>
    <p class="academic-text">Binary trees represent one of the most important and versatile data structures in computer science. By restricting each node to have at most two children - conventionally called "left" and "right" - binary trees create a perfect balance between simplicity and power. This constraint enables elegant recursive algorithms and provides the foundation for numerous advanced data structures including heaps, AVL trees, and red-black trees.</p>

    <p class="academic-text">The power of binary trees lies in their recursive structure: every subtree of a binary tree is itself a binary tree. This self-similarity makes them perfect for divide-and-conquer algorithms and enables elegant recursive solutions to complex problems. The binary constraint also ensures that tree operations have predictable performance characteristics, especially when the tree is balanced.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[A] --> B[B]
            A --> C[C]
            B --> D[D]
            B --> E[E]
            C --> F[F]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each node has at most 2 children</p>
    </div>

    <p class="academic-text"><strong>Binary Search Trees: Ordered Structures for Logarithmic Performance</strong></p>
    <p class="academic-text">Binary Search Trees (BSTs) represent one of the most elegant solutions to the fundamental problem of maintaining sorted data while enabling fast insertion, deletion, and search operations. By imposing a simple ordering constraint - left child < parent < right child - BSTs transform the linear search problem into a logarithmic one, dramatically improving performance for large datasets.</p>

    <p class="academic-text">The genius of BSTs lies in how they maintain order through structure rather than explicit sorting. Every insertion and search operation uses the ordering property to eliminate half of the remaining possibilities at each step, creating the same efficiency as binary search but in a dynamic structure that can grow and shrink. This makes BSTs perfect for applications like databases, symbol tables, and any system that needs to maintain sorted collections with frequent updates.</p>

    <p class="academic-text">The ordering property also enables powerful operations like finding minimum/maximum elements, predecessor/successor queries, and range searches - all with excellent performance characteristics. When balanced, BSTs provide O(log n) performance for all major operations, making them competitive with the best sorting and searching algorithms.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Search Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[50] --> B[30]
            A --> C[70]
            B --> D[20]
            B --> E[40]
            C --> F[60]
            C --> G[80]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Left < Parent < Right rule makes searching O(log n)</p>
    </div>

    <pre class="code-block">// Simple Binary Search Tree
#include &lt;iostream&gt;
using namespace std;

// Simple binary node
struct BinaryNode {
    int data;
    BinaryNode* left;
    BinaryNode* right;
    
    BinaryNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

// BST helper functions
class BST {
public:
    // Build a sample BST
    static BinaryNode* buildSampleBST() {
        BinaryNode* root = new BinaryNode(50);
        root->left = new BinaryNode(30);
        root->right = new BinaryNode(70);
        root->left->left = new BinaryNode(20);
        root->left->right = new BinaryNode(40);
        root->right->left = new BinaryNode(60);
        root->right->right = new BinaryNode(80);
        return root;
    }
    
    // Simple search function
    static bool search(BinaryNode* root, int target) {
        if (root == nullptr) return false;
        if (root->data == target) return true;
        
        if (target < root->data) {
            return search(root->left, target);
        } else {
            return search(root->right, target);
        }
    }
    
    // Insert a new value
    static BinaryNode* insert(BinaryNode* root, int value) {
        if (root == nullptr) {
            return new BinaryNode(value);
        }
        
        if (value < root->data) {
            root->left = insert(root->left, value);
        } else if (value > root->data) {
            root->right = insert(root->right, value);
        }
        return root;
    }
    
    // Print in sorted order
    static void printInOrder(BinaryNode* root) {
        if (root != nullptr) {
            printInOrder(root->left);
            cout << root->data << " ";
            printInOrder(root->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-3">3.3 Tree Traversals: Different Ways to Visit Nodes</h2>

    <p class="academic-text">Tree traversal represents one of the most fundamental operations in computer science - systematically visiting every node in a tree structure. The order in which we visit nodes profoundly affects what we can accomplish, from copying trees to evaluating expressions to processing hierarchical data. Understanding different traversal patterns is essential because each serves specific algorithmic purposes and reveals different aspects of the tree's structure.</p>

    <p class="academic-text">The four main traversal patterns - preorder, inorder, postorder, and level-order - each provide a different perspective on the tree's data. Preorder traversal processes parents before children, making it perfect for copying or serializing tree structures. Inorder traversal visits nodes in sorted order for BSTs, enabling efficient data retrieval. Postorder traversal processes children before parents, ideal for cleanup operations and calculating aggregate values. Level-order traversal processes nodes by depth, perfect for breadth-first analysis and finding shortest paths.</p>

    <p class="academic-text">These traversal patterns form the building blocks for countless tree algorithms. Compilers use traversals to parse and evaluate expressions, file systems use them to calculate directory sizes, and search algorithms use them to explore solution spaces. Mastering tree traversals is crucial because they provide the systematic approach needed to solve complex problems on hierarchical data.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Traversal Orders:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[2]
            A --> C[3]
            B --> D[4]
            B --> E[5]
            C --> F[6]
            C --> G[7]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">
            <strong>Preorder:</strong> 1, 2, 4, 5, 3, 6, 7 (Root first)<br>
            <strong>Inorder:</strong> 4, 2, 5, 1, 6, 3, 7 (Left, Root, Right)<br>
            <strong>Postorder:</strong> 4, 5, 2, 6, 7, 3, 1 (Root last)<br>
            <strong>Level-order:</strong> 1, 2, 3, 4, 5, 6, 7 (Level by level)
        </p>
    </div>

    <p class="academic-text"><strong>When to Use Each Traversal:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Preorder:</strong> Copy/clone tree, prefix expressions</li>
        <li class="academic-text"><strong>Inorder:</strong> Get sorted order from BST</li>
        <li class="academic-text"><strong>Postorder:</strong> Delete tree, calculate directory sizes</li>
        <li class="academic-text"><strong>Level-order:</strong> Print tree level by level, shortest path</li>
    </ul>

    <pre class="code-block">// Simple tree traversal functions
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;

class TreeTraversal {
public:
    // Preorder: Root -> Left -> Right
    static void preorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        cout << node->data << " ";  // Visit root first
        preorder(node->left);       // Then left subtree
        preorder(node->right);      // Then right subtree
    }
    
    // Inorder: Left -> Root -> Right (gives sorted order for BST)
    static void inorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        inorder(node->left);        // Visit left subtree first
        cout << node->data << " ";  // Then root
        inorder(node->right);       // Then right subtree
    }
    
    // Postorder: Left -> Right -> Root
    static void postorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        postorder(node->left);      // Visit left subtree first
        postorder(node->right);     // Then right subtree
        cout << node->data << " ";  // Then root last
    }
    
    // Level-order: Visit level by level using queue
    static void levelOrder(BinaryNode* root) {
        if (root == nullptr) return;
        
        queue<BinaryNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            BinaryNode* current = q.front();
            q.pop();
            
            cout << current->data << " ";
            
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-4">3.4 Applications in File Systems and Hierarchies</h2>

    <p class="academic-text">Trees aren't just abstract data structures - they're the invisible backbone of the digital systems you interact with every day. From the moment you boot your computer to browsing the web to organizing your photos, tree structures are working behind the scenes to organize, search, and manage information efficiently. Understanding these real-world applications helps you see why trees are so fundamental to computer science.</p>

    <p class="academic-text"><strong>File Systems: The Universal Tree Application</strong></p>
    <p class="academic-text">Every modern computer's file system is built on tree structure, creating a hierarchical organization that mirrors how humans naturally think about containment and categorization. Directories (folders) serve as internal nodes that can contain other directories or files, while files themselves are leaf nodes that contain actual data. This tree structure enables efficient navigation, prevents circular references, and provides a clear path to every file in the system.</p>

    <p class="academic-text">The tree structure of file systems isn't just convenient - it's essential for performance and organization. It enables efficient path resolution (finding files by their full path), supports recursive operations (like calculating directory sizes), and provides the foundation for file permissions, backup systems, and search indexing. Without tree structure, managing millions of files would be chaotic and inefficient.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>File System Tree Structure:</strong><br><br>
        <pre style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.4; margin: 0; background: none; border: none; padding: 0;">
/                    (root directory)
â”œâ”€â”€ home/           (user directories)
â”‚   â”œâ”€â”€ user1/
â”‚   â”‚   â”œâ”€â”€ Documents/
â”‚   â”‚   â”‚   â”œâ”€â”€ resume.pdf
â”‚   â”‚   â”‚   â””â”€â”€ notes.txt
â”‚   â”‚   â””â”€â”€ Pictures/
â”‚   â”‚       â””â”€â”€ vacation.jpg
â”‚   â””â”€â”€ user2/
â”œâ”€â”€ usr/            (system programs)
â””â”€â”€ var/            (variable data)
        </pre>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;"><strong>Each path from root to file is unique - no cycles!</strong></p>
    </div>

    <pre class="code-block">// Simple file system tree
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

// Simple file/folder node
struct FileNode {
    string name;
    bool isFile;
    vector<FileNode*> children;
    int size; // for files only
    
    FileNode(string n, bool file = false, int s = 0) 
        : name(n), isFile(file), size(s) {}
};

class FileSystem {
public:
    // Print tree structure with indentation showing hierarchy
    static void printTree(FileNode* node, int depth = 0) {
        if (!node) return;
        
        // Print indentation based on depth
        for (int i = 0; i < depth; i++) cout << "  ";
        cout << node->name;
        if (node->isFile) cout << " (" << node->size << "B)";
        cout << endl;
        
        // Recursively print all children
        for (FileNode* child : node->children) {
            printTree(child, depth + 1);
        }
    }
    
    // Calculate total size of directory (recursive)
    static int getSize(FileNode* node) {
        if (node->isFile) return node->size; // Base case: file size
        
        int total = 0;
        // Sum up sizes of all children
        for (FileNode* child : node->children) {
            total += getSize(child);
        }
        return total;
    }
};</pre>

    <p class="academic-text"><strong>Other Tree Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Organization Charts:</strong> Company hierarchy</li>
        <li class="academic-text"><strong>Decision Trees:</strong> AI and machine learning</li>
        <li class="academic-text"><strong>Parse Trees:</strong> Compilers and language processing</li>
        <li class="academic-text"><strong>Game Trees:</strong> Chess, tic-tac-toe game states</li>
        <li class="academic-text"><strong>Heap Trees:</strong> Priority queues (coming in Chapter 5!)</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">ðŸŒ³ Tree Properties Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Key Properties</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Connected + No cycles</li>
                    <li class="academic-text">n nodes = n-1 edges</li>
                    <li class="academic-text">Unique path between any two nodes</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Common Types</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Binary Tree (â‰¤2 children)</li>
                    <li class="academic-text">BST (ordered binary tree)</li>
                    <li class="academic-text">N-ary Tree (any # children)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">ðŸŽ‰ Chapter 3 Complete!</h3>
        <p class="academic-text">You now understand trees - the most important special graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">âœ… <strong>Tree properties</strong> - connected, acyclic, n-1 edges</li>
            <li class="academic-text">âœ… <strong>Binary trees & BSTs</strong> - organized for fast operations</li>
            <li class="academic-text">âœ… <strong>Tree traversals</strong> - different ways to visit nodes</li>
            <li class="academic-text">âœ… <strong>Real applications</strong> - file systems, hierarchies</li>
        </ul>
        
        <p class="academic-text">Trees are the foundation for many advanced data structures. Next: <strong>Tries</strong> - specialized trees for string processing!</p>
    </div>
</body>
</html>
