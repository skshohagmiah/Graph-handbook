<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 12: Advanced Graph Concepts</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 12</div>
    <h1 class="chapter-title">Advanced Graph Concepts</h1>
    
    <div class="definition-box">
        "Understanding critical connections, strongly connected components, and special paths reveals the deep structure and vulnerabilities of networks."
    </div>

    <p class="academic-text">This chapter explores advanced graph concepts that reveal the hidden structure of networks. We'll learn to identify critical points that can break a network, find tightly connected communities, and discover special paths that visit every edge or vertex exactly once.</p>
    
    <p class="academic-text"><strong>Real-world applications of advanced graph concepts:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Network reliability:</strong> Find critical connections whose failure disconnects the network</li>
        <li class="academic-text"><strong>Social networks:</strong> Identify influential users and tight-knit communities</li>
        <li class="academic-text"><strong>Circuit design:</strong> Find Eulerian paths to draw circuits without lifting the pen</li>
        <li class="academic-text"><strong>Route planning:</strong> Hamiltonian paths for visiting all locations exactly once</li>
        <li class="academic-text"><strong>Web crawling:</strong> Strongly connected components reveal website clusters</li>
    </ul>
    
    <p class="academic-text">These concepts are fundamental to understanding network structure, vulnerability, and optimization.</p>

    <h2 class="section-title" id="ch12-1">12.1 Articulation Points and Bridges</h2>
    
    <p class="academic-text"><strong>Articulation points</strong> (cut vertices) and <strong>bridges</strong> (cut edges) are critical elements whose removal disconnects the graph. They represent single points of failure in networks!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Critical Connections</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Articulation point:</strong> A vertex whose removal increases the number of connected components</li>
            <li class="academic-text"><strong>Bridge:</strong> An edge whose removal increases the number of connected components</li>
            <li class="academic-text"><strong>Biconnected component:</strong> A maximal subgraph with no articulation points</li>
            <li class="academic-text"><strong>Critical for:</strong> Network reliability, vulnerability analysis, redundancy planning</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Articulation Points Example (Network Vulnerability):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Server A] --- B[Router B]
            B --- C[Server C]
            B --- D[Server D]
            C --- E[Server E]
            D --- E
            E --- F[Server F]
            
            style B fill:#ff6b6b,stroke:#333,stroke-width:3px
            style E fill:#ff6b6b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Red nodes (B and E) are articulation points - their failure disconnects the network!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why it matters:</strong> If Router B fails, Server A is isolated. If Server E fails, Server F is isolated. These are single points of failure!
        </div>
    </div>

    <p class="academic-text"><strong>Finding Articulation Points: Tarjan's Algorithm</strong></p>
    <p class="academic-text">We use DFS with two key values for each vertex:</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Discovery time (disc):</strong> When we first visit the vertex during DFS</li>
        <li class="academic-text"><strong>Low value (low):</strong> Minimum discovery time reachable from this vertex's subtree</li>
        <li class="academic-text"><strong>Key insight:</strong> A vertex u is an articulation point if it has a child v where low[v] ≥ disc[u]</li>
    </ul>

    <pre class="code-block">// Articulation Points and Bridges using Tarjan's Algorithm
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class ArticulationPoints {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;bool&gt; visited;
    vector&lt;int&gt; disc, low, parent;
    vector&lt;bool&gt; isAP;
    vector&lt;pair&lt;int, int&gt;&gt; bridges;
    int timer;
    
    void dfs(int u) {
        visited[u] = true;
        disc[u] = low[u] = timer++;
        int children = 0;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                children++;
                parent[v] = u;
                dfs(v);
                
                low[u] = min(low[u], low[v]);
                
                // Check articulation point
                if (parent[u] == -1 && children &gt; 1) {
                    isAP[u] = true;
                }
                if (parent[u] != -1 && low[v] &gt;= disc[u]) {
                    isAP[u] = true;
                }
                
                // Check bridge
                if (low[v] &gt; disc[u]) {
                    bridges.push_back({u, v});
                }
            }
            else if (v != parent[u]) {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    
public:
    ArticulationPoints(int vertices) : V(vertices), timer(0) {
        adj.resize(V);
        visited.resize(V, false);
        disc.resize(V);
        low.resize(V);
        parent.resize(V, -1);
        isAP.resize(V, false);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    void findArticulationPoints() {
        for (int i = 0; i &lt; V; i++) {
            if (!visited[i]) dfs(i);
        }
    }
    
    vector&lt;int&gt; getArticulationPoints() {
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; V; i++) {
            if (isAP[i]) result.push_back(i);
        }
        return result;
    }
    
    vector&lt;pair&lt;int, int&gt;&gt; getBridges() {
        return bridges;
    }
};</pre>

    <h2 class="section-title" id="ch12-2">12.2 Tarjan's Algorithm for SCCs</h2>

    <p class="academic-text"><strong>Strongly Connected Components (SCCs)</strong> are maximal subgraphs where every vertex can reach every other vertex. Tarjan's algorithm finds all SCCs in a single DFS pass!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔄 Strongly Connected Components</h3>
        <p class="academic-text">In a directed graph, an SCC is a maximal set of vertices where:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Mutual reachability:</strong> For any two vertices u, v, there's a path u → v and v → u</li>
            <li class="academic-text"><strong>Maximal:</strong> Adding any other vertex breaks the property</li>
            <li class="academic-text"><strong>Applications:</strong> Web clustering, social communities, dependency analysis</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>SCC Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] --> B[B]
            B --> C[C]
            C --> A
            D[D] --> E[E]
            E --> F[F]
            F --> D
            B --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two SCCs: {A, B, C} and {D, E, F}</p>
    </div>

    <pre class="code-block">// Tarjan's Algorithm for SCCs
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;

class TarjanSCC {
private:
    int V, timer;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;bool&gt; onStack, visited;
    vector&lt;int&gt; disc, low;
    stack&lt;int&gt; st;
    vector&lt;vector&lt;int&gt;&gt; sccs;
    
    void dfs(int u) {
        disc[u] = low[u] = timer++;
        visited[u] = true;
        st.push(u);
        onStack[u] = true;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            }
            else if (onStack[v]) {
                low[u] = min(low[u], disc[v]);
            }
        }
        
        if (low[u] == disc[u]) {
            vector&lt;int&gt; scc;
            int v;
            do {
                v = st.top();
                st.pop();
                onStack[v] = false;
                scc.push_back(v);
            } while (v != u);
            sccs.push_back(scc);
        }
    }
    
public:
    TarjanSCC(int vertices) : V(vertices), timer(0) {
        adj.resize(V);
        onStack.resize(V, false);
        visited.resize(V, false);
        disc.resize(V);
        low.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    vector&lt;vector&lt;int&gt;&gt; findSCCs() {
        for (int i = 0; i &lt; V; i++) {
            if (!visited[i]) dfs(i);
        }
        return sccs;
    }
};</pre>

    <h2 class="section-title" id="ch12-3">12.3 Eulerian and Hamiltonian Paths</h2>

    <p class="academic-text">Two famous path problems with very different difficulty levels!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🛤️ Special Paths</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Eulerian path:</strong> Visits every <em>edge</em> exactly once</li>
            <li class="academic-text"><strong>Eulerian circuit:</strong> Eulerian path that starts and ends at same vertex</li>
            <li class="academic-text"><strong>Hamiltonian path:</strong> Visits every <em>vertex</em> exactly once</li>
            <li class="academic-text"><strong>Hamiltonian cycle:</strong> Hamiltonian path that returns to start</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Eulerian Paths: Easy to Check!</strong></p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Eulerian Path Conditions:</strong><br><br>
        <p style="margin: 10px 0; font-family: sans-serif; font-size: 12pt;"><strong>Undirected Graph:</strong></p>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Eulerian circuit:</strong> All vertices have even degree</li>
            <li style="margin-bottom: 8px;"><strong>Eulerian path:</strong> Exactly 0 or 2 vertices have odd degree</li>
        </ul>
    </div>

    <pre class="code-block">// Eulerian Path Detection
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class EulerianPath {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;int&gt; degree;
    
public:
    EulerianPath(int vertices) : V(vertices) {
        adj.resize(V);
        degree.resize(V, 0);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
        degree[u]++;
        degree[v]++;
    }
    
    int checkEulerian() {
        int oddCount = 0;
        for (int i = 0; i &lt; V; i++) {
            if (degree[i] % 2 != 0) oddCount++;
        }
        
        if (oddCount == 0) return 2; // Circuit
        if (oddCount == 2) return 1; // Path
        return 0; // Neither
    }
};</pre>

    <p class="academic-text"><strong>Hamiltonian Paths: NP-Complete!</strong></p>
    <p class="academic-text">Unlike Eulerian paths, determining if a Hamiltonian path exists is NP-complete - no efficient algorithm is known!</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Applications:</strong> Traveling salesman, DNA sequencing, circuit routing</li>
        <li class="academic-text"><strong>Approaches:</strong> Backtracking O(n!), DP O(2^n × n), heuristics</li>
    </ul>

    <h2 class="section-title" id="ch12-4">12.4 Network Reliability Analysis</h2>

    <p class="academic-text">Combining concepts to analyze real-world network reliability.</p>

    <p class="academic-text"><strong>Network Reliability Metrics:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertex connectivity:</strong> Minimum vertices to remove to disconnect</li>
        <li class="academic-text"><strong>Edge connectivity:</strong> Minimum edges to remove to disconnect</li>
        <li class="academic-text"><strong>Articulation points:</strong> Single points of failure</li>
        <li class="academic-text"><strong>Bridges:</strong> Critical connections</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">⚡ Algorithm Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Articulation Points</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Method:</strong> DFS with low values</li>
                    <li class="academic-text"><strong>Use:</strong> Find critical nodes</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Tarjan's SCC</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Method:</strong> Single DFS pass</li>
                    <li class="academic-text"><strong>Use:</strong> Find communities</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 12 Complete!</h3>
        <p class="academic-text">You now understand advanced graph concepts:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Articulation points & bridges</strong> - critical network elements</li>
            <li class="academic-text">✅ <strong>Tarjan's SCC algorithm</strong> - finding strongly connected components</li>
            <li class="academic-text">✅ <strong>Eulerian paths</strong> - visiting every edge once</li>
            <li class="academic-text">✅ <strong>Hamiltonian paths</strong> - visiting every vertex once</li>
            <li class="academic-text">✅ <strong>Network reliability</strong> - analyzing system vulnerabilities</li>
        </ul>
        
        <p class="academic-text">These advanced concepts reveal the deep structure of networks and help identify vulnerabilities, communities, and special properties. You've completed Part III - Advanced Topics!</p>
    </div>
</body>
</html>
