<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 10: Flow Networks and Optimization</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 10</div>
    <h1 class="chapter-title">Flow Networks and Optimization</h1>
    
    <div class="definition-box">
        "Flow networks model how resources move through systems - from water in pipes to data in networks to goods in supply chains."
    </div>

    <p class="academic-text">Flow networks are directed graphs where edges have capacities, and we want to push as much "flow" as possible from a source to a sink. This fundamental problem appears everywhere in computer science and real-world systems.</p>
    
    <p class="academic-text"><strong>Real-world flow problems you encounter daily:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Internet routing:</strong> Maximizing data throughput through network connections</li>
        <li class="academic-text"><strong>Transportation:</strong> Moving goods efficiently through road networks</li>
        <li class="academic-text"><strong>Supply chains:</strong> Distributing products from factories to stores</li>
        <li class="academic-text"><strong>Matching problems:</strong> Assigning jobs to workers, students to schools</li>
        <li class="academic-text"><strong>Image segmentation:</strong> Separating foreground from background in photos</li>
    </ul>
    
    <p class="academic-text">This chapter introduces the maximum flow problem, one of the most elegant and practical problems in graph theory, along with powerful algorithms to solve it.</p>

    <h2 class="section-title" id="ch10-1">10.1 Max Flow Problem and Min-Cut Theorem</h2>
    
    <p class="academic-text">The <strong>maximum flow problem</strong> asks: given a network with capacity constraints, what's the maximum amount of flow we can push from a source to a sink?</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ’§ Flow Network Definition</h3>
        <p class="academic-text">A <strong>flow network</strong> is a directed graph G = (V, E) with:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Capacity function c(u,v):</strong> Maximum flow allowed on edge (u,v)</li>
            <li class="academic-text"><strong>Source s:</strong> Where flow originates (one node)</li>
            <li class="academic-text"><strong>Sink t:</strong> Where flow terminates (one node)</li>
            <li class="academic-text"><strong>Flow f(u,v):</strong> Actual flow on edge (u,v), where 0 â‰¤ f(u,v) â‰¤ c(u,v)</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Flow Conservation Rule:</strong> For every node except source and sink, the total flow coming in must equal the total flow going out. Think of it like water - what flows in must flow out!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Simple Flow Network Example (Water Pipes):</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|10| A[Pump A]
            S -->|8| B[Pump B]
            A -->|6| C[Junction]
            A -->|4| D[Tank]
            B -->|5| C
            C -->|7| D
            D -->|15| T[Sink]
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers on edges represent capacity - maximum flow that can pass through</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A flow f is valid if: (1) Capacity constraint: 0 â‰¤ f(u,v) â‰¤ c(u,v) for all edges, (2) Flow conservation: Î£ f(u,v) = Î£ f(v,w) for all v â‰  s,t.
        </div>
    </div>

    <p class="academic-text"><strong>The Min-Cut Max-Flow Theorem</strong></p>
    <p class="academic-text">One of the most beautiful results in graph theory! A <strong>cut</strong> is a partition of vertices into two sets S and T, where source s âˆˆ S and sink t âˆˆ T. The capacity of a cut is the sum of capacities of edges going from S to T.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ”ª Min-Cut Max-Flow Theorem</h3>
        <p class="academic-text">The maximum flow from s to t equals the minimum capacity of any cut separating s from t.</p>
        <p class="academic-text" style="margin-top: 10px;"><strong>Why it matters:</strong> This theorem tells us that the bottleneck in any network is determined by its weakest cut. Finding max flow also finds the min cut!</p>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Cut Visualization:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Set S (Source Side)"
                S[Source]
                A[Node A]
            end
            
            subgraph "Set T (Sink Side)"
                B[Node B]
                T[Sink]
            end
            
            S -->|5| A
            S -->|3| B
            A -->|4| B
            A -->|2| T
            B -->|6| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cut capacity = edges crossing from S to T: 3 (Sâ†’B) + 2 (Aâ†’T) = 5. This is the bottleneck!</p>
    </div>

    <h2 class="section-title" id="ch10-2">10.2 Ford-Fulkerson Method</h2>

    <p class="academic-text">The <strong>Ford-Fulkerson method</strong> is a general approach to computing maximum flow. It repeatedly finds augmenting paths (paths from source to sink with available capacity) and pushes flow along them until no more augmenting paths exist.</p>
    
    <p class="academic-text"><strong>Key Concept: Residual Graph</strong></p>
    <p class="academic-text">The residual graph shows remaining capacity. For each edge with flow f and capacity c, the residual capacity is c - f. We also add backward edges with capacity f (allowing us to "undo" flow).</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Ford-Fulkerson Algorithm Steps:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Initialize:</strong> Start with zero flow on all edges</li>
            <li style="margin-bottom: 8px;"><strong>Find augmenting path:</strong> Search for any path from s to t in residual graph</li>
            <li style="margin-bottom: 8px;"><strong>Compute bottleneck:</strong> Find minimum residual capacity along the path</li>
            <li style="margin-bottom: 8px;"><strong>Augment flow:</strong> Add bottleneck capacity to flow along the path</li>
            <li style="margin-bottom: 8px;"><strong>Repeat:</strong> Continue until no augmenting path exists</li>
        </ol>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Time Complexity:</strong> O(E Ã— max_flow) where E is number of edges. Not polynomial in input size! This is why we need better implementations.
        </div>
    </div>

    <pre class="code-block">// Ford-Fulkerson Method Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
using namespace std;

class FordFulkerson {
private:
    int V; // Number of vertices
    vector&lt;vector&lt;int&gt;&gt; capacity;  // Capacity matrix
    vector&lt;vector&lt;int&gt;&gt; flow;      // Flow matrix
    
    // BFS to find if there's a path from source to sink
    bool bfs(int source, int sink, vector&lt;int&gt;&amp; parent) {
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            for (int v = 0; v &lt; V; v++) {
                // Check if there's residual capacity
                int residual = capacity[u][v] - flow[u][v];
                
                if (!visited[v] &amp;&amp; residual &gt; 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    FordFulkerson(int vertices) : V(vertices) {
        capacity.resize(V, vector&lt;int&gt;(V, 0));
        flow.resize(V, vector&lt;int&gt;(V, 0));
    }
    
    // Add edge with capacity
    void addEdge(int u, int v, int cap) {
        capacity[u][v] = cap;
    }
    
    // Compute maximum flow from source to sink
    int maxFlow(int source, int sink) {
        int totalFlow = 0;
        vector&lt;int&gt; parent(V);
        
        // While there exists an augmenting path
        while (bfs(source, sink, parent)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                int residual = capacity[u][v] - flow[u][v];
                pathFlow = min(pathFlow, residual);
            }
            
            // Update flow along the path
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                flow[u][v] += pathFlow;
                flow[v][u] -= pathFlow; // Backward edge
            }
            
            totalFlow += pathFlow;
        }
        
        return totalFlow;
    }
    
    // Get the min-cut (vertices reachable from source in residual graph)
    vector&lt;int&gt; getMinCut(int source) {
        vector&lt;int&gt; reachable;
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            reachable.push_back(u);
            
            for (int v = 0; v &lt; V; v++) {
                int residual = capacity[u][v] - flow[u][v];
                if (!visited[v] &amp;&amp; residual &gt; 0) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        
        return reachable;
    }
};</pre>

    <h2 class="section-title" id="ch10-3">10.3 Edmonds-Karp Algorithm</h2>

    <p class="academic-text">The <strong>Edmonds-Karp algorithm</strong> is a specific implementation of Ford-Fulkerson that uses BFS to find augmenting paths. This simple choice makes a huge difference - it guarantees polynomial time complexity!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">âš¡ Edmonds-Karp Key Insight</h3>
        <p class="academic-text">By always choosing the <strong>shortest augmenting path</strong> (in terms of number of edges) using BFS, we guarantee that the algorithm terminates in O(V Ã— EÂ²) time.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Time Complexity:</strong> O(V Ã— EÂ²) - polynomial!</li>
            <li class="academic-text"><strong>Space Complexity:</strong> O(VÂ²) for adjacency matrix or O(V + E) for adjacency list</li>
            <li class="academic-text"><strong>Why BFS matters:</strong> Shortest paths ensure we don't get stuck in bad augmenting paths</li>
        </ul>
    </div>

    <p class="academic-text"><strong>How Edmonds-Karp Improves Ford-Fulkerson:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Deterministic:</strong> Always finds shortest augmenting path, no arbitrary choices</li>
        <li class="academic-text"><strong>Bounded iterations:</strong> At most O(V Ã— E) augmenting paths</li>
        <li class="academic-text"><strong>Practical:</strong> Works well on real networks, not just theoretical worst cases</li>
    </ul>

    <pre class="code-block">// Edmonds-Karp Algorithm (Ford-Fulkerson with BFS)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;

class EdmondsKarp {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; capacity;
    
    // BFS to find shortest augmenting path
    bool bfs(int source, int sink, vector&lt;int&gt;&amp; parent, 
             vector&lt;vector&lt;int&gt;&gt;&amp; residual) {
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            // Try all neighbors
            for (int v = 0; v &lt; V; v++) {
                if (!visited[v] &amp;&amp; residual[u][v] &gt; 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    EdmondsKarp(int vertices) : V(vertices) {
        capacity.resize(V, vector&lt;int&gt;(V, 0));
    }
    
    void addEdge(int u, int v, int cap) {
        capacity[u][v] += cap; // Handle multiple edges
    }
    
    int maxFlow(int source, int sink) {
        // Create residual graph (initially same as capacity)
        vector&lt;vector&lt;int&gt;&gt; residual = capacity;
        vector&lt;int&gt; parent(V);
        int maxFlowValue = 0;
        
        // While there exists an augmenting path from source to sink
        while (bfs(source, sink, parent, residual)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            // Update residual capacities
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow; // Add reverse edge
            }
            
            maxFlowValue += pathFlow;
        }
        
        return maxFlowValue;
    }
    
    // Print flow decomposition
    void printFlow(int source, int sink) {
        vector&lt;vector&lt;int&gt;&gt; residual = capacity;
        vector&lt;int&gt; parent(V);
        
        cout &lt;&lt; "Flow paths:" &lt;&lt; endl;
        int pathNum = 1;
        
        while (bfs(source, sink, parent, residual)) {
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            cout &lt;&lt; "Path " &lt;&lt; pathNum++ &lt;&lt; " (flow=" &lt;&lt; pathFlow &lt;&lt; "): ";
            vector&lt;int&gt; path;
            for (int v = sink; v != source; v = parent[v]) {
                path.push_back(v);
            }
            path.push_back(source);
            
            for (int i = path.size() - 1; i &gt;= 0; i--) {
                cout &lt;&lt; path[i];
                if (i &gt; 0) cout &lt;&lt; " -> ";
            }
            cout &lt;&lt; endl;
            
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch10-4">10.4 Applications in Logistics and Supply Chain</h2>

    <p class="academic-text">Flow networks aren't just theoretical - they solve real problems every day! Let's explore practical applications that power modern logistics and systems.</p>

    <p class="academic-text"><strong>Application 1: Bipartite Matching</strong></p>
    <p class="academic-text">Matching problems can be modeled as max flow! Connect source to all left nodes, all right nodes to sink, and add edges between compatible pairs with capacity 1.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Job Assignment Problem:</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|1| W1[Worker 1]
            S -->|1| W2[Worker 2]
            S -->|1| W3[Worker 3]
            
            W1 -->|1| J1[Job A]
            W1 -->|1| J2[Job B]
            W2 -->|1| J2
            W2 -->|1| J3[Job C]
            W3 -->|1| J1
            W3 -->|1| J3
            
            J1 -->|1| T[Sink]
            J2 -->|1| T
            J3 -->|1| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style W1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W2 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W3 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style J1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J2 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J3 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Max flow = maximum number of workers that can be assigned to jobs</p>
    </div>

    <p class="academic-text"><strong>Application 2: Supply Chain Optimization</strong></p>
    <p class="academic-text">Model factories as sources, stores as sinks, and distribution centers as intermediate nodes. Edge capacities represent transportation limits.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Multi-source multi-sink:</strong> Add super-source connected to all factories, super-sink connected to all stores</li>
        <li class="academic-text"><strong>Minimize cost:</strong> Use min-cost max-flow algorithms (beyond this chapter)</li>
        <li class="academic-text"><strong>Real-time routing:</strong> Update capacities based on traffic, weather, breakdowns</li>
    </ul>

    <p class="academic-text"><strong>Application 3: Network Reliability</strong></p>
    <p class="academic-text">The min-cut tells us the network's vulnerability! Edges in the min-cut are critical - if they fail, the network is disconnected.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Real-World Applications:</strong><br><br>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Internet routing:</strong> Maximize data throughput between servers</li>
            <li style="margin-bottom: 8px;"><strong>Airline scheduling:</strong> Assign crews to flights efficiently</li>
            <li style="margin-bottom: 8px;"><strong>Image segmentation:</strong> Separate objects from background using graph cuts</li>
            <li style="margin-bottom: 8px;"><strong>Baseball elimination:</strong> Determine if a team can still win the championship</li>
            <li style="margin-bottom: 8px;"><strong>Project selection:</strong> Choose profitable projects with dependencies</li>
        </ul>
    </div>

    <pre class="code-block">// Bipartite Matching using Max Flow
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class BipartiteMatching {
private:
    EdmondsKarp flowNetwork;
    int leftSize, rightSize;
    int source, sink;
    
public:
    BipartiteMatching(int left, int right) 
        : leftSize(left), rightSize(right),
          flowNetwork(left + right + 2) {
        source = 0;
        sink = left + right + 1;
        
        // Connect source to all left nodes
        for (int i = 1; i &lt;= left; i++) {
            flowNetwork.addEdge(source, i, 1);
        }
        
        // Connect all right nodes to sink
        for (int i = 1; i &lt;= right; i++) {
            flowNetwork.addEdge(left + i, sink, 1);
        }
    }
    
    // Add edge from left node to right node
    void addCompatibility(int leftNode, int rightNode) {
        // leftNode: 1 to leftSize
        // rightNode: 1 to rightSize
        flowNetwork.addEdge(leftNode, leftSize + rightNode, 1);
    }
    
    // Find maximum matching
    int maxMatching() {
        return flowNetwork.maxFlow(source, sink);
    }
};

// Example: Job assignment problem
void solveJobAssignment() {
    // 3 workers, 3 jobs
    BipartiteMatching matcher(3, 3);
    
    // Worker 1 can do jobs 1 and 2
    matcher.addCompatibility(1, 1);
    matcher.addCompatibility(1, 2);
    
    // Worker 2 can do jobs 2 and 3
    matcher.addCompatibility(2, 2);
    matcher.addCompatibility(2, 3);
    
    // Worker 3 can do jobs 1 and 3
    matcher.addCompatibility(3, 1);
    matcher.addCompatibility(3, 3);
    
    int maxAssignments = matcher.maxMatching();
    cout &lt;&lt; "Maximum workers that can be assigned: " 
         &lt;&lt; maxAssignments &lt;&lt; endl;
}</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">âš¡ Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Ford-Fulkerson</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E Ã— max_flow)</li>
                    <li class="academic-text"><strong>Pro:</strong> Simple to understand</li>
                    <li class="academic-text"><strong>Con:</strong> Can be slow on large flows</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Edmonds-Karp</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V Ã— EÂ²)</li>
                    <li class="academic-text"><strong>Pro:</strong> Polynomial guarantee</li>
                    <li class="academic-text"><strong>Pro:</strong> Practical and reliable</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">ðŸŽ‰ Chapter 10 Complete!</h3>
        <p class="academic-text">You now understand flow networks and optimization:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">âœ… <strong>Max flow problem</strong> - pushing maximum flow through networks</li>
            <li class="academic-text">âœ… <strong>Min-cut theorem</strong> - the beautiful duality between flow and cuts</li>
            <li class="academic-text">âœ… <strong>Ford-Fulkerson method</strong> - the foundational approach</li>
            <li class="academic-text">âœ… <strong>Edmonds-Karp algorithm</strong> - efficient polynomial-time implementation</li>
            <li class="academic-text">âœ… <strong>Real applications</strong> - logistics, matching, network design</li>
        </ul>
        
        <p class="academic-text">Flow networks are fundamental to optimization and operations research. These algorithms power everything from internet routing to supply chain management. You've now completed Part III - Advanced Topics!</p>
    </div>
</body>
</html>
