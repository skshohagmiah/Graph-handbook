<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 10: Flow Networks and Optimization</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 10</div>
    <h1 class="chapter-title">Flow Networks and Optimization</h1>
    
    <div class="definition-box">
        "Flow networks model how resources move through systems - from water in pipes to data in networks to goods in supply chains."
    </div>

    <p class="academic-text">Flow networks represent one of the most powerful and versatile modeling frameworks in computer science, capturing the essence of resource movement, capacity constraints, and optimization in systems ranging from physical infrastructure to abstract computational problems. These networks model situations where you have limited capacity connections and want to maximize the flow of resources - whether that's water through pipes, data through internet cables, or goods through supply chains.</p>
    
    <p class="academic-text">The mathematical beauty of flow networks lies in their ability to transform complex real-world optimization problems into elegant graph algorithms. By modeling capacity constraints as edge weights and flow conservation as fundamental laws, flow networks enable precise analysis and optimization of systems that would otherwise be intractably complex. The algorithms we'll explore don't just solve abstract mathematical problems - they power the infrastructure and systems that modern society depends on.</p>

    <p class="academic-text">Flow networks also reveal deep connections between seemingly unrelated problems. The same algorithmic framework that optimizes internet traffic can solve job assignment problems, image processing challenges, and supply chain optimization. This universality makes flow networks one of the most important algorithmic paradigms in computer science, with applications spanning from theoretical computer science to practical engineering.</p>
    
    <p class="academic-text"><strong>Flow networks power the optimization systems that keep modern infrastructure running:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Internet infrastructure:</strong> Network routers use flow algorithms to maximize data throughput and minimize congestion across global internet connections, ensuring your video calls and downloads work smoothly</li>
        <li class="academic-text"><strong>Transportation systems:</strong> Logistics companies use flow networks to optimize cargo movement through road, rail, and shipping networks, minimizing costs while meeting delivery deadlines</li>
        <li class="academic-text"><strong>Supply chain management:</strong> Manufacturers use flow algorithms to optimize product distribution from factories through warehouses to retail stores, balancing inventory costs with customer demand</li>
        <li class="academic-text"><strong>Resource allocation:</strong> Flow networks solve matching problems like assigning medical residents to hospitals, students to schools, or workers to projects, ensuring optimal allocation under capacity constraints</li>
        <li class="academic-text"><strong>Computer vision:</strong> Image processing algorithms use flow networks for segmentation, object recognition, and medical imaging, separating regions of interest from background noise</li>
        <li class="academic-text"><strong>Financial systems:</strong> Banks and trading systems use flow algorithms to optimize capital allocation, risk management, and transaction processing across complex financial networks</li>
    </ul>
    
    <p class="academic-text">This chapter explores the maximum flow problem - one of the most elegant and practically important optimization problems in computer science. We'll discover how simple flow conservation laws lead to powerful algorithms that solve complex real-world challenges with mathematical precision and computational efficiency.</p>

    <h2 class="section-title" id="ch10-1">10.1 Max Flow Problem and Min-Cut Theorem</h2>
    
    <p class="academic-text">The <strong>maximum flow problem</strong> asks: given a network with capacity constraints, what's the maximum amount of flow we can push from a source to a sink?</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ’§ Flow Network Definition</h3>
        <p class="academic-text">A <strong>flow network</strong> is a directed graph G = (V, E) with:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Capacity function c(u,v):</strong> Maximum flow allowed on edge (u,v)</li>
            <li class="academic-text"><strong>Source s:</strong> Where flow originates (one node)</li>
            <li class="academic-text"><strong>Sink t:</strong> Where flow terminates (one node)</li>
            <li class="academic-text"><strong>Flow f(u,v):</strong> Actual flow on edge (u,v), where 0 â‰¤ f(u,v) â‰¤ c(u,v)</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Flow Conservation Rule:</strong> For every node except source and sink, the total flow coming in must equal the total flow going out. Think of it like water - what flows in must flow out!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Simple Flow Network Example (Water Pipes):</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|10| A[Pump A]
            S -->|8| B[Pump B]
            A -->|6| C[Junction]
            A -->|4| D[Tank]
            B -->|5| C
            C -->|7| D
            D -->|15| T[Sink]
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers on edges represent capacity - maximum flow that can pass through</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A flow f is valid if: (1) Capacity constraint: 0 â‰¤ f(u,v) â‰¤ c(u,v) for all edges, (2) Flow conservation: Î£ f(u,v) = Î£ f(v,w) for all v â‰  s,t.
        </div>
    </div>

    <p class="academic-text"><strong>The Min-Cut Max-Flow Theorem</strong></p>
    <p class="academic-text">One of the most beautiful results in graph theory! A <strong>cut</strong> is a partition of vertices into two sets S and T, where source s âˆˆ S and sink t âˆˆ T. The capacity of a cut is the sum of capacities of edges going from S to T.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ”ª Min-Cut Max-Flow Theorem</h3>
        <p class="academic-text">The maximum flow from s to t equals the minimum capacity of any cut separating s from t.</p>
        <p class="academic-text" style="margin-top: 10px;"><strong>Why it matters:</strong> This theorem tells us that the bottleneck in any network is determined by its weakest cut. Finding max flow also finds the min cut!</p>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Cut Visualization:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Set S (Source Side)"
                S[Source]
                A[Node A]
            end
            
            subgraph "Set T (Sink Side)"
                B[Node B]
                T[Sink]
            end
            
            S -->|5| A
            S -->|3| B
            A -->|4| B
            A -->|2| T
            B -->|6| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cut capacity = edges crossing from S to T: 3 (Sâ†’B) + 2 (Aâ†’T) = 5. This is the bottleneck!</p>
    </div>

    <h2 class="section-title" id="ch10-2">10.2 Ford-Fulkerson Method</h2>

    <p class="academic-text">The <strong>Ford-Fulkerson method</strong> is a general approach to computing maximum flow. It repeatedly finds augmenting paths (paths from source to sink with available capacity) and pushes flow along them until no more augmenting paths exist.</p>
    
    <p class="academic-text"><strong>Key Concept: Residual Graph</strong></p>
    <p class="academic-text">The residual graph shows remaining capacity. For each edge with flow f and capacity c, the residual capacity is c - f. We also add backward edges with capacity f (allowing us to "undo" flow).</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Ford-Fulkerson Algorithm Steps:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Initialize:</strong> Start with zero flow on all edges</li>
            <li style="margin-bottom: 8px;"><strong>Find augmenting path:</strong> Search for any path from s to t in residual graph</li>
            <li style="margin-bottom: 8px;"><strong>Compute bottleneck:</strong> Find minimum residual capacity along the path</li>
            <li style="margin-bottom: 8px;"><strong>Augment flow:</strong> Add bottleneck capacity to flow along the path</li>
            <li style="margin-bottom: 8px;"><strong>Repeat:</strong> Continue until no augmenting path exists</li>
        </ol>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Time Complexity:</strong> O(E Ã— max_flow) where E is number of edges. Not polynomial in input size! This is why we need better implementations.
        </div>
    </div>

    <pre class="code-block">// Ford-Fulkerson Method Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <cstring>
using namespace std;

class FordFulkerson {
private:
    int V; // Number of vertices
    vector<vector<int>> capacity;  // Capacity matrix
    vector<vector<int>> flow;      // Flow matrix
    
    // BFS to find if there's a path from source to sink
    bool bfs(int source, int sink, vector<int>& parent) {
        vector<bool> visited(V, false);
        queue<int> q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            for (int v = 0; v < V; v++) {
                // Check if there's residual capacity
                int residual = capacity[u][v] - flow[u][v];
                
                if (!visited[v] && residual > 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    FordFulkerson(int vertices) : V(vertices) {
        capacity.resize(V, vector<int>(V, 0));
        flow.resize(V, vector<int>(V, 0));
    }
    
    // Add edge with capacity
    void addEdge(int u, int v, int cap) {
        capacity[u][v] = cap;
    }
    
    // Compute maximum flow from source to sink
    int maxFlow(int source, int sink) {
        int totalFlow = 0;
        vector<int> parent(V);
        
        // While there exists an augmenting path
        while (bfs(source, sink, parent)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                int residual = capacity[u][v] - flow[u][v];
                pathFlow = min(pathFlow, residual);
            }
            
            // Update flow along the path
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                flow[u][v] += pathFlow;
                flow[v][u] -= pathFlow; // Backward edge
            }
            
            totalFlow += pathFlow;
        }
        
        return totalFlow;
    }
    
    // Get the min-cut (vertices reachable from source in residual graph)
    vector<int> getMinCut(int source) {
        vector<int> reachable;
        vector<bool> visited(V, false);
        queue<int> q;
        q.push(source);
        visited[source] = true;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            reachable.push_back(u);
            
            for (int v = 0; v < V; v++) {
                int residual = capacity[u][v] - flow[u][v];
                if (!visited[v] && residual > 0) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        
        return reachable;
    }
};</pre>

    <h2 class="section-title" id="ch10-3">10.3 Edmonds-Karp Algorithm</h2>

    <p class="academic-text">The <strong>Edmonds-Karp algorithm</strong> is a specific implementation of Ford-Fulkerson that uses BFS to find augmenting paths. This simple choice makes a huge difference - it guarantees polynomial time complexity!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">âš¡ Edmonds-Karp Key Insight</h3>
        <p class="academic-text">By always choosing the <strong>shortest augmenting path</strong> (in terms of number of edges) using BFS, we guarantee that the algorithm terminates in O(V Ã— EÂ²) time.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Time Complexity:</strong> O(V Ã— EÂ²) - polynomial!</li>
            <li class="academic-text"><strong>Space Complexity:</strong> O(VÂ²) for adjacency matrix or O(V + E) for adjacency list</li>
            <li class="academic-text"><strong>Why BFS matters:</strong> Shortest paths ensure we don't get stuck in bad augmenting paths</li>
        </ul>
    </div>

    <p class="academic-text"><strong>How Edmonds-Karp Improves Ford-Fulkerson:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Deterministic:</strong> Always finds shortest augmenting path, no arbitrary choices</li>
        <li class="academic-text"><strong>Bounded iterations:</strong> At most O(V Ã— E) augmenting paths</li>
        <li class="academic-text"><strong>Practical:</strong> Works well on real networks, not just theoretical worst cases</li>
    </ul>

    <pre class="code-block">// Edmonds-Karp Algorithm (Ford-Fulkerson with BFS)
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

class EdmondsKarp {
private:
    int V;
    vector<vector<int>> capacity;
    
    // BFS to find shortest augmenting path
    bool bfs(int source, int sink, vector<int>& parent, 
             vector<vector<int>>& residual) {
        vector<bool> visited(V, false);
        queue<int> q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            // Try all neighbors
            for (int v = 0; v < V; v++) {
                if (!visited[v] && residual[u][v] > 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    EdmondsKarp(int vertices) : V(vertices) {
        capacity.resize(V, vector<int>(V, 0));
    }
    
    void addEdge(int u, int v, int cap) {
        capacity[u][v] += cap; // Handle multiple edges
    }
    
    int maxFlow(int source, int sink) {
        // Create residual graph (initially same as capacity)
        vector<vector<int>> residual = capacity;
        vector<int> parent(V);
        int maxFlowValue = 0;
        
        // While there exists an augmenting path from source to sink
        while (bfs(source, sink, parent, residual)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            // Update residual capacities
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow; // Add reverse edge
            }
            
            maxFlowValue += pathFlow;
        }
        
        return maxFlowValue;
    }
    
    // Print flow decomposition
    void printFlow(int source, int sink) {
        vector<vector<int>> residual = capacity;
        vector<int> parent(V);
        
        cout << "Flow paths:" << endl;
        int pathNum = 1;
        
        while (bfs(source, sink, parent, residual)) {
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            cout << "Path " << pathNum++ << " (flow=" << pathFlow << "): ";
            vector<int> path;
            for (int v = sink; v != source; v = parent[v]) {
                path.push_back(v);
            }
            path.push_back(source);
            
            for (int i = path.size() - 1; i >= 0; i--) {
                cout << path[i];
                if (i > 0) cout << " -> ";
            }
            cout << endl;
            
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch10-4">10.4 Applications in Logistics and Supply Chain</h2>

    <p class="academic-text">Flow networks aren't just theoretical - they solve real problems every day! Let's explore practical applications that power modern logistics and systems.</p>

    <p class="academic-text"><strong>Application 1: Bipartite Matching</strong></p>
    <p class="academic-text">Matching problems can be modeled as max flow! Connect source to all left nodes, all right nodes to sink, and add edges between compatible pairs with capacity 1.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Job Assignment Problem:</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|1| W1[Worker 1]
            S -->|1| W2[Worker 2]
            S -->|1| W3[Worker 3]
            
            W1 -->|1| J1[Job A]
            W1 -->|1| J2[Job B]
            W2 -->|1| J2
            W2 -->|1| J3[Job C]
            W3 -->|1| J1
            W3 -->|1| J3
            
            J1 -->|1| T[Sink]
            J2 -->|1| T
            J3 -->|1| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style W1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W2 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W3 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style J1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J2 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J3 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Max flow = maximum number of workers that can be assigned to jobs</p>
    </div>

    <p class="academic-text"><strong>Application 2: Supply Chain Optimization</strong></p>
    <p class="academic-text">Model factories as sources, stores as sinks, and distribution centers as intermediate nodes. Edge capacities represent transportation limits.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Multi-source multi-sink:</strong> Add super-source connected to all factories, super-sink connected to all stores</li>
        <li class="academic-text"><strong>Minimize cost:</strong> Use min-cost max-flow algorithms (beyond this chapter)</li>
        <li class="academic-text"><strong>Real-time routing:</strong> Update capacities based on traffic, weather, breakdowns</li>
    </ul>

    <p class="academic-text"><strong>Application 3: Network Reliability</strong></p>
    <p class="academic-text">The min-cut tells us the network's vulnerability! Edges in the min-cut are critical - if they fail, the network is disconnected.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Real-World Applications:</strong><br><br>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Internet routing:</strong> Maximize data throughput between servers</li>
            <li style="margin-bottom: 8px;"><strong>Airline scheduling:</strong> Assign crews to flights efficiently</li>
            <li style="margin-bottom: 8px;"><strong>Image segmentation:</strong> Separate objects from background using graph cuts</li>
            <li style="margin-bottom: 8px;"><strong>Baseball elimination:</strong> Determine if a team can still win the championship</li>
            <li style="margin-bottom: 8px;"><strong>Project selection:</strong> Choose profitable projects with dependencies</li>
        </ul>
    </div>

    <pre class="code-block">// Bipartite Matching using Max Flow
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class BipartiteMatching {
private:
    EdmondsKarp flowNetwork;
    int leftSize, rightSize;
    int source, sink;
    
public:
    BipartiteMatching(int left, int right) 
        : leftSize(left), rightSize(right),
          flowNetwork(left + right + 2) {
        source = 0;
        sink = left + right + 1;
        
        // Connect source to all left nodes
        for (int i = 1; i <= left; i++) {
            flowNetwork.addEdge(source, i, 1);
        }
        
        // Connect all right nodes to sink
        for (int i = 1; i <= right; i++) {
            flowNetwork.addEdge(left + i, sink, 1);
        }
    }
    
    // Add edge from left node to right node
    void addCompatibility(int leftNode, int rightNode) {
        // leftNode: 1 to leftSize
        // rightNode: 1 to rightSize
        flowNetwork.addEdge(leftNode, leftSize + rightNode, 1);
    }
    
    // Find maximum matching
    int maxMatching() {
        return flowNetwork.maxFlow(source, sink);
    }
};

// Example: Job assignment problem
void solveJobAssignment() {
    // 3 workers, 3 jobs
    BipartiteMatching matcher(3, 3);
    
    // Worker 1 can do jobs 1 and 2
    matcher.addCompatibility(1, 1);
    matcher.addCompatibility(1, 2);
    
    // Worker 2 can do jobs 2 and 3
    matcher.addCompatibility(2, 2);
    matcher.addCompatibility(2, 3);
    
    // Worker 3 can do jobs 1 and 3
    matcher.addCompatibility(3, 1);
    matcher.addCompatibility(3, 3);
    
    int maxAssignments = matcher.maxMatching();
    cout << "Maximum workers that can be assigned: " 
         << maxAssignments << endl;
}</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">âš¡ Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Ford-Fulkerson</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E Ã— max_flow)</li>
                    <li class="academic-text"><strong>Pro:</strong> Simple to understand</li>
                    <li class="academic-text"><strong>Con:</strong> Can be slow on large flows</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Edmonds-Karp</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V Ã— EÂ²)</li>
                    <li class="academic-text"><strong>Pro:</strong> Polynomial guarantee</li>
                    <li class="academic-text"><strong>Pro:</strong> Practical and reliable</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">ðŸŽ‰ Chapter 10 Complete!</h3>
        <p class="academic-text">You now understand flow networks and optimization:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">âœ… <strong>Max flow problem</strong> - pushing maximum flow through networks</li>
            <li class="academic-text">âœ… <strong>Min-cut theorem</strong> - the beautiful duality between flow and cuts</li>
            <li class="academic-text">âœ… <strong>Ford-Fulkerson method</strong> - the foundational approach</li>
            <li class="academic-text">âœ… <strong>Edmonds-Karp algorithm</strong> - efficient polynomial-time implementation</li>
            <li class="academic-text">âœ… <strong>Real applications</strong> - logistics, matching, network design</li>
        </ul>
        
        <p class="academic-text">Flow networks are fundamental to optimization and operations research. These algorithms power everything from internet routing to supply chain management. You've now completed Part III - Advanced Topics!</p>
    </div>
</body>
</html>
