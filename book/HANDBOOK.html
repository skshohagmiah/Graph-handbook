<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms Handbook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cache buster: 1761563524018 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f8ff',
                primaryTextColor: '#000',
                primaryBorderColor: '#333',
                lineColor: '#333',
                secondaryColor: '#e8f5e8',
                tertiaryColor: '#fff5f5'
            }
        });
    </script>
    <style>
        /* Academic book styling like CPH */
        body { 
            font-family: 'Times New Roman', serif; 
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Times New Roman', serif;
            font-weight: normal;
        }
        
        .academic-content {
            max-width: 750px;
            margin: 0 auto;
            padding: 60px 40px;
        }
        
        .chapter-number {
            font-size: 16px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            font-weight: bold;
        }
        
        .chapter-title {
            font-size: 32px;
            font-weight: bold;
            color: #000;
            margin-bottom: 40px;
            line-height: 1.2;
        }
        
        .section-title {
            font-size: 22px;
            font-weight: bold;
            color: #1a202c;
            margin: 45px 0 20px 0;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 10px;
        }
        
        .academic-text {
            font-size: 12pt;
            line-height: 1.7;
            color: #2d3748;
            text-align: justify;
            margin-bottom: 14px;
        }
        
        .code-block {
            background-color: #2d2d2d; /* deeper gray for print clarity */
            color: #f8f8f2; /* softer white */
            border: 1.5px solid #444;
            border-left: 4px solid #3b82f6; /* subtle blue accent */
            border-radius: 6px;
            padding: 14px 18px;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 10pt;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre;
            line-height: 1.5;
            box-shadow: none; /* remove for PDF */
            }

        
        .definition-box {
            border-left: 4px solid #2196f3;
            background-color: #f8f9fa;
            padding: 16px;
            margin: 20px 0;
            font-style: italic;
            border-radius: 4px;
        }
        
        /* Mermaid diagram styling */
        .mermaid {
            text-align: center;
            margin: 20px 0;
        }
        
        .mermaid svg {
            max-width: 100%;
            height: auto;
        }
        
        .cover-title {
            font-size: 48px;
            font-weight: normal;
            color: black;
            margin-bottom: 40px;
            line-height: 1.3;
            text-align: center;
        }
        
        .cover-divider {
            width: 128px;
            height: 1px;
            background: black;
            margin: 0 auto 40px auto;
        }
        
        .cover-subtitle {
            font-size: 18px;
            color: black;
            font-weight: 300;
            max-width: 400px;
            line-height: 1.5;
            margin: 0 auto 100px auto;
            text-align: center;
        }
        
        .cover-author {
            font-size: 18px;
            color: black;
            font-weight: normal;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .cover-year {
            font-size: 16px;
            color: black;
            font-weight: 300;
            text-align: center;
        }
        
        /* Cover page container styling */
        .cover-page {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 48px;
            font-family: 'Times New Roman', serif;
        }
        
        .cover-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }
        
        .cover-main {
            flex: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .cover-footer {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 60px;
        }
        
        /* Summary section styling to match diagram backgrounds */
        .summary-section {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .performance-summary {
            background-color: #f8f9fa;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .completion-summary {
            background-color: #f8f9fa;
            border-left: 5px solid #2196f3;
            padding: 20px;
            margin: 30px 0;
        }
        
        @media print {
            .no-print { display: none !important; }
            .page-break { page-break-before: always; }
            
            /* Ensure code blocks print with proper colors and no overflow */
            .code-block {
                background: #2d3748 !important;
                color: #e2e8f0 !important;
                border: 2px solid #4a5568 !important;
                border-left: 4px solid #4299e1 !important;
                page-break-inside: avoid;
                overflow: visible !important;
                white-space: pre-wrap !important;
                word-wrap: break-word !important;
                font-size: 10pt !important;
                line-height: 1.4 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure summary sections print with colors */
            .performance-summary {
                background-color: #f8f9fa !important;
                border: 2px solid #4caf50 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .completion-summary {
                background-color: #f8f9fa !important;
                border-left: 5px solid #2196f3 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .summary-section {
                background-color: #f8f9fa !important;
                border: 1px solid #dee2e6 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Prevent diagrams from being split across pages */
            .mermaid {
                page-break-inside: avoid;
                page-break-before: auto;
                page-break-after: auto;
            }
            
            /* Prevent diagram containers from splitting */
            div[style*="background-color: #f8f9fa"] {
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure definition boxes print properly */
            .definition-box {
                background-color: #f8f9fa !important;
                border-left: 4px solid #2196f3 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Better page breaks for sections */
            .section-title {
                page-break-after: avoid;
            }
            
            .chapter-title {
                page-break-after: avoid;
            }
            
            /* Prevent orphaned content */
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }
            
            /* Ensure tables don't break awkwardly */
            table {
                page-break-inside: avoid;
            }
            
            /* Better spacing for print */
            .academic-content {
                line-height: 1.6 !important;
            }
        }
    </style>
</head>
<body class="font-sans text-gray-800 bg-white">

    <div class="cover-page " id="cover">
        
    <div class="cover-content">
        <div class="cover-main">
            <h1 class="cover-title">
                Graph Algorithms<br>
                Handbook
            </h1>
            <div class="cover-divider"></div>
            <p class="cover-subtitle">
                A Comprehensive Guide to Graph Theory,<br>
                Algorithms, and Network Analysis
            </p>
        </div>
        
        <div class="cover-footer">
            <div class="cover-author">Shohag Miah</div>
            <div class="cover-year">2025</div>
        </div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="preface">
        
    <h1 class="chapter-title">Preface</h1>
    
    <div class="definition-box">
        "Life is a graph. Learn to navigate it."
    </div>
    
    <p class="academic-text">Welcome to the <strong>Graph Algorithms Handbook</strong> ‚Äì your comprehensive guide to understanding one of the most fundamental and powerful concepts in computer science and life itself.</p>
    
    <h2 class="section-title">Why This Book?</h2>
    
    <p class="academic-text">Every day, you navigate complex networks without realizing it. Your social connections, career decisions, daily routines, and even your thoughts form intricate graph structures. This handbook bridges the gap between abstract mathematical concepts and practical, real-world thinking.</p>
    
    <p class="academic-text">Unlike traditional algorithm books that focus purely on theory, this handbook emphasizes:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Practical Understanding</strong> ‚Äì See graphs everywhere around you</li>
        <li class="academic-text"><strong>Real-World Applications</strong> ‚Äì From social networks to GPS navigation</li>
        <li class="academic-text"><strong>C++ Implementation</strong> ‚Äì Modern, efficient code examples</li>
        <li class="academic-text"><strong>Life Insights</strong> ‚Äì Apply graph thinking to personal decisions</li>
        <li class="academic-text"><strong>Progressive Learning</strong> ‚Äì From basics to advanced concepts</li>
    </ul>
    
    <h2 class="section-title">Who Should Read This?</h2>
    
    <p class="academic-text">This handbook is designed for:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Students</strong> learning data structures and algorithms</li>
        <li class="academic-text"><strong>Programmers</strong> preparing for technical interviews</li>
        <li class="academic-text"><strong>Software Engineers</strong> working with complex systems</li>
        <li class="academic-text"><strong>Anyone curious</strong> about how connected systems work</li>
    </ul>
    
    <h2 class="section-title">How to Use This Book</h2>
    
    <p class="academic-text">The handbook is organized into four progressive parts:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Part I: Foundations</strong> ‚Äì Basic concepts and representations</li>
        <li class="academic-text"><strong>Part II: Core Algorithms</strong> ‚Äì Essential algorithms every programmer should know</li>
        <li class="academic-text"><strong>Part III: Advanced Topics</strong> ‚Äì Complex algorithms and specialized problems</li>
        <li class="academic-text"><strong>Part IV: Applied Thinking</strong> ‚Äì Real-world applications and life insights</li>
    </ul>
    
    <p class="academic-text">Each chapter includes practical C++ examples, exercises, and insights that connect the concepts to everyday life. Don't just read ‚Äì practice, experiment, and think about how these concepts apply to your own challenges.</p>
    
    <h2 class="section-title">A Personal Note</h2>
    
    <p class="academic-text">Graphs changed how I see the world. Once you understand that everything is connected ‚Äì your relationships, goals, systems, and decisions ‚Äì you gain a powerful lens for problem-solving and optimization.</p>
    
    <p class="academic-text">This handbook is my attempt to share that perspective with you. I hope it not only helps you master algorithms but also transforms how you think about the interconnected world around us.</p>
    
    <div style="text-align: right; margin-top: 40px;">
        <div class="academic-text" style="margin-bottom: 4px;"><strong>Shohag Miah</strong></div>
        <div class="academic-text">2025</div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="toc">
        
    <h1 class="chapter-title">Contents</h1>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART I ‚Äî THE FOUNDATIONS OF GRAPH THINKING</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch1" style="color: #000; text-decoration: none;">1 What Are Graphs, Really?</a></strong> <span style="float: right;">1</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch1-1" style="color: #666; text-decoration: none;">1.1 Definition: Nodes, Edges, and Degrees</a></p>
                <p><a href="#ch1-2" style="color: #666; text-decoration: none;">1.2 Graph Types: Directed, Undirected, Weighted, Unweighted</a></p>
                <p><a href="#ch1-3" style="color: #666; text-decoration: none;">1.3 Cyclic vs Acyclic Structures</a></p>
                <p><a href="#ch1-4" style="color: #666; text-decoration: none;">1.4 Graph Representations: Adjacency List, Matrix, Edge List</a></p>
                <p><a href="#ch1-5" style="color: #666; text-decoration: none;">1.5 Real-World Examples</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>2 Graph Properties & Special Types</strong> <span style="float: right;">7</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>2.1 Connected vs Disconnected Graphs</p>
                <p>2.2 Strongly Connected Components (SCCs)</p>
                <p>2.3 Directed Acyclic Graphs (DAGs)</p>
                <p>2.4 Bipartite Graphs and Graph Density</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch3" style="color: #000; text-decoration: none;">3 Trees ‚Äî The Simplest Graphs</a></strong> <span style="float: right;">13</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch3-1" style="color: #666; text-decoration: none;">3.1 Tree Properties and Terminology</a></p>
                <p><a href="#ch3-2" style="color: #666; text-decoration: none;">3.2 Binary Trees, N-ary Trees, Binary Search Trees</a></p>
                <p><a href="#ch3-3" style="color: #666; text-decoration: none;">3.3 Tree Traversals: Preorder, Inorder, Postorder, Level-order</a></p>
                <p><a href="#ch3-4" style="color: #666; text-decoration: none;">3.4 Applications in File Systems and Hierarchies</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch4" style="color: #000; text-decoration: none;">4 Tries and Prefix Structures</a></strong> <span style="float: right;">19</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch4-1" style="color: #666; text-decoration: none;">4.1 Trie Data Structure and Operations</a></p>
                <p><a href="#ch4-2" style="color: #666; text-decoration: none;">4.2 String Searching and Autocomplete Systems</a></p>
                <p><a href="#ch4-3" style="color: #666; text-decoration: none;">4.3 Applications: Spell Checkers, Dictionaries, IP Routing</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch5" style="color: #000; text-decoration: none;">5 Heaps and Priority Structures</a></strong> <span style="float: right;">25</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch5-1" style="color: #666; text-decoration: none;">5.1 Heap Properties: Min-Heap and Max-Heap</a></p>
                <p><a href="#ch5-2" style="color: #666; text-decoration: none;">5.2 Heap Operations: Insert, Extract, Heapify</a></p>
                <p><a href="#ch5-3" style="color: #666; text-decoration: none;">5.3 Priority Queues and Applications</a></p>
                <p><a href="#ch5-4" style="color: #666; text-decoration: none;">5.4 Heap Sort and Graph Algorithm Preparation</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART II ‚Äî CORE ALGORITHMS</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch6" style="color: #000; text-decoration: none;">6 Traversal Algorithms</a></strong> <span style="float: right;">31</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch6-1" style="color: #666; text-decoration: none;">6.1 Breadth-First Search (BFS)</a></p>
                <p><a href="#ch6-2" style="color: #666; text-decoration: none;">6.2 Depth-First Search (DFS)</a></p>
                <p><a href="#ch6-3" style="color: #666; text-decoration: none;">6.3 Cycle Detection Using DFS</a></p>
                <p><a href="#ch6-4" style="color: #666; text-decoration: none;">6.4 Applications in Social Networks and Web Crawling</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch7" style="color: #000; text-decoration: none;">7 Shortest Path Algorithms</a></strong> <span style="float: right;">39</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch7-1" style="color: #666; text-decoration: none;">7.1 Dijkstra's Algorithm</a></p>
                <p><a href="#ch7-2" style="color: #666; text-decoration: none;">7.2 Bellman-Ford Algorithm</a></p>
                <p><a href="#ch7-3" style="color: #666; text-decoration: none;">7.3 A* Algorithm with Heuristics</a></p>
                <p><a href="#ch7-4" style="color: #666; text-decoration: none;">7.4 Floyd-Warshall All-Pairs Shortest Path</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch8" style="color: #000; text-decoration: none;">8 Minimum Spanning Trees</a></strong> <span style="float: right;">47</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch8-1" style="color: #666; text-decoration: none;">8.1 Kruskal's Algorithm</a></p>
                <p><a href="#ch8-2" style="color: #666; text-decoration: none;">8.2 Prim's Algorithm</a></p>
                <p><a href="#ch8-3" style="color: #666; text-decoration: none;">8.3 Union-Find Data Structure</a></p>
                <p><a href="#ch8-4" style="color: #666; text-decoration: none;">8.4 Applications in Network Design</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch9" style="color: #000; text-decoration: none;">9 Topological Sorting & Dynamic Programming on DAGs</a></strong> <span style="float: right;">55</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch9-1" style="color: #666; text-decoration: none;">9.1 Topological Ordering and Kahn's Algorithm</a></p>
                <p><a href="#ch9-2" style="color: #666; text-decoration: none;">9.2 DFS-Based Topological Sort</a></p>
                <p><a href="#ch9-3" style="color: #666; text-decoration: none;">9.3 Dynamic Programming on DAGs</a></p>
                <p><a href="#ch9-4" style="color: #666; text-decoration: none;">9.4 Longest and Shortest Paths in DAGs</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART III ‚Äî ADVANCED TOPICS</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>10 Flow Networks and Optimization</strong> <span style="float: right;">63</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>10.1 Max Flow Problem and Min-Cut Theorem</p>
                <p>10.2 Ford-Fulkerson Method</p>
                <p>10.3 Edmonds-Karp Algorithm</p>
                <p>10.4 Applications in Logistics and Supply Chain</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>11 Graph Coloring & Matching</strong> <span style="float: right;">70</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>11.1 Greedy Coloring Algorithms</p>
                <p>11.2 Bipartite Matching and Maximum Matching</p>
                <p>11.3 Applications in Scheduling and Resource Allocation</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>12 Advanced Graph Concepts</strong> <span style="float: right;">77</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>12.1 Articulation Points and Bridges</p>
                <p>12.2 Tarjan's Algorithm for SCCs</p>
                <p>12.3 Eulerian and Hamiltonian Paths</p>
                <p>12.4 Network Reliability Analysis</p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART IV ‚Äî APPLIED GRAPH THINKING</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>13 Graphs in Computer Science</strong> <span style="float: right;">83</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>13.1 Compilers and Abstract Syntax Trees</p>
                <p>13.2 Operating Systems: Scheduling and Deadlock Detection</p>
                <p>13.3 Databases and Graph Databases</p>
                <p>13.4 AI Search and Machine Learning Computation Graphs</p>
                <p>13.5 Web: PageRank and Social Media Algorithms</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>14 Pattern Recognition in Graphs</strong> <span style="float: right;">89</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>14.1 Cliques and Complete Subgraphs</p>
                <p>14.2 Community Detection Algorithms</p>
                <p>14.3 Graph Clustering Techniques</p>
                <p>14.4 Applications in Social Network Analysis</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>15 Graphs in Real Life & Human Decisions</strong> <span style="float: right;">95</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>15.1 Case Study: Career Pathfinding as Dijkstra's Algorithm</p>
                <p>15.2 Case Study: Social Network Pruning as MST</p>
                <p>15.3 Case Study: Goal Dependencies as Topological Sorting</p>
                <p>15.4 Case Study: Time Management as Graph Coloring</p>
                <p>15.5 Mind Mapping and Decision Making</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>16 Building the Graph Mindset</strong> <span style="float: right;">101</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>16.1 Systems Thinking: Seeing Interconnected Graphs</p>
                <p>16.2 Recognizing Patterns: Cycles, Dependencies, Bottlenecks</p>
                <p>16.3 Framework for Analyzing Any System as a Graph</p>
                <p>16.4 Final Takeaway: "Life is a Graph. Learn to Navigate It."</p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">APPENDICES</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>A Graph Terminology Reference</strong> <span style="float: right;">107</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>A.1 Complete Glossary of Graph Theory Terms</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>B Algorithm Complexity Table</strong> <span style="float: right;">109</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>B.1 Time and Space Complexity for All Algorithms</p>
                <p>B.2 Algorithm Decision Matrix</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>C Practice Problems & Solutions</strong> <span style="float: right;">111</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>C.1 30 Curated Problems (Easy to Hard)</p>
                <p>C.2 Step-by-Step Solutions</p>
                <p>C.3 Online Judge Platform Links</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>D Visual Cheatsheet</strong> <span style="float: right;">114</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>D.1 One-Page Summary of Graph Types</p>
                <p>D.2 Algorithm Decision Tree Flowchart</p>
                <p>D.3 Common Patterns and Solutions</p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong>E Further Reading & Resources</strong> <span style="float: right;">116</span></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p>E.1 Recommended Books and Papers</p>
                <p>E.2 Online Resources and Visualization Tools</p>
                <p>E.3 Research Topics for Deep Dives</p>
            </div>
        </div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch1">
        
    <div class="chapter-number">Chapter 1</div>
    <h1 class="chapter-title">What Are Graphs, Really?</h1>

    <div class="definition-box">
        "Think of graphs as a way to show how things are connected - like a map of relationships in the world around us."
    </div>

    <p class="academic-text">You use graphs every single day without realizing it! When you see friend suggestions on Facebook, get directions on Google Maps, or receive movie recommendations on Netflix, you're experiencing the power of graphs.</p>
    
    <p class="academic-text">In computer science, a <strong>graph</strong> isn't a bar chart or line plot - it's a way to show how things are connected. Think of it as a map of relationships in the world around us.</p>
    
    <p class="academic-text"><strong>Real-world examples you know:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Social media:</strong> Your friends and their connections</li>
        <li class="academic-text"><strong>GPS navigation:</strong> Roads connecting cities and intersections</li>
        <li class="academic-text"><strong>The internet:</strong> Web pages linked to each other</li>
        <li class="academic-text"><strong>Family trees:</strong> How people are related</li>
        <li class="academic-text"><strong>Course prerequisites:</strong> Which classes you need before taking others</li>
    </ul>
    
    <p class="academic-text">This chapter will show you what graphs really are, introduce the key terms you need to know, and demonstrate how they work with simple examples you can relate to.</p>

    <h2 class="section-title" id="ch1-1">1.1 Formal Definition and Mathematical Foundations</h2>
    
    <p class="academic-text">A <strong>graph</strong> is made up of just two simple things:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Vertices (or nodes):</strong> The "things" in your system - people, cities, web pages, etc.</li>
        <li class="academic-text"><strong>Edges:</strong> The connections between things - friendships, roads, links, etc.</li>
    </ul>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üìö Simple Definition</h3>
        <p class="academic-text">A <strong>graph G = (V, E)</strong> consists of:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>V:</strong> A set of vertices (the dots/nodes)</li>
            <li class="academic-text"><strong>E:</strong> A set of edges (the lines/connections)</li>
        </ul>
        <p class="academic-text">That's it! Everything else builds from this simple foundation.</p>
    </div>
    
    <p class="academic-text"><strong>Key terms to know:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Order:</strong> How many vertices you have (size of V)</li>
        <li class="academic-text"><strong>Size:</strong> How many edges you have (size of E)</li>
        <li class="academic-text"><strong>Adjacent:</strong> Two vertices connected by an edge are "neighbors"</li>
        <li class="academic-text"><strong>Incident:</strong> An edge is "incident" to the vertices it connects</li>
    </ul>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Simple Graph Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A simple undirected graph with 3 nodes and 3 edges</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Breaking it down:</strong><br>
            ‚Ä¢ Vertices: {Alice, Bob, Carol} - our 3 people<br>
            ‚Ä¢ Edges: {Alice-Bob, Alice-Carol, Bob-Carol} - the 3 friendships<br>
            ‚Ä¢ This is called a "complete graph" because everyone is friends with everyone else!
        </div>
    </div>
    
    <h2 class="section-title" id="ch1-2">1.2 How Popular is Each Node? (Degree)</h2>
    
    <p class="academic-text">The <strong>degree</strong> of a vertex is simply how many connections it has - like counting how many friends someone has!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üìä Degree Basics</h3>
        <p class="academic-text"><strong>Degree:</strong> The number of edges connected to a vertex.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>High degree:</strong> Very connected (popular person, busy intersection)</li>
            <li class="academic-text"><strong>Low degree:</strong> Few connections (introvert, dead-end street)</li>
            <li class="academic-text"><strong>Degree 0:</strong> Isolated vertex (no friends, disconnected)</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Fun fact:</strong> If you add up everyone's degree in a graph, you always get an even number! This is because each edge connects exactly 2 vertices, so it adds 1 to each of their degrees.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Degree Analysis Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            D[Dave] --- A[Alice]
            A --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#ffeb3b,stroke:#333,stroke-width:3px
            style B fill:#e3f2fd,stroke:#333,stroke-width:2px
            style C fill:#e3f2fd,stroke:#333,stroke-width:2px
            style D fill:#f3e5f5,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Node degrees: Alice=3, Bob=2, Carol=2, Dave=1</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> The degree of a vertex v, denoted deg(v), is the number of edges incident to v. In this graph: deg(Alice) = 3, deg(Bob) = deg(Carol) = 2, deg(Dave) = 1.
        </div>
    </div>
    
    <p class="academic-text">For graphs with arrows (we'll see these next), we count:</p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>In-degree</strong>: How many arrows point TO this node</li>
        <li class="academic-text"><strong>Out-degree</strong>: How many arrows point FROM this node</li>
    </ul>

    <pre class="code-block">// Simple way to represent our friendship graph in code
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class FriendshipGraph {
private:
    // Each person has a list of their friends
    unordered_map&lt;string, vector&lt;string&gt;&gt; friendsList;
    
public:
    // Add a friendship between two people
    void addFriendship(string person1, string person2) {
        friendsList[person1].push_back(person2);
        friendsList[person2].push_back(person1); // Friendship goes both ways!
    }
    
    // Count how many friends someone has
    int countFriends(string person) {
        return friendsList[person].size();
    }
    
    // Show everyone's friends
    void showAllFriendships() {
        for (const auto&amp; [person, friends] : friendsList) {
            cout &lt;&lt; person &lt;&lt; " is friends with: ";
            for (const string&amp; friendName : friends) {
                cout &lt;&lt; friendName &lt;&lt; " ";
            }
            cout &lt;&lt; "(" &lt;&lt; countFriends(person) &lt;&lt; " friends total)" &lt;&lt; endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-3">1.3 Graph Classifications and Structural Properties</h2>
    
    <p class="academic-text">Graph theory encompasses various types of graphs, each with distinct mathematical properties and real-world applications. Understanding these classifications is crucial for selecting appropriate algorithms and data structures.</p>
    
    <h3 style="color: #2e7d32; margin: 25px 0 15px 0;">üîÑ Directed vs. Undirected Graphs</h3>
    
    <p class="academic-text"><strong>Undirected Graphs: Two-Way Streets</strong></p>
    <p class="academic-text">In undirected graphs, connections work both ways - like friendships! If Alice is friends with Bob, then Bob is automatically friends with Alice.</p>
    
    <p class="academic-text"><strong>Key properties:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Symmetric:</strong> If A connects to B, then B connects to A</li>
        <li class="academic-text"><strong>Examples:</strong> Facebook friends, handshakes, two-way roads</li>
        <li class="academic-text"><strong>Maximum connections:</strong> In a graph with n vertices, you can have at most n(n-1)/2 edges</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Undirected Graph Example (Social Network):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] ---|friendship| B[Bob]
            A ---|friendship| C[Carol]
            B ---|friendship| C
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Symmetric relationships: if Alice is friends with Bob, then Bob is friends with Alice</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An undirected graph G = (V, E) where edges are unordered pairs. If (u,v) ‚àà E, then (v,u) ‚àà E. The edge set can be written as E = {{Alice,Bob}, {Alice,Carol}, {Bob,Carol}}.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Real examples:</strong> Facebook friendships, handshakes, two-way roads</li>
        <li class="academic-text"><strong>Key feature:</strong> If A connects to B, then B automatically connects to A</li>
    </ul>

    <p class="academic-text"><strong>Directed Graphs: One-Way Streets</strong></p>
    <p class="academic-text">In directed graphs, connections have direction - like following someone on Twitter! Alice might follow Bob, but Bob doesn't have to follow Alice back.</p>
    
    <p class="academic-text"><strong>Key concepts:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>In-degree:</strong> How many edges point TO a vertex (followers)</li>
        <li class="academic-text"><strong>Out-degree:</strong> How many edges point FROM a vertex (following)</li>
        <li class="academic-text"><strong>Examples:</strong> Twitter follows, web page links, one-way streets</li>
        <li class="academic-text"><strong>Asymmetric:</strong> A ‚Üí B doesn't mean B ‚Üí A</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Directed Graph Example (Social Media Follows):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] -->|follows| B[Bob]
            A -->|follows| C[Carol]
            C -->|follows| B
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Asymmetric relationships: Alice follows Bob, but Bob doesn't follow Alice back</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A directed graph (digraph) G = (V, E) where edges are ordered pairs. Here E = {(Alice,Bob), (Alice,Carol), (Carol,Bob)}. Note that (Alice,Bob) ‚â† (Bob,Alice).
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Real examples:</strong> Twitter follows, web page links, email sending</li>
        <li class="academic-text"><strong>Key feature:</strong> A can connect to B without B connecting back to A</li>
    </ul>

    <p class="academic-text"><strong>Weighted vs Unweighted: Some Connections Are Stronger</strong></p>
    
    <p class="academic-text"><strong>Unweighted Graphs:</strong> All connections are equal</p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Unweighted Graph (Simple Friendship):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">All edges have equal weight (typically weight = 1)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An unweighted graph where all edges have the same importance. Can be represented as G = (V, E) without a weight function.
        </div>
    </div>
    
    <p class="academic-text"><strong>Weighted Graphs:</strong> Connections have different strengths or costs</p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Weighted Graph (Distance Between Cities):</strong><br><br>
        <div class="mermaid">
        graph LR
            NYC[New York] ---|200 miles| BOS[Boston]
            NYC ---|450 miles| MIA[Miami]
            BOS ---|300 miles| MIA
            
            style NYC fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style BOS fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style MIA fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each edge has a weight representing distance in miles</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A weighted graph G = (V, E, w) where w: E ‚Üí ‚Ñù is a weight function. Here w((NYC,Boston)) = 200, w((NYC,Miami)) = 450, w((Boston,Miami)) = 300.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Weights can represent:</strong> Distance, time, cost, friendship strength, internet speed</li>
        <li class="academic-text"><strong>Real examples:</strong> GPS navigation (distance), social networks (closeness), internet routing (speed)</li>
    </ul>

    <pre class="code-block">// Simple way to represent a city distance map
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class CityMap {
private:
    // Each city has connections to other cities with distances
    unordered_map&lt;string, vector&lt;pair&lt;string, int&gt;&gt;&gt; cityConnections;
    
public:
    // Add a road between two cities with distance
    void addRoad(string city1, string city2, int distance) {
        cityConnections[city1].push_back({city2, distance});
        cityConnections[city2].push_back({city1, distance}); // Roads work both ways!
    }
    
    // Show all roads from each city
    void showAllRoads() {
        for (const auto&amp; [city, roads] : cityConnections) {
            cout &lt;&lt; "From " &lt;&lt; city &lt;&lt; ": ";
            for (const auto&amp; [destination, distance] : roads) {
                cout &lt;&lt; destination &lt;&lt; "(" &lt;&lt; distance &lt;&lt; " miles) ";
            }
            cout &lt;&lt; endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-3">1.3 Cycles: Going in Circles vs. Straight Paths</h2>

    <p class="academic-text">Some graphs let you walk in circles, others don't. This makes a big difference in how we use them!</p>

    <p class="academic-text"><strong>What's a Cycle?</strong></p>
    <p class="academic-text">A cycle is when you can start at a node, follow the connections, and end up back where you started.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Graph WITH a Cycle (You can go in circles!):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#ffebee,stroke:#e91e63,stroke-width:3px
            style B fill:#ffebee,stroke:#e91e63,stroke-width:3px
            style C fill:#ffebee,stroke:#e91e63,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cycle path: Alice ‚Üí Bob ‚Üí Carol ‚Üí Alice (back to start!)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A cycle in an undirected graph is a closed walk with no repeated vertices except the first and last. This graph contains the 3-cycle (Alice, Bob, Carol, Alice).
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Graph WITHOUT Cycles (Tree structure):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- D[Dave]
            C --- E[Eve]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style E fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">No cycles: there's exactly one path between any two nodes</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A tree is a connected acyclic graph. With n vertices, it has exactly n-1 edges. This tree has 5 vertices and 4 edges.
        </div>
    </div>

    <p class="academic-text"><strong>Trees: The Most Important Cycle-Free Graphs</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Tree:</strong> A connected graph with no cycles (like a family tree!)</li>
        <li class="academic-text"><strong>Forest:</strong> Multiple trees together (like a forest of family trees)</li>
        <li class="academic-text"><strong>Cool fact:</strong> A tree with 5 nodes always has exactly 4 connections</li>
    </ul>

    <div class="definition-box">
        <strong>Tree Rule:</strong> A tree with n nodes has exactly n-1 edges. Add one more edge and you create a cycle!
    </div>

    <p class="academic-text"><strong>When Do We Want Cycles vs. No Cycles?</strong></p>
    
    <p class="academic-text"><strong>Graphs WITH Cycles are good for:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Social networks:</strong> You can have mutual friends</li>
        <li class="academic-text"><strong>City roads:</strong> Multiple routes to the same destination</li>
        <li class="academic-text"><strong>Internet:</strong> Backup paths if one connection fails</li>
    </ul>
    
    <p class="academic-text"><strong>Graphs WITHOUT Cycles (Trees) are good for:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Family trees:</strong> Clear parent-child relationships</li>
        <li class="academic-text"><strong>File folders:</strong> Organized hierarchy</li>
        <li class="academic-text"><strong>Decision making:</strong> Step-by-step choices</li>
        <li class="academic-text"><strong>Project tasks:</strong> Do A before B before C (no circular dependencies!)</li>
    </ul>

    <h2 class="section-title" id="ch1-4">1.4 How to Store Graphs in a Computer: Three Simple Ways</h2>

    <p class="academic-text">Just like you can organize your contacts in different ways (phone book, business cards, or a list), there are different ways to store graphs in a computer.</p>

    <p class="academic-text"><strong>Method 1: Adjacency Matrix (Like a Friendship Table)</strong></p>
    <p class="academic-text">Imagine a table where you check off who's friends with whom:</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Friendship Table Example:</strong><br><br>
        <table style="width: 100%; border-collapse: collapse; margin: 15px auto; font-family: monospace; font-size: 14px;">
            <thead>
                <tr style="background-color: #e9ecef;">
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center;"></th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Alice</th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Bob</th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Carol</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Alice</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Bob</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Carol</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                </tr>
            </tbody>
        </table>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">1 = friends (green), 0 = not friends. Alice is friends with Bob and Carol!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An adjacency matrix A for graph G = (V, E) is an n√ón matrix where A[i,j] = 1 if (vi, vj) ‚àà E, and 0 otherwise.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Good for:</strong> When you need to quickly check "Are Alice and Bob friends?"</li>
        <li class="academic-text"><strong>Bad for:</strong> Uses lots of memory if you have many people but few friendships</li>
    </ul>

    <pre class="code-block">// Method 1: Adjacency Matrix Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class AdjacencyMatrix {
private:
    vector&lt;vector&lt;bool&gt;&gt; matrix;
    vector&lt;string&gt; nodeNames;
    unordered_map&lt;string, int&gt; nameToIndex;
    int size;
    
public:
    AdjacencyMatrix(const vector&lt;string&gt;&amp; names) {
        size = names.size();
        nodeNames = names;
        matrix.resize(size, vector&lt;bool&gt;(size, false));
        
        // Map names to indices
        for (int i = 0; i &lt; size; i++) {
            nameToIndex[names[i]] = i;
        }
    }
    
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        int i = nameToIndex[person1];
        int j = nameToIndex[person2];
        matrix[i][j] = true;
        matrix[j][i] = true; // Friendship is mutual
    }
    
    // Check if two people are friends - VERY FAST!
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        int i = nameToIndex[person1];
        int j = nameToIndex[person2];
        return matrix[i][j];
    }
    
    // Print the friendship matrix
    void printMatrix() {
        cout &lt;&lt; "\t";
        for (const string&amp; name : nodeNames) {
            cout &lt;&lt; name &lt;&lt; "\t";
        }
        cout &lt;&lt; endl;
        
        for (int i = 0; i &lt; size; i++) {
            cout &lt;&lt; nodeNames[i] &lt;&lt; "\t";
            for (int j = 0; j &lt; size; j++) {
                cout &lt;&lt; (matrix[i][j] ? "1" : "0") &lt;&lt; "\t";
            }
            cout &lt;&lt; endl;
        }
    }
};</pre>


    <p class="academic-text"><strong>Method 2: Adjacency List (Like Contact Lists on Your Phone)</strong></p>
    <p class="academic-text">Each person has their own list of friends:</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; font-family: monospace; text-align: left;">
        <strong>Contact Lists Example:</strong><br><br>
        <pre style="margin: 0; font-size: 12px;">
Alice's friends: [Bob, Carol]
Bob's friends:   [Alice, Carol]
Carol's friends: [Alice, Bob]
        </pre>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px;">Each person keeps a list of their friends</p>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Good for:</strong> Saves memory when people don't have many friends</li>
        <li class="academic-text"><strong>Good for:</strong> Finding all of someone's friends quickly</li>
    </ul>

    <pre class="code-block">// Method 2: Adjacency List Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

class AdjacencyList {
private:
    // Each person has their own list of friends
    unordered_map&lt;string, vector&lt;string&gt;&gt; friendsMap;
    
public:
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        friendsMap[person1].push_back(person2);
        friendsMap[person2].push_back(person1); // Friendship is mutual
    }
    
    // Get all friends of a person - VERY FAST!
    vector&lt;string&gt; getFriends(const string&amp; person) {
        return friendsMap[person];
    }
    
    // Check if two people are friends (slower than matrix)
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        const auto&amp; friends = friendsMap[person1];
        return find(friends.begin(), friends.end(), person2) != friends.end();
    }
    
    // Count how many friends someone has
    int countFriends(const string&amp; person) {
        return friendsMap[person].size();
    }
    
    // Print everyone's friend lists
    void printLists() {
        for (const auto&amp; [person, friends] : friendsMap) {
            cout &lt;&lt; person &lt;&lt; "'s friends: [";
            for (size_t i = 0; i &lt; friends.size(); i++) {
                cout &lt;&lt; friends[i];
                if (i &lt; friends.size() - 1) cout &lt;&lt; ", ";
            }
            cout &lt;&lt; "]" &lt;&lt; endl;
        }
    }
    
    // Find mutual friends between two people
    vector&lt;string&gt; getMutualFriends(const string&amp; person1, const string&amp; person2) {
        vector&lt;string&gt; mutual;
        const auto&amp; friends1 = friendsMap[person1];
        const auto&amp; friends2 = friendsMap[person2];
        
        for (const string&amp; friend1 : friends1) {
            if (find(friends2.begin(), friends2.end(), friend1) != friends2.end()) {
                mutual.push_back(friend1);
            }
        }
        return mutual;
    }
};</pre>

    <p class="academic-text"><strong>Method 3: Edge List (Like a Simple List of All Friendships)</strong></p>
    <p class="academic-text">Just write down every friendship pair:</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; font-family: monospace; text-align: left;">
        <strong>Friendship List Example:</strong><br><br>
        <pre style="margin: 0; font-size: 12px;">
Friendship 1: Alice - Bob
Friendship 2: Alice - Carol  
Friendship 3: Bob - Carol
        </pre>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px;">Simple list of every friendship</p>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Good for:</strong> When you need to look at all friendships one by one</li>
        <li class="academic-text"><strong>Simple:</strong> Easy to understand and implement</li>
    </ul>

    <pre class="code-block">// Method 3: Edge List Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class EdgeList {
private:
    // Simple list of all friendships
    vector&lt;pair&lt;string, string&gt;&gt; edges;
    
public:
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        edges.push_back({person1, person2});
    }
    
    // Get all edges/friendships - VERY FAST!
    const vector&lt;pair&lt;string, string&gt;&gt;&amp; getAllEdges() {
        return edges;
    }
    
    // Check if two people are friends (slow - must search all edges)
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        for (const auto&amp; edge : edges) {
            if ((edge.first == person1 &amp;&amp; edge.second == person2) ||
                (edge.first == person2 &amp;&amp; edge.second == person1)) {
                return true;
            }
        }
        return false;
    }
    
    // Count total number of friendships
    int getTotalFriendships() {
        return edges.size();
    }
    
    // Print all friendships
    void printAllFriendships() {
        cout &lt;&lt; "All Friendships:" &lt;&lt; endl;
        for (size_t i = 0; i &lt; edges.size(); i++) {
            cout &lt;&lt; "Friendship " &lt;&lt; (i + 1) &lt;&lt; ": " 
                 &lt;&lt; edges[i].first &lt;&lt; " - " &lt;&lt; edges[i].second &lt;&lt; endl;
        }
    }
    
    // Find all friends of a person (slow - must search all edges)
    vector&lt;string&gt; getFriends(const string&amp; person) {
        vector&lt;string&gt; friends;
        for (const auto&amp; edge : edges) {
            if (edge.first == person) {
                friends.push_back(edge.second);
            } else if (edge.second == person) {
                friends.push_back(edge.first);
            }
        }
        return friends;
    }
};</pre>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Quick Comparison: Which Method to Choose?</strong><br><br>
        <table style="width: 100%; border-collapse: collapse; font-size: 12pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333;">
                    <th style="text-align: left; padding: 8px; font-weight: bold;">What you want to do</th>
                    <th style="text-align: left; padding: 8px; font-weight: bold;">Best Method</th>
                    <th style="text-align: left; padding: 8px; font-weight: bold;">Why?</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 8px;">Quickly check if two people are friends</td>
                    <td style="padding: 8px;"><strong>Matrix</strong></td>
                    <td style="padding: 8px;">Instant lookup</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Find all of someone's friends</td>
                    <td style="padding: 8px;"><strong>List</strong></td>
                    <td style="padding: 8px;">Already organized by person</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Save memory with few friendships</td>
                    <td style="padding: 8px;"><strong>List or Edge List</strong></td>
                    <td style="padding: 8px;">Only stores actual friendships</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Process all friendships one by one</td>
                    <td style="padding: 8px;"><strong>Edge List</strong></td>
                    <td style="padding: 8px;">Simple to iterate through</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2 class="section-title" id="ch1-5">1.5 Graphs Are Everywhere: Real Examples You Know</h2>

    <p class="academic-text">Once you understand graphs, you'll see them everywhere! Here are some examples from your daily life:</p>

    <p class="academic-text"><strong>1. Social Media (Facebook, Instagram, Twitter)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> You and your friends</li>
            <li class="academic-text"><strong>Edges:</strong> Friend connections or follows</li>
            <li class="academic-text"><strong>What it helps with:</strong> "People you may know" suggestions, showing mutual friends</li>
            <li class="academic-text"><strong>Cool fact:</strong> You're usually connected to anyone in the world through just 6 people!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>2. GPS Navigation (Google Maps, Apple Maps)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Intersections, cities, landmarks</li>
            <li class="academic-text"><strong>Edges:</strong> Roads, highways, walking paths (with distances and speed limits)</li>
            <li class="academic-text"><strong>What it helps with:</strong> Finding the fastest route, avoiding traffic, calculating travel time</li>
            <li class="academic-text"><strong>Cool fact:</strong> Your GPS considers millions of possible routes in seconds!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>3. The Internet</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Websites, servers, your computer</li>
            <li class="academic-text"><strong>Edges:</strong> Links between websites, network connections</li>
            <li class="academic-text"><strong>What it helps with:</strong> Finding paths for your data, web page ranking (Google search), detecting broken links</li>
            <li class="academic-text"><strong>Cool fact:</strong> When you click a link, you're following an edge in the world's largest graph!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>4. Course Prerequisites (College/University)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Classes (Math 101, Physics 201, etc.)</li>
            <li class="academic-text"><strong>Edges:</strong> "Must take this class before that one" relationships</li>
            <li class="academic-text"><strong>What it helps with:</strong> Planning your course schedule, making sure you meet requirements</li>
            <li class="academic-text"><strong>Cool fact:</strong> This type of graph can't have cycles - you can't have circular prerequisites!</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>5. Recommendation Systems (Netflix, Amazon, Spotify)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> You, other users, movies, products, songs</li>
            <li class="academic-text"><strong>Edges:</strong> "User likes this item" or "Users who are similar"</li>
            <li class="academic-text"><strong>What it helps with:</strong> "People who bought this also bought...", "Because you watched..."</li>
            <li class="academic-text"><strong>Cool fact:</strong> The system finds people with similar tastes to you and recommends what they liked!</li>
        </ul>
    </div>

    <pre class="code-block">// Simple course planning system - like a college advisor!
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;set&gt;
using namespace std;

class CourseAdvisor {
private:
    // Each course has a list of courses you need to take first
    unordered_map&lt;string, vector&lt;string&gt;&gt; prerequisites;
    
public:
    // Add a requirement: "To take course X, you must first complete course Y"
    void addRequirement(string course, string mustTakeFirst) {
        prerequisites[course].push_back(mustTakeFirst);
    }
    
    // Check if a student can take a specific course
    bool canStudentTakeCourse(string course, set&lt;string&gt; completedCourses) {
        // Check each requirement for this course
        for (const string&amp; requiredCourse : prerequisites[course]) {
            if (completedCourses.find(requiredCourse) == completedCourses.end()) {
                return false; // Missing a required course!
            }
        }
        return true; // All requirements met!
    }
    
    // Find all courses a student can take right now
    vector&lt;string&gt; getCoursesStudentCanTake(set&lt;string&gt; completedCourses) {
        vector&lt;string&gt; availableCourses;
        
        for (const auto&amp; [course, requirements] : prerequisites) {
            // Skip courses already completed
            if (completedCourses.find(course) != completedCourses.end()) continue;
            
            // Check if student can take this course
            if (canStudentTakeCourse(course, completedCourses)) {
                availableCourses.push_back(course);
            }
        }
        return availableCourses;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üéØ Try This Yourself!</h3>
        <p class="academic-text">Now that you understand graphs, let's practice! Pick something from your daily life and turn it into a graph:</p>
        
        <div style="background-color: white; border-radius: 8px; padding: 20px; margin: 15px 0;">
            <h4 style="color: #2e7d32; margin-top: 0;">Example: Your School or Workplace</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>Nodes:</strong> Classrooms, offices, cafeteria, library, parking lots</li>
                <li class="academic-text"><strong>Edges:</strong> Hallways, stairs, walkways</li>
                <li class="academic-text"><strong>Weights:</strong> Walking time between locations</li>
                <li class="academic-text"><strong>Type:</strong> Undirected (you can walk both ways), Weighted (different distances)</li>
                <li class="academic-text"><strong>Use:</strong> Find shortest path to your next class!</li>
            </ul>
        </div>
        
        <p class="academic-text"><strong>Your turn:</strong></p>
        <ol style="margin: 12px 0; padding-left: 20px;">
            <li class="academic-text">Pick a system you know well (your neighborhood, a video game, your family, etc.)</li>
            <li class="academic-text">What are the nodes? (people, places, things)</li>
            <li class="academic-text">What are the edges? (relationships, connections, paths)</li>
            <li class="academic-text">Does direction matter? Are some connections stronger than others?</li>
            <li class="academic-text">What questions could you answer with this graph?</li>
        </ol>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Congratulations!</h3>
        <p class="academic-text">You now understand the fundamental building blocks of graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Nodes and edges</strong> - the dots and lines that make up any graph</li>
            <li class="academic-text">‚úÖ <strong>Different types</strong> - directed vs undirected, weighted vs unweighted</li>
            <li class="academic-text">‚úÖ <strong>Storage methods</strong> - matrices, lists, and edge lists</li>
            <li class="academic-text">‚úÖ <strong>Real-world examples</strong> - from social media to GPS navigation</li>
        </ul>
        
        <p class="academic-text">These concepts are the foundation for everything else in graph theory. In the next chapter, we'll dive deeper into <strong>trees</strong> - special graphs that are everywhere in computer science, from file systems to decision making!</p>
        
        <p class="academic-text" style="font-style: italic; color: #666;">Remember: Every expert was once a beginner. You're building something amazing, one concept at a time! üöÄ</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch2">
        
    <div class="chapter-number">Chapter 2</div>
    <h1 class="chapter-title">Graph Properties & Special Types</h1>
    
    <div class="definition-box">
        "Not all graphs are created equal - understanding their special properties unlocks the right algorithms and solutions."
    </div>

    <p class="academic-text">Now that you understand basic graphs, let's dive deeper into their special properties. Just like people have different personalities, graphs have characteristics that determine what you can do with them and which algorithms work best.</p>
    
    <p class="academic-text">In this chapter, we'll explore the key properties that graph theorists and computer scientists use to classify and analyze graphs:</p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Connectivity:</strong> Can you get from anywhere to anywhere?</li>
        <li class="academic-text"><strong>Cycles:</strong> Are there circular paths in your graph?</li>
        <li class="academic-text"><strong>Bipartite structure:</strong> Can you divide nodes into two groups?</li>
        <li class="academic-text"><strong>Density:</strong> How many connections exist vs. how many could exist?</li>
    </ul>
    
    <p class="academic-text">These properties aren't just academic curiosities - they directly impact which algorithms you can use and how efficiently they'll run. Let's explore each one!</p>

    <h2 class="section-title" id="ch2-1">2.1 Connectivity: The Foundation of Graph Analysis</h2>
    
    <p class="academic-text">Connectivity is one of the most fundamental properties in graph theory. It determines whether your graph is "all one piece" or broken into separate components.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîó Connected Graph</h3>
        <p class="academic-text">A graph is <strong>connected</strong> if there exists a path between every pair of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path:</strong> A sequence of edges that connects two vertices</li>
            <li class="academic-text"><strong>Reachability:</strong> If you can get from A to B, we say B is reachable from A</li>
            <li class="academic-text"><strong>Examples:</strong> Social networks, transportation systems, communication networks</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Why connectivity matters:</strong> Many graph algorithms only work on connected graphs, or they need to be run separately on each connected component.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Connected Graph (Everyone Can Reach Everyone):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            B --- C[Carol]
            C --- D[Dave]
            A --- D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Alice can reach Dave through Bob or Carol - everyone is reachable!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Technical note:</strong> In a connected graph with n vertices, you need at least n-1 edges. This is because you need enough edges to "link" all vertices together without leaving anyone isolated.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Disconnected Graph (Isolated Groups):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            C[Carol] --- D[Dave]
            E[Eve]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Three separate components - Alice can't reach Carol, and Eve is completely isolated</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A graph is disconnected if it contains two or more connected components that are not connected to each other.
        </div>
    </div>

    <p class="academic-text"><strong>Real-World Examples:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Connected:</strong> Internet (you can reach any website), highway system, social networks</li>
        <li class="academic-text"><strong>Disconnected:</strong> Separate friend groups, isolated computer networks, different continents without bridges</li>
    </ul>

    <pre class="code-block">// Check if a graph is connected using DFS
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
using namespace std;

class ConnectivityChecker {
private:
    unordered_map<string, vector<string>> graph;
    
    // Depth-First Search to visit all reachable nodes
    void dfs(const string& node, unordered_set<string>& visited) {
        visited.insert(node);
        for (const string& neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                dfs(neighbor, visited);
            }
        }
    }
    
public:
    void addEdge(const string& u, const string& v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Check if the graph is connected
    bool isConnected() {
        if (graph.empty()) return true;
        
        unordered_set<string> visited;
        string startNode = graph.begin()->first;
        
        // Start DFS from any node
        dfs(startNode, visited);
        
        // If we visited all nodes, the graph is connected
        return visited.size() == graph.size();
    }
    
    // Find all connected components
    vector<vector<string>> getConnectedComponents() {
        vector<vector<string>> components;
        unordered_set<string> globalVisited;
        
        for (const auto& [node, neighbors] : graph) {
            if (globalVisited.find(node) == globalVisited.end()) {
                unordered_set<string> componentVisited;
                dfs(node, componentVisited);
                
                vector<string> component;
                for (const string& n : componentVisited) {
                    component.push_back(n);
                    globalVisited.insert(n);
                }
                components.push_back(component);
            }
        }
        return components;
    }
};</pre>

    <h2 class="section-title" id="ch2-2">2.2 Strongly Connected Components: The Direction Matters</h2>

    <p class="academic-text">In directed graphs, connectivity gets more interesting! A <strong>strongly connected component (SCC)</strong> is a group of nodes where you can get from any node to any other node following the arrow directions.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Strongly Connected Components Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --> B[Bob]
            B --> C[Carol]
            C --> A
            
            D[Dave] --> E[Eve]
            E --> F[Frank]
            F --> D
            
            B --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two SCCs: {Alice, Bob, Carol} and {Dave, Eve, Frank}. You can go from Alice‚ÜíBob‚ÜíCarol‚ÜíAlice, but not back from Dave to Bob!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A strongly connected component is a maximal set of vertices such that for every pair of vertices u and v, there is a directed path from u to v and from v to u.
        </div>
    </div>

    <p class="academic-text"><strong>Why SCCs Matter:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Web analysis:</strong> Groups of websites that link to each other</li>
        <li class="academic-text"><strong>Social networks:</strong> Tight-knit communities where everyone follows everyone</li>
        <li class="academic-text"><strong>Software dependencies:</strong> Circular dependencies that need to be resolved together</li>
    </ul>

    <h2 class="section-title" id="ch2-3">2.3 Directed Acyclic Graphs (DAGs): No Going in Circles</h2>

    <p class="academic-text">A <strong>Directed Acyclic Graph (DAG)</strong> is a directed graph with no cycles. Think of it as a one-way system where you can never return to where you started by following the arrows.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DAG Example (Course Prerequisites):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> B[Math 201]
            A --> C[Physics 101]
            B --> D[Math 301]
            C --> E[Physics 201]
            D --> F[Advanced Math]
            E --> F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Clear progression from basic to advanced courses - no circular prerequisites!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A DAG is a directed graph with no directed cycles. It has a topological ordering where vertices can be arranged so all edges point "forward."
        </div>
    </div>

    <p class="academic-text"><strong>DAG Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Task scheduling:</strong> Project tasks with dependencies</li>
        <li class="academic-text"><strong>Build systems:</strong> Compile order for software modules</li>
        <li class="academic-text"><strong>Family trees:</strong> Ancestry relationships</li>
        <li class="academic-text"><strong>Decision trees:</strong> Step-by-step decision making</li>
    </ul>

    <pre class="code-block">// Simple DAG implementation for task scheduling
#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <string>
using namespace std;

class TaskScheduler {
private:
    unordered_map<string, vector<string>> dependencies; // task -> list of tasks it depends on
    unordered_map<string, vector<string>> dependents;   // task -> list of tasks that depend on it
    unordered_map<string, int> inDegree;               // task -> number of dependencies
    
public:
    void addTask(const string& task) {
        if (dependencies.find(task) == dependencies.end()) {
            dependencies[task] = vector<string>();
            dependents[task] = vector<string>();
            inDegree[task] = 0;
        }
    }
    
    // Add dependency: taskB depends on taskA (taskA must be done before taskB)
    void addDependency(const string& taskA, const string& taskB) {
        addTask(taskA);
        addTask(taskB);
        
        dependencies[taskB].push_back(taskA);
        dependents[taskA].push_back(taskB);
        inDegree[taskB]++;
    }
    
    // Get the order in which tasks should be completed (topological sort)
    vector<string> getTaskOrder() {
        vector<string> result;
        queue<string> readyTasks;
        unordered_map<string, int> currentInDegree = inDegree;
        
        // Find tasks with no dependencies
        for (const auto& [task, degree] : currentInDegree) {
            if (degree == 0) {
                readyTasks.push(task);
            }
        }
        
        while (!readyTasks.empty()) {
            string currentTask = readyTasks.front();
            readyTasks.pop();
            result.push_back(currentTask);
            
            // Remove this task and update dependencies
            for (const string& dependent : dependents[currentTask]) {
                currentInDegree[dependent]--;
                if (currentInDegree[dependent] == 0) {
                    readyTasks.push(dependent);
                }
            }
        }
        
        // Check if we have a cycle (couldn't complete all tasks)
        if (result.size() != dependencies.size()) {
            cout << "Error: Circular dependency detected!" << endl;
            return vector<string>();
        }
        
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch2-4">2.4 Bipartite Graphs and Graph Density: Special Structures</h2>

    <p class="academic-text"><strong>Bipartite Graphs: Two Sides of the Story</strong></p>
    <p class="academic-text">A <strong>bipartite graph</strong> is like a dance where partners can only be from the opposite group. You can divide all nodes into two groups, and edges only connect nodes from different groups - never within the same group.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bipartite Graph (Students and Courses):</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph Students
                A[Alice]
                B[Bob]
                C[Carol]
            end
            
            subgraph Courses
                D[Math]
                E[Physics]
                F[Chemistry]
            end
            
            A --- D
            A --- E
            B --- D
            B --- F
            C --- E
            C --- F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Students only connect to courses, courses only connect to students - no student-to-student edges!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A bipartite graph G = (V, E) has vertex set V that can be partitioned into two disjoint sets V‚ÇÅ and V‚ÇÇ such that every edge connects a vertex in V‚ÇÅ to a vertex in V‚ÇÇ.
        </div>
    </div>

    <p class="academic-text"><strong>Graph Density: How Connected Is Your Graph?</strong></p>
    <p class="academic-text">Graph density measures how "full" your graph is - what percentage of all possible edges actually exist.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Density Examples:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Sparse Graph (Low Density)"
                A1[A] --- B1[B]
                C1[C] --- D1[D]
            end
            
            subgraph "Dense Graph (High Density)"
                A2[A] --- B2[B]
                A2 --- C2[C]
                A2 --- D2[D]
                B2 --- C2
                B2 --- D2
                C2 --- D2
            end
            
            style A1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style D1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            
            style A2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Sparse: 2 edges out of 6 possible (33% density) vs Dense: 6 edges out of 6 possible (100% density)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> For an undirected graph with n vertices, density = 2|E| / (n(n-1)), where |E| is the number of edges. Range: 0 (no edges) to 1 (complete graph).
        </div>
    </div>

    <pre class="code-block">// Graph analysis tools
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
using namespace std;

class GraphAnalyzer {
private:
    unordered_map<string, vector<string>> graph;
    
public:
    void addEdge(const string& u, const string& v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Calculate graph density
    double getDensity() {
        int n = graph.size();
        if (n <= 1) return 0.0;
        
        int edges = 0;
        for (const auto& [node, neighbors] : graph) {
            edges += neighbors.size();
        }
        edges /= 2; // Each edge counted twice in undirected graph
        
        int maxPossibleEdges = n * (n - 1) / 2;
        return (double)edges / maxPossibleEdges;
    }
    
    // Check if graph is bipartite using 2-coloring
    bool isBipartite() {
        if (graph.empty()) return true;
        
        unordered_map<string, int> color; // 0 = uncolored, 1 = red, 2 = blue
        
        for (const auto& [startNode, neighbors] : graph) {
            if (color[startNode] == 0) {
                // Start BFS/DFS from this component
                vector<string> queue = {startNode};
                color[startNode] = 1;
                
                for (size_t i = 0; i < queue.size(); i++) {
                    string current = queue[i];
                    int currentColor = color[current];
                    int neighborColor = (currentColor == 1) ? 2 : 1;
                    
                    for (const string& neighbor : graph[current]) {
                        if (color[neighbor] == 0) {
                            color[neighbor] = neighborColor;
                            queue.push_back(neighbor);
                        } else if (color[neighbor] == currentColor) {
                            return false; // Same color as neighbor - not bipartite!
                        }
                    }
                }
            }
        }
        return true;
    }
    
    void printAnalysis() {
        cout << "Graph Analysis:" << endl;
        cout << "Nodes: " << graph.size() << endl;
        cout << "Density: " << (getDensity() * 100) << "%" << endl;
        cout << "Bipartite: " << (isBipartite() ? "Yes" : "No") << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üéØ Quick Reference: Graph Properties</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Connectivity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Connected:</strong> Path between any two nodes</li>
                    <li class="academic-text"><strong>SCC:</strong> Directed cycles in directed graphs</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Structure</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>DAG:</strong> No cycles, has ordering</li>
                    <li class="academic-text"><strong>Bipartite:</strong> Two groups, edges between groups</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 2 Complete!</h3>
        <p class="academic-text">You now understand the key properties that make graphs special:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Connectivity</strong> - whether you can reach everywhere</li>
            <li class="academic-text">‚úÖ <strong>Strong connectivity</strong> - directed graph communities</li>
            <li class="academic-text">‚úÖ <strong>DAGs</strong> - ordered structures without cycles</li>
            <li class="academic-text">‚úÖ <strong>Bipartite graphs</strong> - two-sided relationships</li>
            <li class="academic-text">‚úÖ <strong>Graph density</strong> - how connected your graph is</li>
        </ul>
        
        <p class="academic-text">These properties help you choose the right algorithms and understand what's possible with your graph. Next up: <strong>Trees</strong> - the most important special case of graphs!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch3">
        
    <div class="chapter-number">Chapter 3</div>
    <h1 class="chapter-title">Trees ‚Äî The Simplest Graphs</h1>
    
    <div class="definition-box">
        "Trees are everywhere - from your family tree to your computer's file system. They're the most useful special case of graphs."
    </div>

    <p class="academic-text">Trees are the most important special case of graphs. They're connected graphs with no cycles - giving them a perfect balance of structure and simplicity that makes them incredibly useful in computer science.</p>
    
    <p class="academic-text"><strong>Why trees matter:</strong> Trees appear everywhere in computing and real life because they naturally represent hierarchical relationships and provide efficient ways to organize and search data.</p>
    
    <p class="academic-text"><strong>You interact with trees daily:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>File systems:</strong> Folders containing subfolders and files</li>
        <li class="academic-text"><strong>Family trees:</strong> Parents, children, and generational relationships</li>
        <li class="academic-text"><strong>Organization charts:</strong> Company hierarchies and reporting structures</li>
        <li class="academic-text"><strong>Decision making:</strong> "If this, then that" branching logic</li>
        <li class="academic-text"><strong>Web pages:</strong> HTML DOM structure with nested elements</li>
    </ul>

    <h2 class="section-title" id="ch3-1">3.1 Tree Properties and Terminology</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üå≥ Tree Definition</h3>
        <p class="academic-text">A <strong>tree</strong> is a connected graph with no cycles.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Connected:</strong> You can reach any node from any other node</li>
            <li class="academic-text"><strong>Acyclic:</strong> No circular paths - there's exactly one path between any two nodes</li>
            <li class="academic-text"><strong>Minimal:</strong> Remove any edge and it becomes disconnected</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Amazing tree properties:</strong> This simple definition leads to some remarkable mathematical properties that make trees so useful.</p>
    
    <p class="academic-text"><strong>Key tree facts:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text">A tree with n vertices has exactly n-1 edges</li>
        <li class="academic-text">There's exactly one path between any two vertices</li>
        <li class="academic-text">Adding any edge creates exactly one cycle</li>
        <li class="academic-text">Removing any edge disconnects the tree</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Example (Family Tree):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Grandpa] --> B[Dad]
            A --> C[Uncle]
            B --> D[You]
            B --> E[Sister]
            C --> F[Cousin]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">6 nodes, 5 edges - exactly n-1 edges for n nodes!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A tree is a connected acyclic graph. For n vertices, it has exactly n-1 edges.
        </div>
    </div>

    <p class="academic-text"><strong>Tree Terminology:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Root:</strong> The top node (Grandpa in our example)</li>
        <li class="academic-text"><strong>Parent:</strong> Node directly above (Dad is parent of You)</li>
        <li class="academic-text"><strong>Child:</strong> Node directly below (You are child of Dad)</li>
        <li class="academic-text"><strong>Leaf:</strong> Node with no children (You, Sister, Cousin)</li>
        <li class="academic-text"><strong>Height:</strong> Longest path from root to leaf (3 levels)</li>
        <li class="academic-text"><strong>Depth:</strong> Distance from root to a node</li>
    </ul>

    <pre class="code-block">// Simple Node structure
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple node - just holds data and connections
struct Node {
    string data;
    vector<Node*> children;
    
    Node(string value) : data(value) {}
};

// Tree builder functions
class TreeBuilder {
public:
    // Create a simple family tree from arrays
    static Node* buildFamilyTree() {
        Node* grandpa = new Node("Grandpa");
        Node* dad = new Node("Dad");
        Node* uncle = new Node("Uncle");
        Node* you = new Node("You");
        Node* sister = new Node("Sister");
        Node* cousin = new Node("Cousin");
        
        // Build the tree structure
        grandpa->children = {dad, uncle};
        dad->children = {you, sister};
        uncle->children = {cousin};
        
        return grandpa;
    }
    
    // Build tree from parent-child pairs
    static Node* buildFromPairs(vector<pair<string, string>> relationships) {
        // relationships = {("parent", "child"), ("parent", "child2"), ...}
        // Implementation would map relationships to tree structure
        // Simplified for clarity
        return nullptr;
    }
    
    // Print tree in a simple way
    static void printTree(Node* root, int indent = 0) {
        if (root == nullptr) return;
        
        for (int i = 0; i < indent; i++) cout << "  ";
        cout << root->data << endl;
        
        for (Node* child : root->children) {
            printTree(child, indent + 1);
        }
    }
    
    // Check if node is a leaf (no children)
    static bool isLeaf(Node* node) {
        return node->children.empty();
    }
};</pre>

    <h2 class="section-title" id="ch3-2">3.2 Binary Trees, N-ary Trees, Binary Search Trees</h2>

    <p class="academic-text"><strong>Binary Trees: Two Children Max</strong></p>
    <p class="academic-text">A binary tree is a tree where each node has at most 2 children (left and right). They're the most common type of tree in computer science.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[A] --> B[B]
            A --> C[C]
            B --> D[D]
            B --> E[E]
            C --> F[F]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each node has at most 2 children</p>
    </div>

    <p class="academic-text"><strong>Binary Search Trees: Organized for Fast Search</strong></p>
    <p class="academic-text">A BST is a binary tree with a special rule: left child < parent < right child. This makes searching super fast!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Search Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[50] --> B[30]
            A --> C[70]
            B --> D[20]
            B --> E[40]
            C --> F[60]
            C --> G[80]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Left < Parent < Right rule makes searching O(log n)</p>
    </div>

    <pre class="code-block">// Simple Binary Search Tree
#include <iostream>
using namespace std;

// Simple binary node
struct BinaryNode {
    int data;
    BinaryNode* left;
    BinaryNode* right;
    
    BinaryNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

// BST helper functions
class BST {
public:
    // Build a sample BST
    static BinaryNode* buildSampleBST() {
        BinaryNode* root = new BinaryNode(50);
        root->left = new BinaryNode(30);
        root->right = new BinaryNode(70);
        root->left->left = new BinaryNode(20);
        root->left->right = new BinaryNode(40);
        root->right->left = new BinaryNode(60);
        root->right->right = new BinaryNode(80);
        return root;
    }
    
    // Simple search function
    static bool search(BinaryNode* root, int target) {
        if (root == nullptr) return false;
        if (root->data == target) return true;
        
        if (target < root->data) {
            return search(root->left, target);
        } else {
            return search(root->right, target);
        }
    }
    
    // Insert a new value
    static BinaryNode* insert(BinaryNode* root, int value) {
        if (root == nullptr) {
            return new BinaryNode(value);
        }
        
        if (value < root->data) {
            root->left = insert(root->left, value);
        } else if (value > root->data) {
            root->right = insert(root->right, value);
        }
        return root;
    }
    
    // Print in sorted order
    static void printInOrder(BinaryNode* root) {
        if (root != nullptr) {
            printInOrder(root->left);
            cout << root->data << " ";
            printInOrder(root->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-3">3.3 Tree Traversals: Different Ways to Visit Nodes</h2>

    <p class="academic-text">Tree traversal means visiting every node in the tree. There are different orders you can visit them, each useful for different purposes.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Traversal Orders:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[2]
            A --> C[3]
            B --> D[4]
            B --> E[5]
            C --> F[6]
            C --> G[7]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">
            <strong>Preorder:</strong> 1, 2, 4, 5, 3, 6, 7 (Root first)<br>
            <strong>Inorder:</strong> 4, 2, 5, 1, 6, 3, 7 (Left, Root, Right)<br>
            <strong>Postorder:</strong> 4, 5, 2, 6, 7, 3, 1 (Root last)<br>
            <strong>Level-order:</strong> 1, 2, 3, 4, 5, 6, 7 (Level by level)
        </p>
    </div>

    <p class="academic-text"><strong>When to Use Each Traversal:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Preorder:</strong> Copy/clone tree, prefix expressions</li>
        <li class="academic-text"><strong>Inorder:</strong> Get sorted order from BST</li>
        <li class="academic-text"><strong>Postorder:</strong> Delete tree, calculate directory sizes</li>
        <li class="academic-text"><strong>Level-order:</strong> Print tree level by level, shortest path</li>
    </ul>

    <pre class="code-block">// Simple tree traversal functions
#include <iostream>
#include <queue>
using namespace std;

class TreeTraversal {
public:
    // Preorder: Root -> Left -> Right
    static void preorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        cout << node->data << " ";  // Visit root first
        preorder(node->left);       // Then left subtree
        preorder(node->right);      // Then right subtree
    }
    
    // Inorder: Left -> Root -> Right (gives sorted order for BST)
    static void inorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        inorder(node->left);        // Visit left subtree first
        cout << node->data << " ";  // Then root
        inorder(node->right);       // Then right subtree
    }
    
    // Postorder: Left -> Right -> Root
    static void postorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        postorder(node->left);      // Visit left subtree first
        postorder(node->right);     // Then right subtree
        cout << node->data << " ";  // Then root last
    }
    
    // Level-order: Visit level by level using queue
    static void levelOrder(BinaryNode* root) {
        if (root == nullptr) return;
        
        queue<BinaryNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            BinaryNode* current = q.front();
            q.pop();
            
            cout << current->data << " ";
            
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-4">3.4 Applications in File Systems and Hierarchies</h2>

    <p class="academic-text">Trees are everywhere in real life! Let's see how they power the systems you use every day.</p>

    <p class="academic-text"><strong>File System Tree</strong></p>
    <p class="academic-text">Your computer's file system is a tree! Folders are internal nodes, files are leaves.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>File System Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[/] --> B[home]
            A --> C[usr]
            A --> D[var]
            B --> E[user1]
            B --> F[user2]
            E --> G[Documents]
            E --> H[Pictures]
            G --> I[resume.pdf]
            G --> J[notes.txt]
            H --> K[vacation.jpg]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#ffebee,stroke:#f44336,stroke-width:2px
            style H fill:#ffebee,stroke:#f44336,stroke-width:2px
            style I fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
            style J fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
            style K fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each path from root to file is unique - no cycles!</p>
    </div>

    <pre class="code-block">// Simple file system tree
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple file/folder node
struct FileNode {
    string name;
    bool isFile;
    vector<FileNode*> children;
    int size; // for files only
    
    FileNode(string n, bool file = false, int s = 0) 
        : name(n), isFile(file), size(s) {}
};

class FileSystem {
public:
    // Build a sample file system
    static FileNode* buildSampleFileSystem() {
        FileNode* root = new FileNode("/", false);
        FileNode* home = new FileNode("home", false);
        FileNode* user = new FileNode("user1", false);
        FileNode* docs = new FileNode("Documents", false);
        FileNode* pics = new FileNode("Pictures", false);
        
        FileNode* resume = new FileNode("resume.pdf", true, 1024);
        FileNode* notes = new FileNode("notes.txt", true, 512);
        FileNode* photo = new FileNode("vacation.jpg", true, 2048);
        
        // Build the tree structure
        root->children = {home};
        home->children = {user};
        user->children = {docs, pics};
        docs->children = {resume, notes};
        pics->children = {photo};
        
        return root;
    }
    
    // Print file system tree
    static void printFileSystem(FileNode* root, int indent = 0) {
        if (root == nullptr) return;
        
        for (int i = 0; i < indent; i++) cout << "  ";
        cout << root->name;
        if (root->isFile) {
            cout << " (" << root->size << " bytes)";
        } else {
            cout << "/";
        }
        cout << endl;
        
        for (FileNode* child : root->children) {
            printFileSystem(child, indent + 1);
        }
    }
    
    // Calculate total directory size
    static int getTotalSize(FileNode* root) {
        if (root->isFile) return root->size;
        
        int total = 0;
        for (FileNode* child : root->children) {
            total += getTotalSize(child);
        }
        return total;
    }
};</pre>

    <p class="academic-text"><strong>Other Tree Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Organization Charts:</strong> Company hierarchy</li>
        <li class="academic-text"><strong>Decision Trees:</strong> AI and machine learning</li>
        <li class="academic-text"><strong>Parse Trees:</strong> Compilers and language processing</li>
        <li class="academic-text"><strong>Game Trees:</strong> Chess, tic-tac-toe game states</li>
        <li class="academic-text"><strong>Heap Trees:</strong> Priority queues (coming in Chapter 5!)</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üå≥ Tree Properties Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Key Properties</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Connected + No cycles</li>
                    <li class="academic-text">n nodes = n-1 edges</li>
                    <li class="academic-text">Unique path between any two nodes</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Common Types</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Binary Tree (‚â§2 children)</li>
                    <li class="academic-text">BST (ordered binary tree)</li>
                    <li class="academic-text">N-ary Tree (any # children)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 3 Complete!</h3>
        <p class="academic-text">You now understand trees - the most important special graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Tree properties</strong> - connected, acyclic, n-1 edges</li>
            <li class="academic-text">‚úÖ <strong>Binary trees & BSTs</strong> - organized for fast operations</li>
            <li class="academic-text">‚úÖ <strong>Tree traversals</strong> - different ways to visit nodes</li>
            <li class="academic-text">‚úÖ <strong>Real applications</strong> - file systems, hierarchies</li>
        </ul>
        
        <p class="academic-text">Trees are the foundation for many advanced data structures. Next: <strong>Tries</strong> - specialized trees for string processing!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch4">
        
    <div class="chapter-number">Chapter 4</div>
    <h1 class="chapter-title">Tries and Prefix Structures</h1>
    
    <div class="definition-box">
        "Tries are the secret behind autocomplete, spell checkers, and fast string searches. They're trees specialized for text!"
    </div>

    <p class="academic-text">Ever wonder how your phone predicts what you're typing? Or how Google instantly suggests search terms as you type? The answer is <strong>tries</strong> (pronounced "tries" like "tries to help")! They're specialized trees designed specifically for working with strings and text.</p>
    
    <p class="academic-text"><strong>Tries solve text problems efficiently:</strong> While regular trees are great for hierarchical data, tries are optimized for string operations like searching, autocomplete, and spell checking.</p>
    
    <p class="academic-text"><strong>Where you encounter tries:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> Google's search suggestions as you type</li>
        <li class="academic-text"><strong>Text editors:</strong> Autocomplete for code and variable names</li>
        <li class="academic-text"><strong>Spell checkers:</strong> Finding and suggesting correct spellings</li>
        <li class="academic-text"><strong>Phone contacts:</strong> T9 predictive text on older phones</li>
        <li class="academic-text"><strong>IP routing:</strong> Internet routers finding network paths</li>
    </ul>

    <h2 class="section-title" id="ch4-1">4.1 Trie Data Structure and Operations</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üî§ Trie Definition</h3>
        <p class="academic-text">A <strong>trie</strong> (prefix tree) is a tree where each path from root represents a string, and each node represents a character.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path = Word:</strong> Each root-to-node path spells out a prefix or complete word</li>
            <li class="academic-text"><strong>Shared Prefixes:</strong> Words with common beginnings share the same path</li>
            <li class="academic-text"><strong>Marked Endings:</strong> Special markers indicate where complete words end</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Why tries are brilliant:</strong> They store thousands of words efficiently by sharing common prefixes. Instead of storing "CAR", "CARD", and "CARE" separately, they share the "CAR" prefix!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Trie Example (Words: CAT, CAR, CARD, CARE, CAREFUL):</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D[D*]
            R --> E[E*]
            E --> F[F]
            F --> U[U]
            U --> L[L*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style A fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style R fill:#ffebee,stroke:#f44336,stroke-width:3px
            style D fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style E fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style F fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style U fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style L fill:#f1f8e9,stroke:#8bc34a,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">* marks end of word. Path ROOT‚ÜíC‚ÜíA‚ÜíT spells "CAT"</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A trie is a tree data structure where each node represents a character and each path from root to a marked node represents a stored string.
        </div>
    </div>

    <p class="academic-text"><strong>Why Tries Are Amazing:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Shared prefixes:</strong> "CAR", "CARD", "CARE" share the path C‚ÜíA‚ÜíR</li>
        <li class="academic-text"><strong>Fast lookup:</strong> Find any word in O(word length) time</li>
        <li class="academic-text"><strong>Prefix magic:</strong> Find all words starting with "CA" instantly</li>
        <li class="academic-text"><strong>Memory efficient:</strong> Common prefixes stored only once</li>
    </ul>

    <pre class="code-block">// Simple Trie implementation
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple trie node
struct TrieNode {
    vector<TrieNode*> children;
    bool isEndOfWord;
    char character;
    
    TrieNode(char c = '\0') : character(c), isEndOfWord(false) {
        children.resize(26, nullptr); // for a-z
    }
};

class SimpleTrie {
private:
    TrieNode* root;
    
    int charToIndex(char c) {
        return c - 'a'; // convert 'a' to 0, 'b' to 1, etc.
    }
    
public:
    SimpleTrie() {
        root = new TrieNode();
    }
    
    // Insert a word into the trie
    void insert(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            
            if (current->children[index] == nullptr) {
                current->children[index] = new TrieNode(c);
            }
            current = current->children[index];
        }
        current->isEndOfWord = true;
    }
    
    // Search for a word
    bool search(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return current->isEndOfWord;
    }
    
    // Check if any word starts with this prefix
    bool startsWith(string prefix) {
        TrieNode* current = root;
        
        for (char c : prefix) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return true; // We found the complete prefix path
    }
    
    // Build a sample trie with common words
    static SimpleTrie* buildSampleTrie() {
        SimpleTrie* trie = new SimpleTrie();
        vector<string> words = {"cat", "car", "card", "care", "careful", "dog", "dodge"};
        
        for (string word : words) {
            trie->insert(word);
        }
        return trie;
    }
};</pre>

    <h2 class="section-title" id="ch4-2">4.2 String Searching and Autocomplete Systems</h2>

    <p class="academic-text"><strong>Autocomplete Magic</strong></p>
    <p class="academic-text">When you type "ca" and see suggestions like "cat", "car", "care", that's a trie finding all words with the prefix "ca"!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Autocomplete Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            Root --> D[D]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D1[D*]
            R --> E[E*]
            D --> O[O]
            O --> G[G*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#ffeb3b,stroke:#333,stroke-width:4px
            style A fill:#ffeb3b,stroke:#333,stroke-width:4px
            style T fill:#ff9800,stroke:#333,stroke-width:2px
            style R fill:#ff9800,stroke:#333,stroke-width:2px
            style D1 fill:#ff9800,stroke:#333,stroke-width:2px
            style E fill:#ff9800,stroke:#333,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style O fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style G fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">User types "CA" ‚Üí Highlighted path shows all words starting with "CA": CAT, CAR, CARD, CARE</p>
    </div>

    <p class="academic-text"><strong>How Autocomplete Works:</strong></p>
    <ol style="margin: 8px 0 16px 24px;">
        <li class="academic-text">User types a prefix (like "ca")</li>
        <li class="academic-text">Find the node representing that prefix in the trie</li>
        <li class="academic-text">Collect all complete words in the subtree below that node</li>
        <li class="academic-text">Return the suggestions to the user</li>
    </ol>

    <pre class="code-block">// Autocomplete system using trie
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class AutoComplete {
private:
    SimpleTrie* trie;
    
    // Helper function to collect all words from a node
    void collectWords(TrieNode* node, string currentWord, vector<string>& results) {
        if (node == nullptr) return;
        
        if (node->isEndOfWord) {
            results.push_back(currentWord);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i] != nullptr) {
                char nextChar = 'a' + i;
                collectWords(node->children[i], currentWord + nextChar, results);
            }
        }
    }
    
    // Find the node representing a prefix
    TrieNode* findPrefixNode(string prefix) {
        TrieNode* current = trie->root;
        
        for (char c : prefix) {
            int index = c - 'a';
            if (current->children[index] == nullptr) {
                return nullptr; // Prefix not found
            }
            current = current->children[index];
        }
        return current;
    }
    
public:
    AutoComplete() {
        trie = SimpleTrie::buildSampleTrie();
    }
    
    // Get autocomplete suggestions for a prefix
    vector<string> getSuggestions(string prefix) {
        vector<string> suggestions;
        
        TrieNode* prefixNode = findPrefixNode(prefix);
        if (prefixNode == nullptr) {
            return suggestions; // No words with this prefix
        }
        
        collectWords(prefixNode, prefix, suggestions);
        return suggestions;
    }
    
    // Add a new word to the dictionary
    void addWord(string word) {
        trie->insert(word);
    }
    
    // Demo function
    static void demo() {
        AutoComplete ac;
        
        cout << "Autocomplete Demo:" << endl;
        vector<string> prefixes = {"ca", "car", "d"};
        
        for (string prefix : prefixes) {
            cout << "Typing '" << prefix << "' suggests: ";
            vector<string> suggestions = ac.getSuggestions(prefix);
            
            for (string suggestion : suggestions) {
                cout << suggestion << " ";
            }
            cout << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch4-3">4.3 Applications: Spell Checkers, Dictionaries, IP Routing</h2>

    <p class="academic-text">Tries aren't just for autocomplete - they power many systems you use every day!</p>

    <p class="academic-text"><strong>1. Spell Checkers</strong></p>
    <p class="academic-text">When you misspell "recieve" as "recieve", spell checkers use tries to find similar correct words like "receive".</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Spell Checker Strategy:</strong><br><br>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dictionary trie:</strong> Contains all correct words</li>
            <li class="academic-text"><strong>Check word:</strong> Search in trie - if not found, it's misspelled</li>
            <li class="academic-text"><strong>Find suggestions:</strong> Try small changes (add/remove/change letters)</li>
            <li class="academic-text"><strong>Rank suggestions:</strong> Prefer words with similar prefixes</li>
        </ul>
    </div>

    <p class="academic-text"><strong>2. IP Address Routing</strong></p>
    <p class="academic-text">Internet routers use tries to quickly find where to send your data packets!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>IP Routing Trie Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> Zero[0]
            Root --> One[1]
            Zero --> Z0[0]
            Zero --> Z1[1]
            One --> O0[0]
            One --> O1[1]
            Z0 --> Route1[Route A*]
            Z1 --> Route2[Route B*]
            O0 --> Route3[Route C*]
            O1 --> Route4[Route D*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style Zero fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style One fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style Z0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Z1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Route1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route2 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route3 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route4 fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">IP 192.168.1.1 ‚Üí Binary 11000000... ‚Üí Follow path 1‚Üí1‚Üí0‚Üí0... to find route</p>
    </div>

    <pre class="code-block">// Simple spell checker using trie
#include <iostream>
#include <vector>
#include <string>
#include <set>
using namespace std;

class SpellChecker {
private:
    SimpleTrie* dictionary;
    
    // Generate words with one character changed
    set<string> generateEdits(string word) {
        set<string> edits;
        
        // Try changing each character
        for (int i = 0; i < word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                if (c != word[i]) {
                    string edited = word;
                    edited[i] = c;
                    edits.insert(edited);
                }
            }
        }
        
        // Try removing each character
        for (int i = 0; i < word.length(); i++) {
            string edited = word.substr(0, i) + word.substr(i + 1);
            edits.insert(edited);
        }
        
        // Try adding a character at each position
        for (int i = 0; i <= word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                string edited = word.substr(0, i) + c + word.substr(i);
                edits.insert(edited);
            }
        }
        
        return edits;
    }
    
public:
    SpellChecker() {
        dictionary = SimpleTrie::buildSampleTrie();
        // Add more common words
        dictionary->insert("hello");
        dictionary->insert("world");
        dictionary->insert("computer");
        dictionary->insert("science");
    }
    
    // Check if word is spelled correctly
    bool isCorrect(string word) {
        return dictionary->search(word);
    }
    
    // Get spelling suggestions
    vector<string> getSuggestions(string misspelledWord) {
        vector<string> suggestions;
        
        if (isCorrect(misspelledWord)) {
            return suggestions; // Word is already correct
        }
        
        set<string> possibleEdits = generateEdits(misspelledWord);
        
        for (string edit : possibleEdits) {
            if (dictionary->search(edit)) {
                suggestions.push_back(edit);
            }
        }
        
        return suggestions;
    }
    
    // Demo function
    static void demo() {
        SpellChecker checker;
        
        cout << "Spell Checker Demo:" << endl;
        vector<string> testWords = {"cat", "cta", "carr", "carefull"};
        
        for (string word : testWords) {
            if (checker.isCorrect(word)) {
                cout << "'" << word << "' is spelled correctly!" << endl;
            } else {
                cout << "'" << word << "' is misspelled. Suggestions: ";
                vector<string> suggestions = checker.getSuggestions(word);
                for (string suggestion : suggestions) {
                    cout << suggestion << " ";
                }
                cout << endl;
            }
        }
    }
};</pre>

    <p class="academic-text"><strong>Other Amazing Trie Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Search Engines:</strong> Google uses tries for query suggestions</li>
        <li class="academic-text"><strong>Code Editors:</strong> Autocomplete for variable names and functions</li>
        <li class="academic-text"><strong>Phone Contacts:</strong> T9 predictive text on old phones</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> DNA sequence matching</li>
        <li class="academic-text"><strong>Compression:</strong> Finding repeated patterns in text</li>
        <li class="academic-text"><strong>Games:</strong> Word games like Scrabble and Boggle</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üî§ Trie Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Search:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Prefix check:</strong> O(prefix length)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Shared prefixes save memory</li>
                    <li class="academic-text">Fast prefix operations</li>
                    <li class="academic-text">Natural autocomplete structure</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 4 Complete!</h3>
        <p class="academic-text">You now understand tries - specialized trees for text processing:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Trie structure</strong> - character nodes forming word paths</li>
            <li class="academic-text">‚úÖ <strong>Core operations</strong> - insert, search, prefix checking</li>
            <li class="academic-text">‚úÖ <strong>Autocomplete systems</strong> - how suggestions work</li>
            <li class="academic-text">‚úÖ <strong>Real applications</strong> - spell checkers, routing, search engines</li>
        </ul>
        
        <p class="academic-text">Tries show how specialized data structures solve specific problems elegantly. Next: <strong>Heaps</strong> - trees optimized for priority and ordering!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch5">
        
    <div class="chapter-number">Chapter 5</div>
    <h1 class="chapter-title">Heaps and Priority Structures</h1>
    
    <div class="definition-box">
        "Heaps are the secret sauce behind priority queues, efficient sorting, and many graph algorithms like Dijkstra's shortest path!"
    </div>

    <p class="academic-text">Imagine you're managing a hospital emergency room - you need to treat patients by priority, not arrival order. That's exactly what heaps do! They're special trees that always keep the most important item at the top, making them perfect for priority-based systems.</p>
    
    <p class="academic-text"><strong>Heaps bridge trees and algorithms:</strong> While we've learned about general trees and specialized tries, heaps are trees optimized for a specific purpose - maintaining priority order efficiently.</p>
    
    <p class="academic-text"><strong>Where heaps power your world:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Operating systems:</strong> Process scheduling based on priority</li>
        <li class="academic-text"><strong>Network traffic:</strong> Packet prioritization in routers</li>
        <li class="academic-text"><strong>Graph algorithms:</strong> Dijkstra's shortest path algorithm</li>
        <li class="academic-text"><strong>Event simulation:</strong> Processing events in time order</li>
        <li class="academic-text"><strong>Data compression:</strong> Huffman coding for file compression</li>
    </ul>

    <h2 class="section-title" id="ch5-1">5.1 Heap Properties: Min-Heap and Max-Heap</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üèÑ Heap Definition</h3>
        <p class="academic-text">A <strong>heap</strong> is a complete binary tree with the heap property: every parent node has a specific ordering relationship with its children.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Complete binary tree:</strong> All levels filled except possibly the last (filled left to right)</li>
            <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
            <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Two types of heaps:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Min-heap:</strong> Parent ‚â§ children (smallest at top)</li>
        <li class="academic-text"><strong>Max-heap:</strong> Parent ‚â• children (largest at top)</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Heap Example (Smallest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[3]
            A --> C[2]
            B --> D[7]
            B --> E[8]
            C --> F[5]
            C --> G[4]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ‚â§ Children: 1‚â§3,2 | 3‚â§7,8 | 2‚â§5,4</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A min-heap is a complete binary tree where every parent node has a value ‚â§ its children.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Max-Heap Example (Largest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[10] --> B[8]
            A --> C[9]
            B --> D[4]
            B --> E[7]
            C --> F[5]
            C --> G[6]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ‚â• Children: 10‚â•8,9 | 8‚â•4,7 | 9‚â•5,6</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A max-heap is a complete binary tree where every parent node has a value ‚â• its children.
        </div>
    </div>

    <p class="academic-text"><strong>Key Heap Properties:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Complete tree:</strong> All levels filled except possibly the last (filled left to right)</li>
        <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
        <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        <li class="academic-text"><strong>Array representation:</strong> Can be stored efficiently in an array</li>
    </ul>

    <pre class="code-block">// Simple heap implementation using array
#include <iostream>
#include <vector>
using namespace std;

class MinHeap {
private:
    vector<int> heap;
    
    // Get parent, left child, right child indices
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    // Swap two elements
    void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
public:
    // Check if heap is empty
    bool isEmpty() {
        return heap.empty();
    }
    
    // Get the minimum element (root)
    int getMin() {
        if (isEmpty()) return -1;
        return heap[0];
    }
    
    // Get heap size
    int size() {
        return heap.size();
    }
    
    // Print heap as array
    void printHeap() {
        cout << "Heap: ";
        for (int val : heap) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    // Build a sample min-heap
    static MinHeap* buildSampleHeap() {
        MinHeap* h = new MinHeap();
        vector<int> values = {3, 7, 1, 8, 2, 5, 4};
        
        for (int val : values) {
            h->insert(val);
        }
        return h;
    }
};</pre>

    <h2 class="section-title" id="ch5-2">5.2 Heap Operations: Insert, Extract, Heapify</h2>

    <p class="academic-text"><strong>Insert: Adding New Elements</strong></p>
    <p class="academic-text">To insert into a heap: add at the end, then "bubble up" until heap property is restored.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Insert Process (Adding 1 to Min-Heap):</strong><br><br>
        <div class="mermaid">
        graph TD
            subgraph "Step 1: Add at end"
                A1[3] --> B1[7]
                A1 --> C1[5]
                B1 --> D1[8]
                B1 --> E1[1]
                
                style E1 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 2: Bubble up"
                A2[3] --> B2[1]
                A2 --> C2[5]
                B2 --> D2[8]
                B2 --> E2[7]
                
                style B2 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 3: Final result"
                A3[1] --> B3[3]
                A3 --> C3[5]
                B3 --> D3[8]
                B3 --> E3[7]
                
                style A3 fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            end
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">1 bubbles up: 1<7 (swap) ‚Üí 1<3 (swap) ‚Üí Done!</p>
    </div>

    <p class="academic-text"><strong>Extract: Removing the Root</strong></p>
    <p class="academic-text">To extract from a heap: remove root, move last element to root, then "bubble down".</p>

    <pre class="code-block">// Heap operations implementation
class MinHeap {
    // ... previous code ...
    
    // Bubble up to maintain heap property after insert
    void bubbleUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    // Bubble down to maintain heap property after extract
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        // Find the smallest among parent and children
        if (left < heap.size() && heap[left] < heap[minIndex]) {
            minIndex = left;
        }
        if (right < heap.size() && heap[right] < heap[minIndex]) {
            minIndex = right;
        }
        
        // If parent is not the smallest, swap and continue
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Insert a new element
    void insert(int value) {
        heap.push_back(value);
        bubbleUp(heap.size() - 1);
    }
    
    // Extract the minimum element
    int extractMin() {
        if (isEmpty()) return -1;
        
        int min = heap[0];
        
        // Move last element to root and remove last
        heap[0] = heap[heap.size() - 1];
        heap.pop_back();
        
        // Restore heap property
        if (!isEmpty()) {
            bubbleDown(0);
        }
        
        return min;
    }
    
    // Build heap from array (heapify)
    void buildHeap(vector<int> array) {
        heap = array;
        
        // Start from last non-leaf node and bubble down
        for (int i = (heap.size() / 2) - 1; i >= 0; i--) {
            bubbleDown(i);
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-3">5.3 Priority Queues and Applications</h2>

    <p class="academic-text"><strong>Priority Queue: The Heap's Superpower</strong></p>
    <p class="academic-text">A priority queue lets you always get the most important item first. Heaps make this super efficient!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Hospital Emergency Room Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Critical: 1] --> B[Urgent: 3]
            A --> C[Urgent: 2]
            B --> D[Standard: 7]
            B --> E[Standard: 5]
            C --> F[Standard: 4]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style E fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style F fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Lower numbers = higher priority. Critical patient (1) treated first!</p>
    </div>

    <p class="academic-text"><strong>Real-World Priority Queue Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Operating Systems:</strong> Process scheduling by priority</li>
        <li class="academic-text"><strong>Network Routing:</strong> Packet prioritization</li>
        <li class="academic-text"><strong>Game AI:</strong> Action selection by importance</li>
        <li class="academic-text"><strong>Graph Algorithms:</strong> Dijkstra's shortest path</li>
        <li class="academic-text"><strong>Event Simulation:</strong> Process events by time</li>
    </ul>

    <pre class="code-block">// Priority Queue using heap
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Task with priority
struct Task {
    string description;
    int priority;
    
    Task(string desc, int prio) : description(desc), priority(prio) {}
};

class PriorityQueue {
private:
    vector<Task> tasks;
    
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    void swap(int i, int j) {
        Task temp = tasks[i];
        tasks[i] = tasks[j];
        tasks[j] = temp;
    }
    
    void bubbleUp(int index) {
        while (index > 0 && tasks[parent(index)].priority > tasks[index].priority) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < tasks.size() && tasks[left].priority < tasks[minIndex].priority) {
            minIndex = left;
        }
        if (right < tasks.size() && tasks[right].priority < tasks[minIndex].priority) {
            minIndex = right;
        }
        
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Add task with priority
    void addTask(string description, int priority) {
        tasks.push_back(Task(description, priority));
        bubbleUp(tasks.size() - 1);
    }
    
    // Get highest priority task
    Task getNextTask() {
        if (tasks.empty()) return Task("No tasks", -1);
        
        Task nextTask = tasks[0];
        
        tasks[0] = tasks[tasks.size() - 1];
        tasks.pop_back();
        
        if (!tasks.empty()) {
            bubbleDown(0);
        }
        
        return nextTask;
    }
    
    bool isEmpty() {
        return tasks.empty();
    }
    
    // Demo function
    static void demo() {
        PriorityQueue pq;
        
        pq.addTask("Fix critical bug", 1);
        pq.addTask("Write documentation", 5);
        pq.addTask("Review code", 3);
        pq.addTask("Deploy to production", 2);
        pq.addTask("Update tests", 4);
        
        cout << "Tasks in priority order:" << endl;
        while (!pq.isEmpty()) {
            Task task = pq.getNextTask();
            cout << "Priority " << task.priority << ": " << task.description << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-4">5.4 Heap Sort and Graph Algorithm Preparation</h2>

    <p class="academic-text"><strong>Heap Sort: Sorting with Heaps</strong></p>
    <p class="academic-text">Heap sort uses a heap to sort efficiently: build a max-heap, then repeatedly extract the maximum!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Heap Sort Process:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Unsorted Array] --> B[Build Max-Heap]
            B --> C[Extract Max]
            C --> D[Place at End]
            D --> E[Heapify Remaining]
            E --> F{More Elements?}
            F -->|Yes| C
            F -->|No| G[Sorted Array]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style G fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">O(n log n) time complexity - efficient and in-place!</p>
    </div>

    <p class="academic-text"><strong>Heaps in Graph Algorithms</strong></p>
    <p class="academic-text">Heaps are crucial for many graph algorithms you'll learn next:</p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> Find shortest paths using min-heap</li>
        <li class="academic-text"><strong>Prim's Algorithm:</strong> Find minimum spanning tree</li>
        <li class="academic-text"><strong>A* Search:</strong> Pathfinding with priority queue</li>
        <li class="academic-text"><strong>Huffman Coding:</strong> Data compression using heaps</li>
    </ul>

    <pre class="code-block">// Heap Sort implementation
#include <iostream>
#include <vector>
using namespace std;

class HeapSort {
private:
    static void heapify(vector<int>& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        // Find largest among root and children
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // If largest is not root, swap and continue heapifying
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
    
public:
    static void sort(vector<int>& arr) {
        int n = arr.size();
        
        // Step 1: Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Step 2: Extract elements one by one
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            swap(arr[0], arr[i]);
            
            // Heapify the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    // Demo function
    static void demo() {
        vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
        
        cout << "Original array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
        
        sort(arr);
        
        cout << "Sorted array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
    }
};

// Graph algorithm preparation - Dijkstra's preview
class GraphAlgorithmPrep {
public:
    // Simple structure for graph edges with weights
    struct Edge {
        int to;
        int weight;
        
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    // Distance-node pair for priority queue
    struct DistanceNode {
        int distance;
        int node;
        
        DistanceNode(int d, int n) : distance(d), node(n) {}
        
        // For min-heap comparison
        bool operator>(const DistanceNode& other) const {
            return distance > other.distance;
        }
    };
    
    static void dijkstraPreview() {
        cout << "Coming up in Part II:" << endl;
        cout << "- Dijkstra's algorithm will use min-heap for shortest paths" << endl;
        cout << "- Prim's algorithm will use min-heap for minimum spanning trees" << endl;
        cout << "- Priority queues will be essential for efficient graph traversal" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üèîÔ∏è Heap Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Extract:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Peek:</strong> O(1)</li>
                    <li class="academic-text"><strong>Build heap:</strong> O(n)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space & Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Space:</strong> O(n)</li>
                    <li class="academic-text"><strong>Array-based:</strong> Cache-friendly</li>
                    <li class="academic-text"><strong>In-place:</strong> No extra pointers</li>
                    <li class="academic-text"><strong>Stable:</strong> Predictable performance</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Part I Complete!</h3>
        <p class="academic-text">Congratulations! You've mastered the foundations of graph thinking:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Chapter 1:</strong> Basic graphs and representations</li>
            <li class="academic-text">‚úÖ <strong>Chapter 2:</strong> Graph properties and special types</li>
            <li class="academic-text">‚úÖ <strong>Chapter 3:</strong> Trees and hierarchical structures</li>
            <li class="academic-text">‚úÖ <strong>Chapter 4:</strong> Tries and string processing</li>
            <li class="academic-text">‚úÖ <strong>Chapter 5:</strong> Heaps and priority structures</li>
        </ul>
        
        <p class="academic-text"><strong>You're now ready for Part II: Core Algorithms!</strong> You have all the data structures needed to understand graph traversal, shortest paths, and spanning trees. The real adventure begins!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch6">
        
    <div class="chapter-number">Chapter 6</div>
    <h1 class="chapter-title">Traversal Algorithms</h1>
    
    <div class="definition-box">
        "Graph traversal is like exploring a maze - you need systematic strategies to visit every room without getting lost."
    </div>

    <p class="academic-text">Welcome to Part II! Now that you understand graphs, trees, tries, and heaps, it's time to learn the algorithms that make them useful. Graph traversal algorithms are the foundation of almost every graph algorithm you'll encounter.</p>
    
    <p class="academic-text"><strong>Why traversal matters:</strong> Before you can solve complex problems like finding shortest paths or detecting communities, you need to systematically visit and explore graph nodes. Traversal algorithms provide the systematic exploration strategies that power everything from web crawlers to social network analysis.</p>
    
    <p class="academic-text"><strong>The two fundamental approaches:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Breadth-First Search (BFS):</strong> Explore neighbors first, then their neighbors</li>
        <li class="academic-text"><strong>Depth-First Search (DFS):</strong> Go as deep as possible, then backtrack</li>
    </ul>

    <h2 class="section-title" id="ch6-1">6.1 Breadth-First Search (BFS)</h2>
    
    <p class="academic-text">BFS explores a graph level by level, like ripples spreading out from a stone dropped in water. It visits all nodes at distance 1, then all nodes at distance 2, and so on.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üåä BFS Strategy</h3>
        <p class="academic-text"><strong>Breadth-First Search</strong> systematically explores nodes in order of their distance from the starting node.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Level-by-level:</strong> Visit all nodes at distance k before any at distance k+1</li>
            <li class="academic-text"><strong>Queue-based:</strong> Uses a FIFO queue to maintain exploration order</li>
            <li class="academic-text"><strong>Shortest paths:</strong> Finds shortest unweighted paths naturally</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>BFS Exploration Example (Starting from A):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A:0] --- B[B:1]
            A --- C[C:1]
            B --- D[D:2]
            B --- E[E:2]
            C --- F[F:2]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show distance from A. BFS visits: A(0) ‚Üí B,C(1) ‚Üí D,E,F(2)</p>
    </div>

    <pre class="code-block">// BFS Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
using namespace std;

class BFS {
private:
    vector<vector<int>> graph;
    
public:
    BFS(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u); // undirected
    }
    
    // BFS traversal from start node
    vector<int> bfsTraversal(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            result.push_back(current);
            
            // Visit all unvisited neighbors
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        return result;
    }
    
    // Find shortest path using BFS
    vector<int> shortestPath(int start, int target) {
        vector<int> parent(graph.size(), -1);
        vector<bool> visited(graph.size(), false);
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            
            if (current == target) break;
            
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    q.push(neighbor);
                }
            }
        }
        
        // Reconstruct path
        vector<int> path;
        for (int node = target; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        return path;
    }
};</pre>

    <h2 class="section-title" id="ch6-2">6.2 Depth-First Search (DFS)</h2>
    
    <p class="academic-text">DFS explores a graph by going as deep as possible along each branch before backtracking. It's like exploring a maze by always taking the first unexplored path you see.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üï≥Ô∏è DFS Strategy</h3>
        <p class="academic-text"><strong>Depth-First Search</strong> explores as far as possible along each branch before backtracking.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Deep exploration:</strong> Follow paths to their end before trying alternatives</li>
            <li class="academic-text"><strong>Stack-based:</strong> Uses recursion or explicit stack (LIFO)</li>
            <li class="academic-text"><strong>Memory efficient:</strong> Only stores current path, not all discovered nodes</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DFS vs BFS Comparison:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[A] --- B[B]
            A --- C[C]
            B --- D[D]
            B --- E[E]
            C --- F[F]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">BFS order: A ‚Üí B,C ‚Üí D,E,F | DFS order: A ‚Üí B ‚Üí D ‚Üí E ‚Üí C ‚Üí F</p>
    </div>

    <pre class="code-block">// DFS Implementation
class DFS {
private:
    vector<vector<int>> graph;
    
    void dfsRecursive(int node, vector<bool>& visited, vector<int>& result) {
        visited[node] = true;
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                dfsRecursive(neighbor, visited, result);
            }
        }
    }
    
public:
    DFS(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Recursive DFS
    vector<int> dfsTraversal(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        dfsRecursive(start, visited, result);
        return result;
    }
    
    // Iterative DFS using stack
    vector<int> dfsIterative(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        stack<int> s;
        
        s.push(start);
        
        while (!s.empty()) {
            int current = s.top();
            s.pop();
            
            if (!visited[current]) {
                visited[current] = true;
                result.push_back(current);
                
                // Add neighbors to stack (reverse order for consistent traversal)
                for (auto it = graph[current].rbegin(); it != graph[current].rend(); ++it) {
                    if (!visited[*it]) {
                        s.push(*it);
                    }
                }
            }
        }
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch6-3">6.3 Cycle Detection Using DFS</h2>
    
    <p class="academic-text">One of DFS's superpowers is detecting cycles in graphs. This is crucial for many applications like detecting deadlocks, finding dependencies, and validating DAGs.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîÑ Cycle Detection</h3>
        <p class="academic-text">DFS can detect cycles by tracking the recursion stack and looking for back edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Back edge:</strong> An edge to an ancestor in the DFS tree</li>
            <li class="academic-text"><strong>Three colors:</strong> White (unvisited), Gray (processing), Black (finished)</li>
            <li class="academic-text"><strong>Cycle found:</strong> When we encounter a gray node</li>
        </ul>
    </div>

    <pre class="code-block">// Cycle Detection
class CycleDetector {
private:
    vector<vector<int>> graph;
    enum Color { WHITE, GRAY, BLACK };
    
    bool hasCycleDFS(int node, vector<Color>& colors) {
        colors[node] = GRAY;
        
        for (int neighbor : graph[node]) {
            if (colors[neighbor] == GRAY) {
                return true; // Back edge found - cycle detected!
            }
            if (colors[neighbor] == WHITE && hasCycleDFS(neighbor, colors)) {
                return true;
            }
        }
        
        colors[node] = BLACK;
        return false;
    }
    
public:
    CycleDetector(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v); // directed edge
    }
    
    bool hasCycle() {
        vector<Color> colors(graph.size(), WHITE);
        
        for (int i = 0; i < graph.size(); i++) {
            if (colors[i] == WHITE) {
                if (hasCycleDFS(i, colors)) {
                    return true;
                }
            }
        }
        return false;
    }
};</pre>

    <h2 class="section-title" id="ch6-4">6.4 Applications in Social Networks and Web Crawling</h2>
    
    <p class="academic-text">BFS and DFS power many real-world applications. Let's see how they work in systems you use every day.</p>
    
    <p class="academic-text"><strong>Social Network Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Friend suggestions:</strong> BFS finds mutual friends at distance 2</li>
        <li class="academic-text"><strong>Influence analysis:</strong> DFS explores how information spreads</li>
        <li class="academic-text"><strong>Community detection:</strong> Connected components using DFS</li>
    </ul>
    
    <p class="academic-text"><strong>Web Crawling Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> BFS for broad web exploration</li>
        <li class="academic-text"><strong>Site mapping:</strong> DFS for deep site structure analysis</li>
        <li class="academic-text"><strong>Link validation:</strong> Cycle detection for broken link loops</li>
    </ul>

    <pre class="code-block">// Social Network Friend Suggestions
class SocialNetwork {
private:
    vector<vector<int>> friendships;
    
public:
    SocialNetwork(int users) : friendships(users) {}
    
    void addFriendship(int user1, int user2) {
        friendships[user1].push_back(user2);
        friendships[user2].push_back(user1);
    }
    
    // Find mutual friends (distance 2 connections)
    vector<int> suggestFriends(int user) {
        set<int> suggestions;
        set<int> directFriends(friendships[user].begin(), friendships[user].end());
        
        // BFS to distance 2
        for (int friend_id : friendships[user]) {
            for (int friend_of_friend : friendships[friend_id]) {
                // Suggest if not already friend and not self
                if (friend_of_friend != user && 
                    directFriends.find(friend_of_friend) == directFriends.end()) {
                    suggestions.insert(friend_of_friend);
                }
            }
        }
        
        return vector<int>(suggestions.begin(), suggestions.end());
    }
    
    // Find connected components (friend groups)
    vector<vector<int>> findCommunities() {
        vector<vector<int>> communities;
        vector<bool> visited(friendships.size(), false);
        
        for (int i = 0; i < friendships.size(); i++) {
            if (!visited[i]) {
                vector<int> community;
                dfsComponent(i, visited, community);
                communities.push_back(community);
            }
        }
        return communities;
    }
    
private:
    void dfsComponent(int user, vector<bool>& visited, vector<int>& component) {
        visited[user] = true;
        component.push_back(user);
        
        for (int friend_id : friendships[user]) {
            if (!visited[friend_id]) {
                dfsComponent(friend_id, visited, component);
            }
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üöÄ Traversal Algorithm Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">BFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Shortest paths, level-order</li>
                    <li class="academic-text"><strong>Memory:</strong> Higher (stores all discovered)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Best for:</strong> Cycles, components, paths</li>
                    <li class="academic-text"><strong>Memory:</strong> Lower (only current path)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 6 Complete!</h3>
        <p class="academic-text">You've mastered the fundamental graph traversal algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>BFS</strong> - level-by-level exploration for shortest paths</li>
            <li class="academic-text">‚úÖ <strong>DFS</strong> - deep exploration for cycles and components</li>
            <li class="academic-text">‚úÖ <strong>Cycle detection</strong> - using DFS with three-color approach</li>
            <li class="academic-text">‚úÖ <strong>Real applications</strong> - social networks and web crawling</li>
        </ul>
        
        <p class="academic-text">These traversal algorithms are the foundation for almost every graph algorithm you'll learn next. Understanding BFS and DFS deeply will make shortest path algorithms, minimum spanning trees, and network flow much easier to grasp!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch7">
        
    <div class="chapter-number">Chapter 7</div>
    <h1 class="chapter-title">Shortest Path Algorithms</h1>
    
    <div class="definition-box">
        "Finding the shortest path is one of the most fundamental problems in computer science - from GPS navigation to network routing to game AI."
    </div>

    <p class="academic-text">Every time you use Google Maps, play a video game with smart AI, or send data across the internet, you're benefiting from shortest path algorithms. These algorithms solve one of the most practical problems in graph theory: finding the optimal route between two points.</p>
    
    <p class="academic-text"><strong>Why shortest paths matter:</strong> Beyond navigation, shortest path algorithms power network routing protocols, social network analysis, resource optimization, and countless other applications where finding the "best" connection is crucial.</p>
    
    <p class="academic-text"><strong>The four essential algorithms:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> Single-source shortest paths (no negative weights)</li>
        <li class="academic-text"><strong>Bellman-Ford Algorithm:</strong> Handles negative weights and detects negative cycles</li>
        <li class="academic-text"><strong>A* Algorithm:</strong> Dijkstra + heuristics for faster pathfinding</li>
        <li class="academic-text"><strong>Floyd-Warshall:</strong> All-pairs shortest paths for complete analysis</li>
    </ul>

    <h2 class="section-title" id="ch7-1">7.1 Dijkstra's Algorithm</h2>
    
    <p class="academic-text">Dijkstra's algorithm is the gold standard for finding shortest paths in weighted graphs with non-negative edge weights. It's the algorithm behind GPS navigation systems and network routing protocols.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üõ£Ô∏è Dijkstra's Strategy</h3>
        <p class="academic-text"><strong>Dijkstra's Algorithm</strong> finds shortest paths by always exploring the closest unvisited node first.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Greedy approach:</strong> Always pick the node with minimum distance</li>
            <li class="academic-text"><strong>Priority queue:</strong> Uses min-heap to efficiently get next closest node</li>
            <li class="academic-text"><strong>Relaxation:</strong> Updates distances when shorter paths are found</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Shortest path contains shortest subpaths</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Dijkstra's Algorithm Example (Finding shortest path from A):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A:0] -->|4| B[B:4]
            A -->|2| C[C:2]
            B -->|3| D[D:7]
            C -->|1| D[D:3]
            C -->|5| E[E:7]
            D -->|2| E[E:5]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#ffeb3b,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show shortest distances from A. Path A‚ÜíC‚ÜíD gives distance 3, better than A‚ÜíB‚ÜíD (distance 7)</p>
    </div>

    <pre class="code-block">// Dijkstra's Algorithm Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <limits>
using namespace std;

class DijkstraGraph {
private:
    struct Edge {
        int to;
        int weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    
public:
    DijkstraGraph(int n) : graph(n) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Dijkstra's shortest path algorithm
    pair<vector<int>, vector<int>> dijkstra(int start) {
        int n = graph.size();
        vector<int> dist(n, INT_MAX);
        vector<int> parent(n, -1);
        
        // Priority queue: (distance, node)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        dist[start] = 0;
        pq.push({0, start});
        
        while (!pq.empty()) {
            int currentDist = pq.top().first;
            int currentNode = pq.top().second;
            pq.pop();
            
            // Skip if we've already found a better path
            if (currentDist > dist[currentNode]) continue;
            
            // Explore all neighbors
            for (const Edge& edge : graph[currentNode]) {
                int newDist = dist[currentNode] + edge.weight;
                
                // Relaxation: update if we found a shorter path
                if (newDist < dist[edge.to]) {
                    dist[edge.to] = newDist;
                    parent[edge.to] = currentNode;
                    pq.push({newDist, edge.to});
                }
            }
        }
        
        return {dist, parent};
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int start, int end, const vector<int>& parent) {
        vector<int> path;
        for (int node = end; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        
        // Check if path exists
        if (path[0] != start) return {};
        return path;
    }
    
    // Demo function
    static void demo() {
        DijkstraGraph g(5);
        g.addEdge(0, 1, 4);  // A -> B: 4
        g.addEdge(0, 2, 2);  // A -> C: 2
        g.addEdge(1, 3, 3);  // B -> D: 3
        g.addEdge(2, 3, 1);  // C -> D: 1
        g.addEdge(2, 4, 5);  // C -> E: 5
        g.addEdge(3, 4, 2);  // D -> E: 2
        
        auto [distances, parents] = g.dijkstra(0);
        
        cout << "Shortest distances from A:" << endl;
        vector<char> labels = {'A', 'B', 'C', 'D', 'E'};
        for (int i = 0; i < 5; i++) {
            cout << "To " << labels[i] << ": " << distances[i] << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-2">7.2 Bellman-Ford Algorithm</h2>
    
    <p class="academic-text">While Dijkstra's algorithm is fast, it can't handle negative edge weights. Bellman-Ford algorithm is slower but more versatile - it can detect negative cycles and handle negative weights.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">‚öñÔ∏è Bellman-Ford Strategy</h3>
        <p class="academic-text"><strong>Bellman-Ford Algorithm</strong> finds shortest paths by relaxing all edges repeatedly.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Edge relaxation:</strong> Try to improve distances using each edge</li>
            <li class="academic-text"><strong>V-1 iterations:</strong> Guarantees finding shortest paths in V-1 steps</li>
            <li class="academic-text"><strong>Negative cycle detection:</strong> Extra iteration detects negative cycles</li>
            <li class="academic-text"><strong>Handles negative weights:</strong> Works where Dijkstra fails</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bellman-Ford vs Dijkstra Comparison:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] -->|2| B[B]
            A -->|-1| C[C]
            C -->|3| B
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffeb3b,stroke:#333,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Negative edge A‚ÜíC: -1. Dijkstra fails, but Bellman-Ford finds A‚ÜíC‚ÜíB = 2 < A‚ÜíB = 2</p>
    </div>

    <pre class="code-block">// Bellman-Ford Algorithm Implementation
class BellmanFordGraph {
private:
    struct Edge {
        int from, to, weight;
        Edge(int f, int t, int w) : from(f), to(t), weight(w) {}
    };
    
    vector<Edge> edges;
    int numVertices;
    
public:
    BellmanFordGraph(int n) : numVertices(n) {}
    
    void addEdge(int from, int to, int weight) {
        edges.push_back(Edge(from, to, weight));
    }
    
    // Bellman-Ford shortest path algorithm
    pair<vector<int>, bool> bellmanFord(int start) {
        vector<int> dist(numVertices, INT_MAX);
        dist[start] = 0;
        
        // Relax all edges V-1 times
        for (int i = 0; i < numVertices - 1; i++) {
            for (const Edge& edge : edges) {
                if (dist[edge.from] != INT_MAX && 
                    dist[edge.from] + edge.weight < dist[edge.to]) {
                    dist[edge.to] = dist[edge.from] + edge.weight;
                }
            }
        }
        
        // Check for negative cycles
        bool hasNegativeCycle = false;
        for (const Edge& edge : edges) {
            if (dist[edge.from] != INT_MAX && 
                dist[edge.from] + edge.weight < dist[edge.to]) {
                hasNegativeCycle = true;
                break;
            }
        }
        
        return {dist, hasNegativeCycle};
    }
    
    // Demo function
    static void demo() {
        BellmanFordGraph g(4);
        g.addEdge(0, 1, 4);   // A -> B: 4
        g.addEdge(0, 2, -2);  // A -> C: -2 (negative!)
        g.addEdge(2, 1, 3);   // C -> B: 3
        g.addEdge(1, 3, 2);   // B -> D: 2
        g.addEdge(2, 3, 4);   // C -> D: 4
        
        auto [distances, hasNegCycle] = g.bellmanFord(0);
        
        if (hasNegCycle) {
            cout << "Negative cycle detected!" << endl;
        } else {
            cout << "Shortest distances from A (with negative edges):" << endl;
            vector<char> labels = {'A', 'B', 'C', 'D'};
            for (int i = 0; i < 4; i++) {
                cout << "To " << labels[i] << ": " << distances[i] << endl;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-3">7.3 A* Algorithm with Heuristics</h2>
    
    <p class="academic-text">A* (A-star) is Dijkstra's algorithm enhanced with heuristics. It's the go-to algorithm for pathfinding in games, robotics, and any scenario where you know the target location.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üéØ A* Strategy</h3>
        <p class="academic-text"><strong>A* Algorithm</strong> combines actual distance with estimated distance to goal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>f(n) = g(n) + h(n):</strong> Total cost = actual cost + heuristic estimate</li>
            <li class="academic-text"><strong>Admissible heuristic:</strong> Never overestimates the actual cost</li>
            <li class="academic-text"><strong>Guided search:</strong> Explores toward the goal more efficiently</li>
            <li class="academic-text"><strong>Optimal:</strong> Finds shortest path if heuristic is admissible</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>A* Pathfinding Example (Grid with obstacles):</strong><br><br>
        <div class="mermaid">
        graph TD
            S[Start] --> A[A]
            S --> B[B]
            A --> C[C]
            B --> D[D]
            C --> G[Goal]
            D --> G
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style G fill:#ffeb3b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A* uses heuristic (like Manhattan distance) to guide search toward goal</p>
    </div>

    <pre class="code-block">// A* Algorithm Implementation
#include <cmath>

class AStarGraph {
private:
    struct Node {
        int id;
        double x, y;  // Coordinates for heuristic
        Node(int i, double px, double py) : id(i), x(px), y(py) {}
    };
    
    struct AStarNode {
        int id;
        double g, h, f;  // g: actual cost, h: heuristic, f: total
        int parent;
        
        AStarNode(int i, double gc, double hc, int p) 
            : id(i), g(gc), h(hc), f(gc + hc), parent(p) {}
        
        bool operator>(const AStarNode& other) const {
            return f > other.f;
        }
    };
    
    vector<Node> nodes;
    vector<vector<pair<int, double>>> graph;
    
    // Manhattan distance heuristic
    double heuristic(int from, int to) {
        return abs(nodes[from].x - nodes[to].x) + abs(nodes[from].y - nodes[to].y);
    }
    
public:
    AStarGraph(int n) : graph(n) {}
    
    void addNode(int id, double x, double y) {
        nodes.push_back(Node(id, x, y));
    }
    
    void addEdge(int from, int to, double weight) {
        graph[from].push_back({to, weight});
    }
    
    // A* pathfinding algorithm
    vector<int> aStar(int start, int goal) {
        priority_queue<AStarNode, vector<AStarNode>, greater<AStarNode>> openSet;
        unordered_set<int> closedSet;
        unordered_map<int, double> gScore;
        unordered_map<int, int> parent;
        
        gScore[start] = 0;
        openSet.push(AStarNode(start, 0, heuristic(start, goal), -1));
        
        while (!openSet.empty()) {
            AStarNode current = openSet.top();
            openSet.pop();
            
            if (current.id == goal) {
                // Reconstruct path
                vector<int> path;
                for (int node = goal; node != -1; node = parent[node]) {
                    path.push_back(node);
                }
                reverse(path.begin(), path.end());
                return path;
            }
            
            closedSet.insert(current.id);
            
            for (auto& [neighbor, weight] : graph[current.id]) {
                if (closedSet.count(neighbor)) continue;
                
                double tentativeG = gScore[current.id] + weight;
                
                if (gScore.find(neighbor) == gScore.end() || tentativeG < gScore[neighbor]) {
                    gScore[neighbor] = tentativeG;
                    parent[neighbor] = current.id;
                    openSet.push(AStarNode(neighbor, tentativeG, heuristic(neighbor, goal), current.id));
                }
            }
        }
        
        return {}; // No path found
    }
    
    // Demo function for grid pathfinding
    static void demo() {
        AStarGraph g(6);
        
        // Add nodes with coordinates
        g.addNode(0, 0, 0);  // Start
        g.addNode(1, 1, 0);
        g.addNode(2, 0, 1);
        g.addNode(3, 1, 1);
        g.addNode(4, 2, 1);
        g.addNode(5, 2, 2);  // Goal
        
        // Add edges (grid connections)
        g.addEdge(0, 1, 1);  // Horizontal/vertical moves cost 1
        g.addEdge(0, 2, 1);
        g.addEdge(1, 3, 1);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 4, 1);
        g.addEdge(4, 5, 1);
        
        vector<int> path = g.aStar(0, 5);
        
        cout << "A* path from start to goal: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <h2 class="section-title" id="ch7-4">7.4 Floyd-Warshall All-Pairs Shortest Path</h2>
    
    <p class="academic-text">Sometimes you need shortest paths between ALL pairs of vertices, not just from one source. Floyd-Warshall algorithm efficiently computes the shortest path matrix for the entire graph.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üåê Floyd-Warshall Strategy</h3>
        <p class="academic-text"><strong>Floyd-Warshall Algorithm</strong> finds shortest paths between all pairs of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dynamic programming:</strong> Builds solution by considering intermediate vertices</li>
            <li class="academic-text"><strong>All-pairs:</strong> Computes shortest paths between every pair of vertices</li>
            <li class="academic-text"><strong>Handles negatives:</strong> Works with negative weights (but not negative cycles)</li>
            <li class="academic-text"><strong>Simple implementation:</strong> Three nested loops, easy to understand</li>
        </ul>
    </div>

    <pre class="code-block">// Floyd-Warshall Algorithm Implementation
class FloydWarshallGraph {
private:
    vector<vector<int>> dist;
    vector<vector<int>> next;
    int n;
    
public:
    FloydWarshallGraph(int vertices) : n(vertices) {
        dist.assign(n, vector<int>(n, INT_MAX));
        next.assign(n, vector<int>(n, -1));
        
        // Initialize diagonal to 0
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
    }
    
    void addEdge(int from, int to, int weight) {
        dist[from][to] = weight;
        next[from][to] = to;
    }
    
    // Floyd-Warshall all-pairs shortest path
    void floydWarshall() {
        // Try each vertex as intermediate
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                            next[i][j] = next[i][k];
                        }
                    }
                }
            }
        }
    }
    
    // Get shortest distance between two vertices
    int getDistance(int from, int to) {
        return dist[from][to];
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int from, int to) {
        if (next[from][to] == -1) return {};
        
        vector<int> path;
        path.push_back(from);
        
        while (from != to) {
            from = next[from][to];
            path.push_back(from);
        }
        
        return path;
    }
    
    // Print distance matrix
    void printDistanceMatrix() {
        cout << "All-pairs shortest distances:" << endl;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == INT_MAX) {
                    cout << "‚àû ";
                } else {
                    cout << dist[i][j] << " ";
                }
            }
            cout << endl;
        }
    }
    
    // Demo function
    static void demo() {
        FloydWarshallGraph g(4);
        
        g.addEdge(0, 1, 3);
        g.addEdge(0, 3, 7);
        g.addEdge(1, 0, 8);
        g.addEdge(1, 2, 2);
        g.addEdge(2, 0, 5);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 0, 2);
        
        g.floydWarshall();
        g.printDistanceMatrix();
        
        // Example path
        vector<int> path = g.getPath(1, 3);
        cout << "Path from 1 to 3: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">‚ö° Shortest Path Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Single-Source Algorithms</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Dijkstra:</strong> O((V+E) log V), no negative weights</li>
                    <li class="academic-text"><strong>Bellman-Ford:</strong> O(VE), handles negative weights</li>
                    <li class="academic-text"><strong>A*:</strong> O(b^d), guided by heuristics</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">All-Pairs Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Floyd-Warshall:</strong> O(V¬≥), all pairs</li>
                    <li class="academic-text"><strong>Dense graphs:</strong> More efficient than V √ó Dijkstra</li>
                    <li class="academic-text"><strong>Simple code:</strong> Easy to implement and understand</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">Algorithm Selection Guide</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>GPS Navigation:</strong> A* with Euclidean distance heuristic</li>
                <li class="academic-text"><strong>Network Routing:</strong> Dijkstra for positive weights, Bellman-Ford for policy routing</li>
                <li class="academic-text"><strong>Game AI:</strong> A* for pathfinding with obstacles</li>
                <li class="academic-text"><strong>Social Networks:</strong> Floyd-Warshall for analyzing all relationships</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 7 Complete!</h3>
        <p class="academic-text">You've mastered the essential shortest path algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Dijkstra's Algorithm</strong> - the gold standard for non-negative weights</li>
            <li class="academic-text">‚úÖ <strong>Bellman-Ford Algorithm</strong> - handles negative weights and cycle detection</li>
            <li class="academic-text">‚úÖ <strong>A* Algorithm</strong> - heuristic-guided pathfinding for games and robotics</li>
            <li class="academic-text">‚úÖ <strong>Floyd-Warshall Algorithm</strong> - all-pairs shortest paths analysis</li>
        </ul>
        
        <p class="academic-text">These algorithms power everything from GPS navigation to internet routing to game AI. You now understand the core techniques that make modern connected systems possible. Next up: spanning tree algorithms that find the most efficient ways to connect networks!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch8">
        
    <div class="chapter-number">Chapter 8</div>
    <h1 class="chapter-title">Minimum Spanning Trees</h1>
    
    <div class="definition-box">
        "Minimum spanning trees find the cheapest way to connect all nodes in a network - essential for designing efficient infrastructure."
    </div>

    <p class="academic-text">Imagine you're designing a network to connect all cities in a country with the minimum total cost of cables. Or you're planning the most efficient road system to connect all neighborhoods. These are minimum spanning tree problems!</p>
    
    <p class="academic-text"><strong>What is a spanning tree?</strong> A spanning tree of a graph is a subgraph that includes all vertices and is a tree (connected with no cycles). A minimum spanning tree (MST) is the spanning tree with the smallest total edge weight.</p>
    
    <p class="academic-text"><strong>Real-world MST applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Network design:</strong> Connecting computers, cities, or power grids efficiently</li>
        <li class="academic-text"><strong>Circuit design:</strong> Minimizing wire length in electronic circuits</li>
        <li class="academic-text"><strong>Clustering:</strong> Finding natural groupings in data analysis</li>
        <li class="academic-text"><strong>Approximation algorithms:</strong> Starting point for solving harder optimization problems</li>
    </ul>

    <h2 class="section-title" id="ch8-1">8.1 Kruskal's Algorithm</h2>
    
    <p class="academic-text">Kruskal's algorithm builds the MST by considering edges in order of increasing weight, adding each edge if it doesn't create a cycle. It's a greedy algorithm that always makes the locally optimal choice.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîó Kruskal's Strategy</h3>
        <p class="academic-text"><strong>Kruskal's Algorithm</strong> builds MST by adding edges in order of increasing weight.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Sort edges:</strong> Order all edges by weight from smallest to largest</li>
            <li class="academic-text"><strong>Greedy selection:</strong> Add the smallest edge that doesn't create a cycle</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use Union-Find to efficiently detect cycles</li>
            <li class="academic-text"><strong>Stop condition:</strong> Stop when we have V-1 edges (tree property)</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Kruskal's Algorithm Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] ---|1| B[B]
            A ---|4| C[C]
            B ---|2| C[C]
            B ---|5| D[D]
            C ---|3| D[D]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Edge selection order: AB(1) ‚Üí BC(2) ‚Üí CD(3). Skip AC(4) and BD(5) as they create cycles.</p>
    </div>

    <pre class="code-block">// Kruskal's Algorithm Implementation
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class KruskalMST {
private:
    struct Edge {
        int u, v, weight;
        Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
        
        bool operator<(const Edge& other) const {
            return weight < other.weight;
        }
    };
    
    vector<Edge> edges;
    int numVertices;
    
public:
    KruskalMST(int n) : numVertices(n) {}
    
    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }
    
    // Find MST using Kruskal's algorithm
    vector<Edge> findMST() {
        vector<Edge> mst;
        
        // Sort edges by weight
        sort(edges.begin(), edges.end());
        
        // Initialize Union-Find
        UnionFind uf(numVertices);
        
        for (const Edge& edge : edges) {
            // If adding this edge doesn't create a cycle
            if (uf.find(edge.u) != uf.find(edge.v)) {
                mst.push_back(edge);
                uf.unite(edge.u, edge.v);
                
                // MST complete when we have V-1 edges
                if (mst.size() == numVertices - 1) break;
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<Edge> mst = findMST();
        int totalWeight = 0;
        for (const Edge& edge : mst) {
            totalWeight += edge.weight;
        }
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        KruskalMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<Edge> mst = graph.findMST();
        
        cout << "Kruskal's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (const Edge& edge : mst) {
            cout << labels[edge.u] << "-" << labels[edge.v] 
                 << " (weight: " << edge.weight << ")" << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-2">8.2 Prim's Algorithm</h2>
    
    <p class="academic-text">Prim's algorithm builds the MST by starting from a vertex and growing the tree one edge at a time, always adding the minimum weight edge that connects the tree to a new vertex.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üå± Prim's Strategy</h3>
        <p class="academic-text"><strong>Prim's Algorithm</strong> grows MST from a starting vertex by adding minimum edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Start with vertex:</strong> Begin with any vertex in the MST</li>
            <li class="academic-text"><strong>Grow incrementally:</strong> Add minimum edge connecting MST to new vertex</li>
            <li class="academic-text"><strong>Priority queue:</strong> Use min-heap to efficiently find minimum edge</li>
            <li class="academic-text"><strong>Cut property:</strong> Minimum edge crossing cut is safe to add</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Prim's vs Kruskal's Comparison:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Start: Pick any vertex] --> B[Prim's: Grow tree from vertex]
            A --> C[Kruskal's: Consider all edges globally]
            B --> D[Uses: Priority Queue]
            C --> E[Uses: Union-Find]
            D --> F[Good for: Dense graphs]
            E --> G[Good for: Sparse graphs]
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Both algorithms find the same MST but use different strategies</p>
    </div>

    <pre class="code-block">// Prim's Algorithm Implementation
#include <queue>
#include <climits>

class PrimMST {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    PrimMST(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int u, int v, int weight) {
        graph[u].push_back(Edge(v, weight));
        graph[v].push_back(Edge(u, weight)); // undirected
    }
    
    // Find MST using Prim's algorithm
    vector<pair<int, int>> findMST() {
        vector<pair<int, int>> mst;
        vector<bool> inMST(numVertices, false);
        vector<int> key(numVertices, INT_MAX);
        vector<int> parent(numVertices, -1);
        
        // Priority queue: (weight, vertex)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        // Start from vertex 0
        key[0] = 0;
        pq.push({0, 0});
        
        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();
            
            if (inMST[u]) continue;
            
            inMST[u] = true;
            
            // Add edge to MST (except for starting vertex)
            if (parent[u] != -1) {
                mst.push_back({parent[u], u});
            }
            
            // Update keys of adjacent vertices
            for (const Edge& edge : graph[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (!inMST[v] && weight < key[v]) {
                    key[v] = weight;
                    parent[v] = u;
                    pq.push({weight, v});
                }
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<pair<int, int>> mst = findMST();
        int totalWeight = 0;
        
        for (auto [u, v] : mst) {
            // Find edge weight between u and v
            for (const Edge& edge : graph[u]) {
                if (edge.to == v) {
                    totalWeight += edge.weight;
                    break;
                }
            }
        }
        
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        PrimMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<pair<int, int>> mst = graph.findMST();
        
        cout << "Prim's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (auto [u, v] : mst) {
            cout << labels[u] << "-" << labels[v] << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-3">8.3 Union-Find Data Structure</h2>
    
    <p class="academic-text">Union-Find (also called Disjoint Set Union) is a crucial data structure for Kruskal's algorithm. It efficiently tracks which vertices belong to which connected components and can quickly determine if adding an edge would create a cycle.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîó Union-Find Operations</h3>
        <p class="academic-text"><strong>Union-Find</strong> maintains disjoint sets with two key operations:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Find(x):</strong> Determine which set contains element x</li>
            <li class="academic-text"><strong>Union(x, y):</strong> Merge the sets containing x and y</li>
            <li class="academic-text"><strong>Path compression:</strong> Optimize find by flattening tree structure</li>
            <li class="academic-text"><strong>Union by rank:</strong> Optimize union by balancing tree height</li>
        </ul>
    </div>

    <pre class="code-block">// Union-Find Data Structure Implementation
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        // Initially, each element is its own parent
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // Find with path compression
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    // Union by rank
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            // Union by rank: attach smaller tree to larger tree
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    
    // Check if two elements are in the same set
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // Count number of disjoint sets
    int countSets() {
        unordered_set<int> roots;
        for (int i = 0; i < parent.size(); i++) {
            roots.insert(find(i));
        }
        return roots.size();
    }
    
    // Demo function
    static void demo() {
        UnionFind uf(5);
        
        cout << "Initial sets: " << uf.countSets() << endl;
        
        uf.unite(0, 1);  // Connect 0 and 1
        uf.unite(2, 3);  // Connect 2 and 3
        
        cout << "After unions: " << uf.countSets() << endl;
        cout << "0 and 1 connected: " << uf.connected(0, 1) << endl;
        cout << "0 and 2 connected: " << uf.connected(0, 2) << endl;
        
        uf.unite(1, 2);  // Connect the two components
        cout << "Final sets: " << uf.countSets() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-4">8.4 Applications in Network Design</h2>
    
    <p class="academic-text">MST algorithms have countless real-world applications in designing efficient networks and infrastructure. Let's explore some practical examples.</p>
    
    <p class="academic-text"><strong>Network Infrastructure Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Computer networks:</strong> Connecting offices with minimum cable cost</li>
        <li class="academic-text"><strong>Power grids:</strong> Connecting power stations to minimize transmission costs</li>
        <li class="academic-text"><strong>Transportation:</strong> Building road networks with minimum construction cost</li>
        <li class="academic-text"><strong>Telecommunications:</strong> Laying fiber optic cables efficiently</li>
    </ul>
    
    <p class="academic-text"><strong>Data Analysis Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Clustering:</strong> Finding natural groupings in data</li>
        <li class="academic-text"><strong>Image segmentation:</strong> Identifying regions in images</li>
        <li class="academic-text"><strong>Social network analysis:</strong> Finding communities</li>
        <li class="academic-text"><strong>Phylogenetic trees:</strong> Evolutionary relationships</li>
    </ul>

    <pre class="code-block">// Network Design Application
class NetworkDesigner {
private:
    struct Connection {
        int city1, city2;
        double cost;
        string type; // "fiber", "cable", "wireless"
        
        Connection(int c1, int c2, double c, string t) 
            : city1(c1), city2(c2), cost(c), type(t) {}
    };
    
    vector<string> cityNames;
    vector<Connection> possibleConnections;
    
public:
    void addCity(const string& name) {
        cityNames.push_back(name);
    }
    
    void addPossibleConnection(int city1, int city2, double cost, const string& type) {
        possibleConnections.push_back(Connection(city1, city2, cost, type));
    }
    
    // Design minimum cost network using MST
    vector<Connection> designNetwork() {
        vector<Connection> network;
        
        // Sort connections by cost
        sort(possibleConnections.begin(), possibleConnections.end(),
             [](const Connection& a, const Connection& b) {
                 return a.cost < b.cost;
             });
        
        UnionFind uf(cityNames.size());
        
        for (const Connection& conn : possibleConnections) {
            if (uf.find(conn.city1) != uf.find(conn.city2)) {
                network.push_back(conn);
                uf.unite(conn.city1, conn.city2);
                
                if (network.size() == cityNames.size() - 1) break;
            }
        }
        
        return network;
    }
    
    // Calculate total network cost
    double getTotalCost() {
        vector<Connection> network = designNetwork();
        double totalCost = 0;
        for (const Connection& conn : network) {
            totalCost += conn.cost;
        }
        return totalCost;
    }
    
    // Demo function
    static void demo() {
        NetworkDesigner designer;
        
        // Add cities
        designer.addCity("New York");
        designer.addCity("Boston");
        designer.addCity("Philadelphia");
        designer.addCity("Washington DC");
        
        // Add possible connections with costs (in millions)
        designer.addPossibleConnection(0, 1, 15.5, "fiber");    // NY-Boston
        designer.addPossibleConnection(0, 2, 8.2, "fiber");     // NY-Philadelphia
        designer.addPossibleConnection(0, 3, 12.1, "cable");    // NY-Washington
        designer.addPossibleConnection(1, 2, 18.7, "wireless"); // Boston-Philadelphia
        designer.addPossibleConnection(1, 3, 25.3, "cable");    // Boston-Washington
        designer.addPossibleConnection(2, 3, 6.8, "fiber");     // Philadelphia-Washington
        
        vector<Connection> network = designer.designNetwork();
        
        cout << "Optimal network design:" << endl;
        for (const Connection& conn : network) {
            cout << designer.cityNames[conn.city1] << " - " 
                 << designer.cityNames[conn.city2] 
                 << " (" << conn.type << ", $" << conn.cost << "M)" << endl;
        }
        cout << "Total cost: $" << designer.getTotalCost() << "M" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üå≥ MST Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kruskal's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for Union-Find</li>
                    <li class="academic-text"><strong>Best for:</strong> Sparse graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Global edge selection</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Prim's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log V)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for priority queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Dense graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Incremental tree growth</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">When to Use Which Algorithm</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>Kruskal's:</strong> When edges are given as a list, sparse graphs, or when Union-Find is already available</li>
                <li class="academic-text"><strong>Prim's:</strong> When graph is represented as adjacency list/matrix, dense graphs, or when starting from specific vertex</li>
                <li class="academic-text"><strong>Both produce identical MST weight</strong> - choice depends on implementation convenience and graph density</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 8 Complete!</h3>
        <p class="academic-text">You've mastered minimum spanning tree algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Kruskal's Algorithm</strong> - global edge selection with Union-Find</li>
            <li class="academic-text">‚úÖ <strong>Prim's Algorithm</strong> - incremental tree growth with priority queue</li>
            <li class="academic-text">‚úÖ <strong>Union-Find Data Structure</strong> - efficient cycle detection and set operations</li>
            <li class="academic-text">‚úÖ <strong>Network Design Applications</strong> - real-world infrastructure optimization</li>
        </ul>
        
        <p class="academic-text">MST algorithms are fundamental tools for optimization problems involving connectivity. They're used everywhere from computer networks to data clustering to circuit design. Next: topological sorting for handling dependencies and scheduling!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch9">
        
    <div class="chapter-number">Chapter 9</div>
    <h1 class="chapter-title">Topological Sorting & Dynamic Programming on DAGs</h1>
    
    <div class="definition-box">
        "Topological sorting solves dependency problems - from course prerequisites to build systems to project scheduling."
    </div>

    <p class="academic-text">Ever wonder how your computer knows which files to compile first? Or how project managers schedule tasks with dependencies? The answer is topological sorting! It's the algorithm that puts things in the right order when some things must come before others.</p>
    
    <p class="academic-text"><strong>What is topological sorting?</strong> It's a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u,v), vertex u comes before v in the ordering.</p>
    
    <p class="academic-text"><strong>Real-world applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Course scheduling:</strong> Taking prerequisites before advanced courses</li>
        <li class="academic-text"><strong>Build systems:</strong> Compiling dependencies before main programs</li>
        <li class="academic-text"><strong>Project management:</strong> Scheduling tasks with dependencies</li>
        <li class="academic-text"><strong>Package managers:</strong> Installing dependencies in correct order</li>
    </ul>

    <h2 class="section-title" id="ch9-1">9.1 Topological Ordering and Kahn's Algorithm</h2>
    
    <p class="academic-text">Kahn's algorithm is an intuitive approach to topological sorting. It repeatedly removes vertices with no incoming edges, which represents tasks that have no remaining dependencies.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üìã Kahn's Algorithm Strategy</h3>
        <p class="academic-text"><strong>Kahn's Algorithm</strong> builds topological order by removing vertices with no dependencies.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Track in-degrees:</strong> Count incoming edges for each vertex</li>
            <li class="academic-text"><strong>Start with zero in-degree:</strong> Process vertices with no dependencies first</li>
            <li class="academic-text"><strong>Remove and update:</strong> Remove vertex and decrease neighbors' in-degrees</li>
            <li class="academic-text"><strong>Cycle detection:</strong> If we can't process all vertices, there's a cycle</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Course Prerequisites Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> C[Physics 201]
            B[CS 101] --> D[Data Structures]
            A --> D
            C --> E[Advanced Physics]
            D --> F[Algorithms]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Valid order: Math 101, CS 101, Physics 201, Data Structures, Advanced Physics, Algorithms</p>
    </div>

    <pre class="code-block">// Kahn's Algorithm Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

class TopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> inDegree;
    int numVertices;
    
public:
    TopologicalSort(int n) : numVertices(n), graph(n), inDegree(n, 0) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
        inDegree[to]++;
    }
    
    // Kahn's algorithm for topological sorting
    vector<int> kahnSort() {
        vector<int> result;
        queue<int> zeroInDegree;
        
        // Find all vertices with no incoming edges
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                zeroInDegree.push(i);
            }
        }
        
        while (!zeroInDegree.empty()) {
            int current = zeroInDegree.front();
            zeroInDegree.pop();
            result.push_back(current);
            
            // Remove current vertex and update in-degrees
            for (int neighbor : graph[current]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    zeroInDegree.push(neighbor);
                }
            }
        }
        
        // Check for cycles
        if (result.size() != numVertices) {
            return {}; // Cycle detected - no valid topological order
        }
        
        return result;
    }
    
    // Check if graph is a DAG
    bool isDAG() {
        return kahnSort().size() == numVertices;
    }
};</pre>

    <h2 class="section-title" id="ch9-2">9.2 DFS-Based Topological Sort</h2>
    
    <p class="academic-text">Another approach to topological sorting uses DFS. The key insight is that in a DFS traversal of a DAG, a vertex should appear in the topological order after all vertices in its DFS subtree.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîç DFS Topological Strategy</h3>
        <p class="academic-text"><strong>DFS Topological Sort</strong> uses post-order DFS traversal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Post-order traversal:</strong> Add vertex to result after visiting all descendants</li>
            <li class="academic-text"><strong>Reverse order:</strong> Reverse the post-order to get topological order</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use three colors to detect back edges</li>
            <li class="academic-text"><strong>Recursive approach:</strong> Natural recursive implementation</li>
        </ul>
    </div>

    <pre class="code-block">// DFS-Based Topological Sort
class DFSTopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> color; // 0: white, 1: gray, 2: black
    vector<int> result;
    bool hasCycle;
    
    void dfsVisit(int vertex) {
        color[vertex] = 1; // Mark as gray (processing)
        
        for (int neighbor : graph[vertex]) {
            if (color[neighbor] == 1) {
                hasCycle = true; // Back edge found - cycle detected
                return;
            }
            if (color[neighbor] == 0) {
                dfsVisit(neighbor);
            }
        }
        
        color[vertex] = 2; // Mark as black (finished)
        result.push_back(vertex); // Add to result in post-order
    }
    
public:
    DFSTopologicalSort(int n) : graph(n), color(n, 0), hasCycle(false) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
    }
    
    vector<int> topologicalSort() {
        result.clear();
        hasCycle = false;
        fill(color.begin(), color.end(), 0);
        
        // Start DFS from all unvisited vertices
        for (int i = 0; i < graph.size(); i++) {
            if (color[i] == 0) {
                dfsVisit(i);
                if (hasCycle) return {}; // Cycle detected
            }
        }
        
        // Reverse to get correct topological order
        reverse(result.begin(), result.end());
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch9-3">9.3 Dynamic Programming on DAGs</h2>
    
    <p class="academic-text">DAGs have a special property that makes dynamic programming very natural: they have no cycles, so we can process vertices in topological order and guarantee that when we process a vertex, all its dependencies have already been computed.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">‚ö° DP on DAGs Strategy</h3>
        <p class="academic-text"><strong>Dynamic Programming on DAGs</strong> leverages topological ordering for optimal substructure.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Topological order:</strong> Process vertices in dependency order</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Solution depends on optimal solutions to subproblems</li>
            <li class="academic-text"><strong>No cycles:</strong> No need to worry about circular dependencies</li>
            <li class="academic-text"><strong>Memoization:</strong> Store computed results to avoid recomputation</li>
        </ul>
    </div>

    <pre class="code-block">// Dynamic Programming on DAGs
class DAGDynamicProgramming {
private:
    vector<vector<pair<int, int>>> graph; // adjacency list with weights
    vector<int> dp;
    vector<bool> visited;
    
public:
    DAGDynamicProgramming(int n) : graph(n), dp(n, -1), visited(n, false) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back({to, weight});
    }
    
    // Find longest path from source using DP
    int longestPath(int source, int target) {
        if (source == target) return 0;
        if (visited[source]) return dp[source];
        
        visited[source] = true;
        dp[source] = INT_MIN; // Initialize to negative infinity
        
        for (auto [neighbor, weight] : graph[source]) {
            int pathLength = longestPath(neighbor, target);
            if (pathLength != INT_MIN) {
                dp[source] = max(dp[source], weight + pathLength);
            }
        }
        
        return dp[source];
    }
    
    // Count number of paths from source to target
    int countPaths(int source, int target) {
        if (source == target) return 1;
        
        vector<int> pathCount(graph.size(), -1);
        return countPathsHelper(source, target, pathCount);
    }
    
private:
    int countPathsHelper(int current, int target, vector<int>& pathCount) {
        if (current == target) return 1;
        if (pathCount[current] != -1) return pathCount[current];
        
        pathCount[current] = 0;
        for (auto [neighbor, weight] : graph[current]) {
            pathCount[current] += countPathsHelper(neighbor, target, pathCount);
        }
        
        return pathCount[current];
    }
};</pre>

    <h2 class="section-title" id="ch9-4">9.4 Longest and Shortest Paths in DAGs</h2>
    
    <p class="academic-text">Finding longest and shortest paths in general graphs can be complex, but in DAGs, we can solve these problems efficiently using topological sorting and dynamic programming.</p>

    <pre class="code-block">// Longest and Shortest Paths in DAGs
class DAGPaths {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    DAGPaths(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Find shortest paths from source using topological sort
    vector<int> shortestPaths(int source) {
        vector<int> dist(numVertices, INT_MAX);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MAX) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight < dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
    // Find longest paths from source
    vector<int> longestPaths(int source) {
        vector<int> dist(numVertices, INT_MIN);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MIN) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight > dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
private:
    vector<int> getTopologicalOrder() {
        vector<int> inDegree(numVertices, 0);
        for (int u = 0; u < numVertices; u++) {
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]++;
            }
        }
        
        queue<int> q;
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        vector<int> topoOrder;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            topoOrder.push_back(u);
            
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]--;
                if (inDegree[edge.to] == 0) {
                    q.push(edge.to);
                }
            }
        }
        
        return topoOrder;
    }
    
public:
    // Demo function for project scheduling
    static void demo() {
        DAGPaths scheduler(6);
        
        // Project tasks with durations (weights)
        scheduler.addEdge(0, 1, 3);  // Task A -> B (3 days)
        scheduler.addEdge(0, 2, 2);  // Task A -> C (2 days)
        scheduler.addEdge(1, 3, 4);  // Task B -> D (4 days)
        scheduler.addEdge(2, 3, 1);  // Task C -> D (1 day)
        scheduler.addEdge(3, 4, 2);  // Task D -> E (2 days)
        scheduler.addEdge(1, 5, 3);  // Task B -> F (3 days)
        
        vector<int> longest = scheduler.longestPaths(0);
        
        cout << "Critical path analysis:" << endl;
        char labels[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        for (int i = 0; i < 6; i++) {
            cout << "Task " << labels[i] << ": " << longest[i] << " days" << endl;
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üìä Topological Sorting Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kahn's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Approach:</strong> Remove vertices with no dependencies</li>
                    <li class="academic-text"><strong>Intuitive:</strong> Mirrors real-world scheduling</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS-Based Sort</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Approach:</strong> Post-order DFS traversal</li>
                    <li class="academic-text"><strong>Natural:</strong> Recursive implementation</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 9 Complete!</h3>
        <p class="academic-text">You've mastered topological sorting and DAG algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Kahn's Algorithm</strong> - intuitive dependency-based sorting</li>
            <li class="academic-text">‚úÖ <strong>DFS Topological Sort</strong> - recursive post-order approach</li>
            <li class="academic-text">‚úÖ <strong>Dynamic Programming on DAGs</strong> - leveraging topological order</li>
            <li class="academic-text">‚úÖ <strong>Path Problems in DAGs</strong> - longest/shortest paths efficiently</li>
        </ul>
        
        <p class="academic-text">These algorithms solve fundamental scheduling and dependency problems that appear everywhere in computer science and project management. You now have the complete toolkit for core graph algorithms!</p>
    </div>

    </div>
            
</body>
</html>