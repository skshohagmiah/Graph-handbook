<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms Handbook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Cache buster: 1761635545595 -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f8ff',
                primaryTextColor: '#000',
                primaryBorderColor: '#333',
                lineColor: '#333',
                secondaryColor: '#e8f5e8',
                tertiaryColor: '#fff5f5'
            }
        });
    </script>
    <style>
        /* Academic book styling like CPH */
        body { 
            font-family: 'Times New Roman', serif; 
            line-height: 1.6;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Times New Roman', serif;
            font-weight: normal;
        }
        
        .academic-content {
            max-width: 750px;
            margin: 0 auto;
            padding: 60px 40px;
        }
        
        .chapter-number {
            font-size: 16px;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 12px;
            font-weight: bold;
        }
        
        .chapter-title {
            font-size: 32px;
            font-weight: bold;
            color: #000;
            margin-bottom: 40px;
            line-height: 1.2;
        }
        
        .section-title {
            font-size: 22px;
            font-weight: bold;
            color: #1a202c;
            margin: 45px 0 20px 0;
            border-bottom: 2px solid #4299e1;
            padding-bottom: 10px;
        }
        
        .academic-text {
            font-size: 12pt;
            line-height: 1.7;
            color: #2d3748;
            text-align: justify;
            margin-bottom: 14px;
        }
        
        .code-block {
            background-color: #2d2d2d; /* deeper gray for print clarity */
            color: #f8f8f2; /* softer white */
            border: 1.5px solid #444;
            border-left: 4px solid #3b82f6; /* subtle blue accent */
            border-radius: 6px;
            padding: 14px 18px;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 10pt;
            margin: 20px 0;
            overflow-x: auto;
            white-space: pre;
            line-height: 1.5;
            box-shadow: none; /* remove for PDF */
            }

        
        .definition-box {
            border-left: 4px solid #2196f3;
            background-color: #f8f9fa;
            padding: 16px;
            margin: 20px 0;
            font-style: italic;
            border-radius: 4px;
        }
        
        /* Mermaid diagram styling */
        .mermaid {
            text-align: center;
            margin: 20px 0;
        }
        
        .mermaid svg {
            max-width: 100%;
            height: auto;
        }
        
        .cover-title {
            font-size: 48px;
            font-weight: normal;
            color: black;
            margin-bottom: 40px;
            line-height: 1.3;
            text-align: center;
        }
        
        .cover-divider {
            width: 128px;
            height: 1px;
            background: black;
            margin: 0 auto 40px auto;
        }
        
        .cover-subtitle {
            font-size: 18px;
            color: black;
            font-weight: 300;
            max-width: 400px;
            line-height: 1.5;
            margin: 0 auto 100px auto;
            text-align: center;
        }
        
        .cover-author {
            font-size: 18px;
            color: black;
            font-weight: normal;
            margin-bottom: 12px;
            text-align: center;
        }
        
        .cover-year {
            font-size: 16px;
            color: black;
            font-weight: 300;
            text-align: center;
        }
        
        /* Cover page container styling */
        .cover-page {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 0 48px;
            font-family: 'Times New Roman', serif;
        }
        
        .cover-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }
        
        .cover-main {
            flex: 2;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .cover-footer {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding-bottom: 60px;
        }
        
        /* Summary section styling to match diagram backgrounds */
        .summary-section {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .performance-summary {
            background-color: #f8f9fa;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .completion-summary {
            background-color: #f8f9fa;
            border-left: 5px solid #2196f3;
            padding: 20px;
            margin: 30px 0;
        }
        
        @media print {
            .no-print { display: none !important; }
            .page-break { page-break-before: always; }
            
            /* Ensure code blocks print with proper colors and no overflow */
            .code-block {
                background: #2d3748 !important;
                color: #e2e8f0 !important;
                border: 2px solid #4a5568 !important;
                border-left: 4px solid #4299e1 !important;
                page-break-inside: avoid;
                overflow: visible !important;
                white-space: pre-wrap !important;
                word-wrap: break-word !important;
                font-size: 10pt !important;
                line-height: 1.4 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure summary sections print with colors */
            .performance-summary {
                background-color: #f8f9fa !important;
                border: 2px solid #4caf50 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .completion-summary {
                background-color: #f8f9fa !important;
                border-left: 5px solid #2196f3 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            .summary-section {
                background-color: #f8f9fa !important;
                border: 1px solid #dee2e6 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Prevent diagrams from being split across pages */
            .mermaid {
                page-break-inside: avoid;
                page-break-before: auto;
                page-break-after: auto;
            }
            
            /* Prevent diagram containers from splitting */
            div[style*="background-color: #f8f9fa"] {
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure definition boxes print properly */
            .definition-box {
                background-color: #f8f9fa !important;
                border-left: 4px solid #2196f3 !important;
                page-break-inside: avoid;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Better page breaks for sections */
            .section-title {
                page-break-after: avoid;
            }
            
            .chapter-title {
                page-break-after: avoid;
            }
            
            /* Prevent orphaned content */
            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }
            
            /* Ensure tables don't break awkwardly */
            table {
                page-break-inside: avoid;
            }
            
            /* Better spacing for print */
            .academic-content {
                line-height: 1.6 !important;
            }
        }
    </style>
</head>
<body class="font-sans text-gray-800 bg-white">

    <div class="cover-page " id="cover">
        
    <div class="cover-content">
        <div class="cover-main">
            <h1 class="cover-title">
                Graph Algorithms<br>
                Handbook
            </h1>
            <div class="cover-divider"></div>
            <p class="cover-subtitle">
                A Comprehensive Guide to Graph Theory,<br>
                Algorithms, and Network Analysis
            </p>
        </div>
        
        <div class="cover-footer">
            <div class="cover-author">Shohag Miah</div>
            <div class="cover-year">2025</div>
        </div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="preface">
        
    <h1 class="chapter-title">Preface</h1>
    
    <div class="definition-box">
        "Life is a graph. Learn to navigate it."
    </div>
    
    <p class="academic-text">Welcome to the <strong>Graph Algorithms Handbook</strong> – your comprehensive guide to understanding one of the most fundamental and powerful concepts in computer science and life itself.</p>
    
    <h2 class="section-title">Why This Book?</h2>
    
    <p class="academic-text">Every day, you navigate complex networks without realizing it. Your social connections, career decisions, daily routines, and even your thoughts form intricate graph structures. This handbook bridges the gap between abstract mathematical concepts and practical, real-world thinking.</p>
    
    <p class="academic-text">Unlike traditional algorithm books that focus purely on theory, this handbook emphasizes:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Practical Understanding</strong> – See graphs everywhere around you</li>
        <li class="academic-text"><strong>Real-World Applications</strong> – From social networks to GPS navigation</li>
        <li class="academic-text"><strong>C++ Implementation</strong> – Modern, efficient code examples</li>
        <li class="academic-text"><strong>Life Insights</strong> – Apply graph thinking to personal decisions</li>
        <li class="academic-text"><strong>Progressive Learning</strong> – From basics to advanced concepts</li>
    </ul>
    
    <h2 class="section-title">Who Should Read This?</h2>
    
    <p class="academic-text">This handbook is designed for:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Students</strong> learning data structures and algorithms</li>
        <li class="academic-text"><strong>Programmers</strong> preparing for technical interviews</li>
        <li class="academic-text"><strong>Software Engineers</strong> working with complex systems</li>
        <li class="academic-text"><strong>Anyone curious</strong> about how connected systems work</li>
    </ul>
    
    <h2 class="section-title">How to Use This Book</h2>
    
    <p class="academic-text">The handbook is organized into four progressive parts:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Part I: Foundations</strong> – Basic concepts and representations</li>
        <li class="academic-text"><strong>Part II: Core Algorithms</strong> – Essential algorithms every programmer should know</li>
        <li class="academic-text"><strong>Part III: Advanced Topics</strong> – Complex algorithms and specialized problems</li>
        <li class="academic-text"><strong>Part IV: Applied Thinking</strong> – Real-world applications and life insights</li>
    </ul>
    
    <p class="academic-text">Each chapter includes practical C++ examples, exercises, and insights that connect the concepts to everyday life. Don't just read – practice, experiment, and think about how these concepts apply to your own challenges.</p>
    
    <h2 class="section-title">A Personal Note</h2>
    
    <p class="academic-text">Graphs changed how I see the world. Once you understand that everything is connected – your relationships, goals, systems, and decisions – you gain a powerful lens for problem-solving and optimization.</p>
    
    <p class="academic-text">This handbook is my attempt to share that perspective with you. I hope it not only helps you master algorithms but also transforms how you think about the interconnected world around us.</p>
    
    <p class="academic-text">If you have questions, feedback, or would like to discuss any concepts from this handbook, I'd love to hear from you. Feel free to reach out at <strong>shohagmiah2100@gmail.com</strong>.</p>
    
    <div style="text-align: right; margin-top: 40px;">
        <div class="academic-text" style="margin-bottom: 4px;"><strong>Shohag Miah</strong></div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="toc">
        
    <h1 class="chapter-title">Contents</h1>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART I — THE FOUNDATIONS OF GRAPH THINKING</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch1" style="color: #000; text-decoration: none;">1 What Are Graphs, Really?</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch1-1" style="color: #666; text-decoration: none;">1.1 Definition: Nodes, Edges, and Degrees</a></p>
                <p><a href="#ch1-2" style="color: #666; text-decoration: none;">1.2 Graph Types: Directed, Undirected, Weighted, Unweighted</a></p>
                <p><a href="#ch1-3" style="color: #666; text-decoration: none;">1.3 Cyclic vs Acyclic Structures</a></p>
                <p><a href="#ch1-4" style="color: #666; text-decoration: none;">1.4 Graph Representations: Adjacency List, Matrix, Edge List</a></p>
                <p><a href="#ch1-5" style="color: #666; text-decoration: none;">1.5 Real-World Examples</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch2" style="color: #000; text-decoration: none;">2 Graph Properties & Special Types</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch2-1" style="color: #666; text-decoration: none;">2.1 Connected vs Disconnected Graphs</a></p>
                <p><a href="#ch2-2" style="color: #666; text-decoration: none;">2.2 Strongly Connected Components (SCCs)</a></p>
                <p><a href="#ch2-3" style="color: #666; text-decoration: none;">2.3 Directed Acyclic Graphs (DAGs)</a></p>
                <p><a href="#ch2-4" style="color: #666; text-decoration: none;">2.4 Bipartite Graphs and Graph Density</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch3" style="color: #000; text-decoration: none;">3 Trees — The Simplest Graphs</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch3-1" style="color: #666; text-decoration: none;">3.1 Tree Properties and Terminology</a></p>
                <p><a href="#ch3-2" style="color: #666; text-decoration: none;">3.2 Binary Trees, N-ary Trees, Binary Search Trees</a></p>
                <p><a href="#ch3-3" style="color: #666; text-decoration: none;">3.3 Tree Traversals: Preorder, Inorder, Postorder, Level-order</a></p>
                <p><a href="#ch3-4" style="color: #666; text-decoration: none;">3.4 Applications in File Systems and Hierarchies</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch4" style="color: #000; text-decoration: none;">4 Tries and Prefix Structures</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch4-1" style="color: #666; text-decoration: none;">4.1 Trie Data Structure and Operations</a></p>
                <p><a href="#ch4-2" style="color: #666; text-decoration: none;">4.2 String Searching and Autocomplete Systems</a></p>
                <p><a href="#ch4-3" style="color: #666; text-decoration: none;">4.3 Applications: Spell Checkers, Dictionaries, IP Routing</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch5" style="color: #000; text-decoration: none;">5 Heaps and Priority Structures</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch5-1" style="color: #666; text-decoration: none;">5.1 Heap Properties: Min-Heap and Max-Heap</a></p>
                <p><a href="#ch5-2" style="color: #666; text-decoration: none;">5.2 Heap Operations: Insert, Extract, Heapify</a></p>
                <p><a href="#ch5-3" style="color: #666; text-decoration: none;">5.3 Priority Queues and Applications</a></p>
                <p><a href="#ch5-4" style="color: #666; text-decoration: none;">5.4 Heap Sort and Graph Algorithm Preparation</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART II — CORE ALGORITHMS</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch6" style="color: #000; text-decoration: none;">6 Traversal Algorithms</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch6-1" style="color: #666; text-decoration: none;">6.1 Breadth-First Search (BFS)</a></p>
                <p><a href="#ch6-2" style="color: #666; text-decoration: none;">6.2 Depth-First Search (DFS)</a></p>
                <p><a href="#ch6-3" style="color: #666; text-decoration: none;">6.3 Cycle Detection Using DFS</a></p>
                <p><a href="#ch6-4" style="color: #666; text-decoration: none;">6.4 Applications in Social Networks and Web Crawling</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch7" style="color: #000; text-decoration: none;">7 Shortest Path Algorithms</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch7-1" style="color: #666; text-decoration: none;">7.1 Dijkstra's Algorithm</a></p>
                <p><a href="#ch7-2" style="color: #666; text-decoration: none;">7.2 Bellman-Ford Algorithm</a></p>
                <p><a href="#ch7-3" style="color: #666; text-decoration: none;">7.3 A* Algorithm with Heuristics</a></p>
                <p><a href="#ch7-4" style="color: #666; text-decoration: none;">7.4 Floyd-Warshall All-Pairs Shortest Path</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch8" style="color: #000; text-decoration: none;">8 Minimum Spanning Trees</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch8-1" style="color: #666; text-decoration: none;">8.1 Kruskal's Algorithm</a></p>
                <p><a href="#ch8-2" style="color: #666; text-decoration: none;">8.2 Prim's Algorithm</a></p>
                <p><a href="#ch8-3" style="color: #666; text-decoration: none;">8.3 Union-Find Data Structure</a></p>
                <p><a href="#ch8-4" style="color: #666; text-decoration: none;">8.4 Applications in Network Design</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch9" style="color: #000; text-decoration: none;">9 Topological Sorting & Dynamic Programming on DAGs</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch9-1" style="color: #666; text-decoration: none;">9.1 Topological Ordering and Kahn's Algorithm</a></p>
                <p><a href="#ch9-2" style="color: #666; text-decoration: none;">9.2 DFS-Based Topological Sort</a></p>
                <p><a href="#ch9-3" style="color: #666; text-decoration: none;">9.3 Dynamic Programming on DAGs</a></p>
                <p><a href="#ch9-4" style="color: #666; text-decoration: none;">9.4 Longest and Shortest Paths in DAGs</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART III — ADVANCED TOPICS</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch10" style="color: #000; text-decoration: none;">10 Flow Networks and Optimization</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch10-1" style="color: #666; text-decoration: none;">10.1 Max Flow Problem and Min-Cut Theorem</a></p>
                <p><a href="#ch10-2" style="color: #666; text-decoration: none;">10.2 Ford-Fulkerson Method</a></p>
                <p><a href="#ch10-3" style="color: #666; text-decoration: none;">10.3 Edmonds-Karp Algorithm</a></p>
                <p><a href="#ch10-4" style="color: #666; text-decoration: none;">10.4 Applications in Logistics and Supply Chain</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch11" style="color: #000; text-decoration: none;">11 Graph Coloring & Matching</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch11-1" style="color: #666; text-decoration: none;">11.1 Greedy Coloring Algorithms</a></p>
                <p><a href="#ch11-2" style="color: #666; text-decoration: none;">11.2 Bipartite Matching and Maximum Matching</a></p>
                <p><a href="#ch11-3" style="color: #666; text-decoration: none;">11.3 Applications in Scheduling and Resource Allocation</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch12" style="color: #000; text-decoration: none;">12 Advanced Graph Concepts</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch12-1" style="color: #666; text-decoration: none;">12.1 Articulation Points and Bridges</a></p>
                <p><a href="#ch12-2" style="color: #666; text-decoration: none;">12.2 Tarjan's Algorithm for SCCs</a></p>
                <p><a href="#ch12-3" style="color: #666; text-decoration: none;">12.3 Eulerian and Hamiltonian Paths</a></p>
                <p><a href="#ch12-4" style="color: #666; text-decoration: none;">12.4 Network Reliability Analysis</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">PART IV — APPLIED GRAPH THINKING</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch13" style="color: #000; text-decoration: none;">13 Graphs in Computer Science</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch13-1" style="color: #666; text-decoration: none;">13.1 Compilers and Abstract Syntax Trees</a></p>
                <p><a href="#ch13-2" style="color: #666; text-decoration: none;">13.2 Operating Systems: Scheduling and Deadlock Detection</a></p>
                <p><a href="#ch13-3" style="color: #666; text-decoration: none;">13.3 Databases and Graph Databases</a></p>
                <p><a href="#ch13-4" style="color: #666; text-decoration: none;">13.4 AI Search and Machine Learning Computation Graphs</a></p>
                <p><a href="#ch13-5" style="color: #666; text-decoration: none;">13.5 Web: PageRank and Social Media Algorithms</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch14" style="color: #000; text-decoration: none;">14 Pattern Recognition in Graphs</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch14-1" style="color: #666; text-decoration: none;">14.1 Cliques and Complete Subgraphs</a></p>
                <p><a href="#ch14-2" style="color: #666; text-decoration: none;">14.2 Community Detection Algorithms</a></p>
                <p><a href="#ch14-3" style="color: #666; text-decoration: none;">14.3 Graph Clustering Techniques</a></p>
                <p><a href="#ch14-4" style="color: #666; text-decoration: none;">14.4 Applications in Social Network Analysis</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch15" style="color: #000; text-decoration: none;">15 Graphs in Real Life & Human Decisions</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch15-1" style="color: #666; text-decoration: none;">15.1 Case Study: Career Pathfinding as Dijkstra's Algorithm</a></p>
                <p><a href="#ch15-2" style="color: #666; text-decoration: none;">15.2 Case Study: Social Network Pruning as MST</a></p>
                <p><a href="#ch15-3" style="color: #666; text-decoration: none;">15.3 Case Study: Goal Dependencies as Topological Sorting</a></p>
                <p><a href="#ch15-4" style="color: #666; text-decoration: none;">15.4 Case Study: Time Management as Graph Coloring</a></p>
                <p><a href="#ch15-5" style="color: #666; text-decoration: none;">15.5 Mind Mapping and Decision Making</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch16" style="color: #000; text-decoration: none;">16 Building the Graph Mindset</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch16-1" style="color: #666; text-decoration: none;">16.1 Systems Thinking: Seeing Interconnected Graphs</a></p>
                <p><a href="#ch16-2" style="color: #666; text-decoration: none;">16.2 Recognizing Patterns: Cycles, Dependencies, Bottlenecks</a></p>
                <p><a href="#ch16-3" style="color: #666; text-decoration: none;">16.3 Framework for Analyzing Any System as a Graph</a></p>
                <p><a href="#ch16-4" style="color: #666; text-decoration: none;">16.4 Final Takeaway: "Life is a Graph. Learn to Navigate It."</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#ch17" style="color: #000; text-decoration: none;">17 Graph Problems in Coding Interviews</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#ch17-1" style="color: #666; text-decoration: none;">17.1 Problem 1: Number of Islands (Graph Traversal)</a></p>
                <p><a href="#ch17-2" style="color: #666; text-decoration: none;">17.2 Problem 2: Course Schedule (Topological Sorting)</a></p>
                <p><a href="#ch17-3" style="color: #666; text-decoration: none;">17.3 Problem 3: Word Ladder (Shortest Path)</a></p>
                <p><a href="#ch17-4" style="color: #666; text-decoration: none;">17.4 Problem 4: Number of Connected Components (Union-Find)</a></p>
                <p><a href="#ch17-5" style="color: #666; text-decoration: none;">17.5 Problem 5: Clone Graph (Advanced Traversal)</a></p>
            </div>
        </div>
    </div>
    
    <div style="margin: 40px 0;">
        <h2 class="section-title">APPENDICES</h2>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#appa" style="color: #000; text-decoration: none;">A Graph Terminology Reference</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#appa-1" style="color: #666; text-decoration: none;">A.1 Complete Glossary of Graph Theory Terms</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#appb" style="color: #000; text-decoration: none;">B Algorithm Complexity Table</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#appb-1" style="color: #666; text-decoration: none;">B.1 Time and Space Complexity for All Algorithms</a></p>
                <p><a href="#appb-2" style="color: #666; text-decoration: none;">B.2 Algorithm Decision Matrix</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#appc" style="color: #000; text-decoration: none;">C Practice Problems & Solutions</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#appc-1" style="color: #666; text-decoration: none;">C.1 30 Curated Problems (Easy to Hard)</a></p>
                <p><a href="#appc-2" style="color: #666; text-decoration: none;">C.2 Step-by-Step Solutions</a></p>
                <p><a href="#appc-3" style="color: #666; text-decoration: none;">C.3 Online Judge Platform Links</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#appd" style="color: #000; text-decoration: none;">D Visual Cheatsheet</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#appd-1" style="color: #666; text-decoration: none;">D.1 One-Page Summary of Graph Types</a></p>
                <p><a href="#appd-2" style="color: #666; text-decoration: none;">D.2 Algorithm Decision Tree Flowchart</a></p>
                <p><a href="#appd-3" style="color: #666; text-decoration: none;">D.3 Common Patterns and Solutions</a></p>
            </div>
        </div>
        
        <div style="margin: 20px 0;">
            <p class="academic-text"><strong><a href="#appe" style="color: #000; text-decoration: none;">E Further Reading & Resources</a></strong></p>
            <div style="margin: 8px 0 0 20px; font-size: 10pt; color: #666;">
                <p><a href="#appe-1" style="color: #666; text-decoration: none;">E.1 Recommended Books and Papers</a></p>
                <p><a href="#appe-2" style="color: #666; text-decoration: none;">E.2 Online Resources and Visualization Tools</a></p>
                <p><a href="#appe-3" style="color: #666; text-decoration: none;">E.3 Research Topics for Deep Dives</a></p>
            </div>
        </div>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch1">
        
    <div class="chapter-number">Chapter 1</div>
    <h1 class="chapter-title">What Are Graphs, Really?</h1>

    <div class="definition-box">
        "Think of graphs as a way to show how things are connected - like a map of relationships in the world around us."
    </div>

    <p class="academic-text">You use graphs every single day without realizing it! When you see friend suggestions on Facebook, get directions on Google Maps, or receive movie recommendations on Netflix, you're experiencing the power of graphs. These systems analyze millions of connections to understand relationships and make intelligent predictions about what you might want.</p>
    
    <p class="academic-text">In computer science, a <strong>graph</strong> isn't a bar chart or line plot - it's a mathematical structure that represents relationships between objects. Think of it as a universal language for describing how things are connected in the world around us. Whether you're modeling social networks, transportation systems, or computer networks, graphs provide the foundation for understanding complex interconnected systems.</p>
    
    <p class="academic-text">The beauty of graphs lies in their simplicity and universality. Once you understand how to think in terms of nodes and connections, you can model almost any system where relationships matter. This abstraction allows computer scientists to develop algorithms that work across completely different domains - the same algorithm that finds the shortest path between cities can also find the most efficient way to route data through the internet.</p>
    
    <p class="academic-text"><strong>Real-world examples you encounter daily:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Social media platforms:</strong> Your friends and their connections form a massive social graph. Algorithms analyze this graph to suggest new friends, show relevant posts, and detect communities with similar interests.</li>
        <li class="academic-text"><strong>GPS navigation systems:</strong> Roads, intersections, and traffic patterns create a transportation graph. Your GPS finds the shortest or fastest route by analyzing this network in real-time.</li>
        <li class="academic-text"><strong>The internet and web:</strong> Web pages linked to each other form the world wide web graph. Search engines like Google use this structure to rank pages and understand content relationships.</li>
        <li class="academic-text"><strong>Family and genealogy:</strong> Relationships between people create family trees and ancestry networks, helping trace lineage and genetic connections.</li>
        <li class="academic-text"><strong>Academic systems:</strong> Course prerequisites form directed graphs that determine valid graduation paths and help students plan their academic journey.</li>
        <li class="academic-text"><strong>Recommendation engines:</strong> Your viewing history, purchases, and preferences create graphs that power Netflix suggestions, Amazon recommendations, and Spotify playlists.</li>
    </ul>
    
    <p class="academic-text">This chapter will demystify graphs by showing you exactly what they are, introducing the essential vocabulary you need to understand them, and demonstrating how they work with intuitive examples from everyday life. By the end, you'll see graphs everywhere and understand why they're one of the most powerful tools in computer science.</p>

    <h2 class="section-title" id="ch1-1">1.1 Formal Definition and Mathematical Foundations</h2>
    
    <p class="academic-text">At its core, a <strong>graph</strong> is elegantly simple - it's just a collection of objects and the relationships between them. This mathematical abstraction is powerful because it can represent virtually any system where connections matter, from social networks to molecular structures.</p>
    
    <p class="academic-text">Every graph consists of exactly two components:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Vertices (or nodes):</strong> The individual entities in your system. These could be people in a social network, cities on a map, computers in a network, or genes in a biological pathway. Each vertex represents a distinct object or concept.</li>
        <li class="academic-text"><strong>Edges:</strong> The relationships or connections between vertices. These represent how entities interact, relate, or connect to each other. An edge between two vertices means there's some meaningful relationship worth modeling.</li>
    </ul>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">📚 Mathematical Definition</h3>
        <p class="academic-text">A <strong>graph G = (V, E)</strong> consists of:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>V:</strong> A finite set of vertices (the objects/entities)</li>
            <li class="academic-text"><strong>E:</strong> A set of edges, where each edge connects two vertices from V</li>
        </ul>
        <p class="academic-text">This deceptively simple definition is the foundation for modeling complex systems. Everything else in graph theory - from algorithms to applications - builds upon this basic structure.</p>
    </div>
    
    <p class="academic-text">Understanding the fundamental terminology is crucial for working with graphs effectively. These terms form the vocabulary that allows us to precisely describe graph structures and properties:</p>
    
    <p class="academic-text"><strong>Essential graph terminology:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Order:</strong> The number of vertices in the graph (|V|). This tells you the scale of your system - a social network might have millions of vertices, while a small project dependency graph might have dozens.</li>
        <li class="academic-text"><strong>Size:</strong> The number of edges in the graph (|E|). This indicates how interconnected your system is. More edges generally mean more complex relationships and interactions.</li>
        <li class="academic-text"><strong>Adjacent vertices:</strong> Two vertices connected by an edge are called adjacent or neighbors. In social networks, adjacent vertices represent direct friendships or connections.</li>
        <li class="academic-text"><strong>Incident edges:</strong> An edge is incident to the vertices it connects. This relationship is fundamental for understanding how information or influence flows through a graph.</li>
        <li class="academic-text"><strong>Endpoint:</strong> The vertices at the ends of an edge are called its endpoints. Every edge has exactly two endpoints (in simple graphs).</li>
    </ul>
    
    <p class="academic-text">These basic concepts might seem simple, but they provide the foundation for understanding complex phenomena like viral spread in social networks, traffic flow in cities, or information propagation on the internet. The power of graph theory lies in how these simple building blocks can model incredibly sophisticated real-world systems.</p>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Simple Graph Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A simple undirected graph with 3 nodes and 3 edges</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Breaking it down:</strong><br>
            • Vertices: {Alice, Bob, Carol} - our 3 people<br>
            • Edges: {Alice-Bob, Alice-Carol, Bob-Carol} - the 3 friendships<br>
            • This is called a "complete graph" because everyone is friends with everyone else!
        </div>
    </div>
    
    <h2 class="section-title" id="ch1-2">1.2 Understanding Vertex Degree: Measuring Connectivity and Importance</h2>
    
    <p class="academic-text">The <strong>degree</strong> of a vertex is one of the most fundamental and revealing properties in graph theory. It measures how connected a particular vertex is to the rest of the graph, providing immediate insight into its importance, influence, or role within the system.</p>
    
    <p class="academic-text">In simple terms, the degree is just a count of connections, but this simple measure reveals profound insights about network structure. In social networks, high-degree vertices represent influential people with many connections. In transportation networks, they represent major hubs or intersections. In biological networks, they might represent critical genes or proteins that interact with many others.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">📊 Degree: The Connectivity Measure</h3>
        <p class="academic-text"><strong>Degree of a vertex:</strong> The number of edges incident to (connected to) that vertex.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>High degree vertices:</strong> Highly connected nodes that often serve as hubs, influencers, or critical junction points in the system</li>
            <li class="academic-text"><strong>Low degree vertices:</strong> Peripheral nodes with few connections, often representing specialized or isolated entities</li>
            <li class="academic-text"><strong>Degree 0 (isolated vertices):</strong> Completely disconnected nodes that exist independently of the main network structure</li>
        </ul>
    </div>
    
    <p class="academic-text">The distribution of degrees across a graph tells a story about the network's structure and behavior. Many real-world networks follow a "power law" distribution where most vertices have low degree, but a few vertices have extremely high degree - these are called "scale-free" networks. This pattern appears everywhere from social media (most people have few followers, but celebrities have millions) to the internet (most websites have few links, but major sites like Google have millions).</p>
    
    <p class="academic-text"><strong>The Handshaking Lemma - A fundamental insight:</strong> If you add up all the degrees in any graph, you always get an even number! This happens because each edge connects exactly two vertices, contributing 1 to each of their degrees. So every edge contributes exactly 2 to the total degree count. This simple observation leads to the profound result that the sum of all degrees equals twice the number of edges: Σdeg(v) = 2|E|.</p>
    
    <p class="academic-text">This mathematical relationship has practical implications: in any social network, the total number of friendships (counting each friendship from both people's perspectives) must be even. It's impossible to have a network where this relationship doesn't hold, making it a useful check for data validity.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Degree Analysis Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            D[Dave] --- A[Alice]
            A --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#ffeb3b,stroke:#333,stroke-width:3px
            style B fill:#e3f2fd,stroke:#333,stroke-width:2px
            style C fill:#e3f2fd,stroke:#333,stroke-width:2px
            style D fill:#f3e5f5,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Node degrees: Alice=3, Bob=2, Carol=2, Dave=1</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> The degree of a vertex v, denoted deg(v), is the number of edges incident to v. In this graph: deg(Alice) = 3, deg(Bob) = deg(Carol) = 2, deg(Dave) = 1.
        </div>
    </div>
    
    <p class="academic-text">For graphs with arrows (we'll see these next), we count:</p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>In-degree</strong>: How many arrows point TO this node</li>
        <li class="academic-text"><strong>Out-degree</strong>: How many arrows point FROM this node</li>
    </ul>

    <pre class="code-block">// Simple way to represent our friendship graph in code
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class FriendshipGraph {
private:
    // Each person has a list of their friends
    unordered_map&lt;string, vector&lt;string&gt;&gt; friendsList;
    
public:
    // Add a friendship between two people
    void addFriendship(string person1, string person2) {
        friendsList[person1].push_back(person2);
        friendsList[person2].push_back(person1); // Friendship goes both ways!
    }
    
    // Count how many friends someone has
    int countFriends(string person) {
        return friendsList[person].size();
    }
    
    // Show everyone's friends
    void showAllFriendships() {
        for (const auto&amp; [person, friends] : friendsList) {
            cout &lt;&lt; person &lt;&lt; " is friends with: ";
            for (const string&amp; friendName : friends) {
                cout &lt;&lt; friendName &lt;&lt; " ";
            }
            cout &lt;&lt; "(" &lt;&lt; countFriends(person) &lt;&lt; " friends total)" &lt;&lt; endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-3">1.3 Graph Classifications and Structural Properties</h2>
    
    <p class="academic-text">Graph theory encompasses various types of graphs, each with distinct mathematical properties and real-world applications. Understanding these classifications is crucial for selecting appropriate algorithms and data structures.</p>
    
    <h3 style="color: #2e7d32; margin: 25px 0 15px 0;">🔄 Directed vs. Undirected Graphs</h3>
    
    <p class="academic-text"><strong>Undirected Graphs: Two-Way Streets</strong></p>
    <p class="academic-text">In undirected graphs, connections work both ways - like friendships! If Alice is friends with Bob, then Bob is automatically friends with Alice.</p>
    
    <p class="academic-text"><strong>Key properties:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Symmetric:</strong> If A connects to B, then B connects to A</li>
        <li class="academic-text"><strong>Examples:</strong> Facebook friends, handshakes, two-way roads</li>
        <li class="academic-text"><strong>Maximum connections:</strong> In a graph with n vertices, you can have at most n(n-1)/2 edges</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Undirected Graph Example (Social Network):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] ---|friendship| B[Bob]
            A ---|friendship| C[Carol]
            B ---|friendship| C
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Symmetric relationships: if Alice is friends with Bob, then Bob is friends with Alice</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An undirected graph G = (V, E) where edges are unordered pairs. If (u,v) ∈ E, then (v,u) ∈ E. The edge set can be written as E = {{Alice,Bob}, {Alice,Carol}, {Bob,Carol}}.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Real examples:</strong> Facebook friendships, handshakes, two-way roads</li>
        <li class="academic-text"><strong>Key feature:</strong> If A connects to B, then B automatically connects to A</li>
    </ul>

    <p class="academic-text"><strong>Directed Graphs: One-Way Streets</strong></p>
    <p class="academic-text">In directed graphs, connections have direction - like following someone on Twitter! Alice might follow Bob, but Bob doesn't have to follow Alice back.</p>
    
    <p class="academic-text"><strong>Key concepts:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>In-degree:</strong> How many edges point TO a vertex (followers)</li>
        <li class="academic-text"><strong>Out-degree:</strong> How many edges point FROM a vertex (following)</li>
        <li class="academic-text"><strong>Examples:</strong> Twitter follows, web page links, one-way streets</li>
        <li class="academic-text"><strong>Asymmetric:</strong> A → B doesn't mean B → A</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Directed Graph Example (Social Media Follows):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] -->|follows| B[Bob]
            A -->|follows| C[Carol]
            C -->|follows| B
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Asymmetric relationships: Alice follows Bob, but Bob doesn't follow Alice back</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A directed graph (digraph) G = (V, E) where edges are ordered pairs. Here E = {(Alice,Bob), (Alice,Carol), (Carol,Bob)}. Note that (Alice,Bob) ≠ (Bob,Alice).
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Real examples:</strong> Twitter follows, web page links, email sending</li>
        <li class="academic-text"><strong>Key feature:</strong> A can connect to B without B connecting back to A</li>
    </ul>

    <p class="academic-text"><strong>Weighted vs Unweighted: Some Connections Are Stronger</strong></p>
    
    <p class="academic-text"><strong>Unweighted Graphs:</strong> All connections are equal</p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Unweighted Graph (Simple Friendship):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">All edges have equal weight (typically weight = 1)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An unweighted graph where all edges have the same importance. Can be represented as G = (V, E) without a weight function.
        </div>
    </div>
    
    <p class="academic-text"><strong>Weighted Graphs:</strong> Connections have different strengths or costs</p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Weighted Graph (Distance Between Cities):</strong><br><br>
        <div class="mermaid">
        graph LR
            NYC[New York] ---|200 miles| BOS[Boston]
            NYC ---|450 miles| MIA[Miami]
            BOS ---|300 miles| MIA
            
            style NYC fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style BOS fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style MIA fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each edge has a weight representing distance in miles</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A weighted graph G = (V, E, w) where w: E → ℝ is a weight function. Here w((NYC,Boston)) = 200, w((NYC,Miami)) = 450, w((Boston,Miami)) = 300.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Weights can represent:</strong> Distance, time, cost, friendship strength, internet speed</li>
        <li class="academic-text"><strong>Real examples:</strong> GPS navigation (distance), social networks (closeness), internet routing (speed)</li>
    </ul>

    <pre class="code-block">// Simple way to represent a city distance map
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class CityMap {
private:
    // Each city has connections to other cities with distances
    unordered_map&lt;string, vector&lt;pair&lt;string, int&gt;&gt;&gt; cityConnections;
    
public:
    // Add a road between two cities with distance
    void addRoad(string city1, string city2, int distance) {
        cityConnections[city1].push_back({city2, distance});
        cityConnections[city2].push_back({city1, distance}); // Roads work both ways!
    }
    
    // Show all roads from each city
    void showAllRoads() {
        for (const auto&amp; [city, roads] : cityConnections) {
            cout &lt;&lt; "From " &lt;&lt; city &lt;&lt; ": ";
            for (const auto&amp; [destination, distance] : roads) {
                cout &lt;&lt; destination &lt;&lt; "(" &lt;&lt; distance &lt;&lt; " miles) ";
            }
            cout &lt;&lt; endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-3">1.3 Cycles: Going in Circles vs. Straight Paths</h2>

    <p class="academic-text">Some graphs let you walk in circles, others don't. This makes a big difference in how we use them!</p>

    <p class="academic-text"><strong>What's a Cycle?</strong></p>
    <p class="academic-text">A cycle is when you can start at a node, follow the connections, and end up back where you started.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Graph WITH a Cycle (You can go in circles!):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            
            style A fill:#ffebee,stroke:#e91e63,stroke-width:3px
            style B fill:#ffebee,stroke:#e91e63,stroke-width:3px
            style C fill:#ffebee,stroke:#e91e63,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cycle path: Alice → Bob → Carol → Alice (back to start!)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A cycle in an undirected graph is a closed walk with no repeated vertices except the first and last. This graph contains the 3-cycle (Alice, Bob, Carol, Alice).
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Graph WITHOUT Cycles (Tree structure):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- D[Dave]
            C --- E[Eve]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style E fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">No cycles: there's exactly one path between any two nodes</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A tree is a connected acyclic graph. With n vertices, it has exactly n-1 edges. This tree has 5 vertices and 4 edges.
        </div>
    </div>

    <p class="academic-text"><strong>Trees: The Most Important Cycle-Free Graphs</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Tree:</strong> A connected graph with no cycles (like a family tree!)</li>
        <li class="academic-text"><strong>Forest:</strong> Multiple trees together (like a forest of family trees)</li>
        <li class="academic-text"><strong>Cool fact:</strong> A tree with 5 nodes always has exactly 4 connections</li>
    </ul>

    <div class="definition-box">
        <strong>Tree Rule:</strong> A tree with n nodes has exactly n-1 edges. Add one more edge and you create a cycle!
    </div>

    <p class="academic-text"><strong>When Do We Want Cycles vs. No Cycles?</strong></p>
    
    <p class="academic-text"><strong>Graphs WITH Cycles are good for:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Social networks:</strong> You can have mutual friends</li>
        <li class="academic-text"><strong>City roads:</strong> Multiple routes to the same destination</li>
        <li class="academic-text"><strong>Internet:</strong> Backup paths if one connection fails</li>
    </ul>
    
    <p class="academic-text"><strong>Graphs WITHOUT Cycles (Trees) are good for:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Family trees:</strong> Clear parent-child relationships</li>
        <li class="academic-text"><strong>File folders:</strong> Organized hierarchy</li>
        <li class="academic-text"><strong>Decision making:</strong> Step-by-step choices</li>
        <li class="academic-text"><strong>Project tasks:</strong> Do A before B before C (no circular dependencies!)</li>
    </ul>

    <h2 class="section-title" id="ch1-4">1.4 Graph Representation: Choosing the Right Data Structure</h2>

    <p class="academic-text">One of the most crucial decisions in working with graphs is how to represent them in computer memory. Just as you might organize your contacts differently depending on how you use them - a phone book for alphabetical lookup, business cards for quick access, or a digital list for searching - there are different ways to store graphs that optimize for different operations and use cases.</p>

    <p class="academic-text">The choice of representation fundamentally affects the performance of every operation you perform on the graph. Want to quickly check if two people are friends? An adjacency matrix excels. Need to find all of someone's connections? An adjacency list is your friend. Processing all relationships in the network? An edge list might be perfect. Understanding these trade-offs is essential for building efficient graph algorithms and applications.</p>

    <p class="academic-text">Let's explore the three most common and important graph representations, understanding not just how they work, but when and why to use each one.</p>

    <p class="academic-text"><strong>Method 1: Adjacency Matrix - The Lookup Table Approach</strong></p>
    <p class="academic-text">An adjacency matrix represents a graph as a square table where each row and column corresponds to a vertex. The intersection of row i and column j tells you whether vertices i and j are connected. Think of it as a giant friendship table where you can instantly look up any relationship.</p>

    <p class="academic-text">This representation excels when you need fast answers to "Are these two vertices connected?" questions. Social media platforms use similar structures to quickly determine if two users are friends, or if one user should see another's posts. The trade-off is memory usage - the matrix needs space for every possible relationship, even if most don't exist.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Friendship Table Example:</strong><br><br>
        <table style="width: 100%; border-collapse: collapse; margin: 15px auto; font-family: monospace; font-size: 14px;">
            <thead>
                <tr style="background-color: #e9ecef;">
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center;"></th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Alice</th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Bob</th>
                    <th style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold;">Carol</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Alice</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Bob</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                </tr>
                <tr>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; font-weight: bold; background-color: #e9ecef;">Carol</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center; background-color: #d4edda;">1</td>
                    <td style="border: 1px solid #dee2e6; padding: 8px; text-align: center;">0</td>
                </tr>
            </tbody>
        </table>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">1 = friends (green), 0 = not friends. Alice is friends with Bob and Carol!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> An adjacency matrix A for graph G = (V, E) is an n×n matrix where A[i,j] = 1 if (vi, vj) ∈ E, and 0 otherwise.
        </div>
    </div>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Good for:</strong> When you need to quickly check "Are Alice and Bob friends?"</li>
        <li class="academic-text"><strong>Bad for:</strong> Uses lots of memory if you have many people but few friendships</li>
    </ul>

    <pre class="code-block">// Method 1: Adjacency Matrix Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

class AdjacencyMatrix {
private:
    vector&lt;vector&lt;bool&gt;&gt; matrix;
    vector&lt;string&gt; nodeNames;
    unordered_map&lt;string, int&gt; nameToIndex;
    int size;
    
public:
    AdjacencyMatrix(const vector&lt;string&gt;&amp; names) {
        size = names.size();
        nodeNames = names;
        matrix.resize(size, vector&lt;bool&gt;(size, false));
        
        // Map names to indices
        for (int i = 0; i &lt; size; i++) {
            nameToIndex[names[i]] = i;
        }
    }
    
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        int i = nameToIndex[person1];
        int j = nameToIndex[person2];
        matrix[i][j] = true;
        matrix[j][i] = true; // Friendship is mutual
    }
    
    // Check if two people are friends - VERY FAST!
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        int i = nameToIndex[person1];
        int j = nameToIndex[person2];
        return matrix[i][j];
    }
    
    // Print the friendship matrix
    void printMatrix() {
        cout &lt;&lt; "\t";
        for (const string&amp; name : nodeNames) {
            cout &lt;&lt; name &lt;&lt; "\t";
        }
        cout &lt;&lt; endl;
        
        for (int i = 0; i &lt; size; i++) {
            cout &lt;&lt; nodeNames[i] &lt;&lt; "\t";
            for (int j = 0; j &lt; size; j++) {
                cout &lt;&lt; (matrix[i][j] ? "1" : "0") &lt;&lt; "\t";
            }
            cout &lt;&lt; endl;
        }
    }
};</pre>


    <p class="academic-text"><strong>Method 2: Adjacency List - The Contact List Approach</strong></p>
    <p class="academic-text">An adjacency list represents a graph by giving each vertex its own list of neighbors - like how your phone stores contacts for each person you know. Instead of a massive table with mostly empty cells, you only store the connections that actually exist.</p>

    <p class="academic-text">This representation is incredibly memory-efficient for sparse graphs (where most vertices aren't connected to most other vertices), which describes the vast majority of real-world networks. Think about it: you're not friends with most people on Facebook, most web pages don't link to most other web pages, and most cities aren't directly connected by roads. Adjacency lists excel in these scenarios by only storing actual relationships.</p>

    <p class="academic-text">The adjacency list shines when you need to iterate through all of a vertex's neighbors - operations like "find all of Alice's friends" or "recommend people Bob might know" become very efficient. Social media algorithms, recommendation systems, and network analysis tools heavily rely on this type of neighbor traversal.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; font-family: monospace; text-align: left;">
        <strong>Contact Lists Example:</strong><br><br>
        <pre style="margin: 0; font-size: 12px;">
Alice's friends: [Bob, Carol]
Bob's friends:   [Alice, Carol]
Carol's friends: [Alice, Bob]
        </pre>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px;">Each person maintains their own list of direct connections</p>
    </div>
    
    <p class="academic-text"><strong>When adjacency lists excel:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Sparse networks:</strong> When most vertices have relatively few connections compared to the total number of vertices</li>
        <li class="academic-text"><strong>Neighbor iteration:</strong> When you frequently need to process all neighbors of a vertex</li>
        <li class="academic-text"><strong>Dynamic graphs:</strong> When you're adding or removing edges frequently</li>
        <li class="academic-text"><strong>Memory constraints:</strong> When you need to minimize memory usage for large graphs</li>
    </ul>

    <pre class="code-block">// Method 2: Adjacency List Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;

class AdjacencyList {
private:
    // Each person has their own list of friends
    unordered_map&lt;string, vector&lt;string&gt;&gt; friendsMap;
    
public:
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        friendsMap[person1].push_back(person2);
        friendsMap[person2].push_back(person1); // Friendship is mutual
    }
    
    // Get all friends of a person - VERY FAST!
    vector&lt;string&gt; getFriends(const string&amp; person) {
        return friendsMap[person];
    }
    
    // Check if two people are friends (slower than matrix)
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        const auto&amp; friends = friendsMap[person1];
        return find(friends.begin(), friends.end(), person2) != friends.end();
    }
    
    // Count how many friends someone has
    int countFriends(const string&amp; person) {
        return friendsMap[person].size();
    }
    
    // Print everyone's friend lists
    void printLists() {
        for (const auto&amp; [person, friends] : friendsMap) {
            cout &lt;&lt; person &lt;&lt; "'s friends: [";
            for (size_t i = 0; i &lt; friends.size(); i++) {
                cout &lt;&lt; friends[i];
                if (i &lt; friends.size() - 1) cout &lt;&lt; ", ";
            }
            cout &lt;&lt; "]" &lt;&lt; endl;
        }
    }
    
    // Find mutual friends between two people
    vector&lt;string&gt; getMutualFriends(const string&amp; person1, const string&amp; person2) {
        vector&lt;string&gt; mutual;
        const auto&amp; friends1 = friendsMap[person1];
        const auto&amp; friends2 = friendsMap[person2];
        
        for (const string&amp; friend1 : friends1) {
            if (find(friends2.begin(), friends2.end(), friend1) != friends2.end()) {
                mutual.push_back(friend1);
            }
        }
        return mutual;
    }
};</pre>

    <p class="academic-text"><strong>Method 3: Edge List - The Simple Relationship Catalog</strong></p>
    <p class="academic-text">An edge list is the most straightforward way to represent a graph - simply maintain a list of all the relationships that exist. Think of it as a comprehensive catalog where each entry describes one connection in your network. While this might seem overly simple, edge lists are incredibly powerful for certain types of graph processing.</p>

    <p class="academic-text">Edge lists excel when you need to process all relationships in the graph systematically. Many fundamental graph algorithms - like finding minimum spanning trees, detecting cycles, or analyzing network properties - work by examining every edge in the graph. For these applications, having all edges in a simple, iterable list is exactly what you need.</p>

    <p class="academic-text">This representation is also ideal for algorithms that need to sort or filter edges based on properties like weight, creation time, or relationship strength. Social media platforms might use edge lists to analyze all friendships formed in a particular time period, or transportation systems might process all road segments to find optimal routes.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; font-family: monospace; text-align: left;">
        <strong>Friendship List Example:</strong><br><br>
        <pre style="margin: 0; font-size: 12px;">
Friendship 1: Alice - Bob
Friendship 2: Alice - Carol  
Friendship 3: Bob - Carol
        </pre>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px;">A complete catalog of every relationship in the network</p>
    </div>
    
    <p class="academic-text"><strong>When edge lists are perfect:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Edge-centric algorithms:</strong> When you need to process every relationship in the graph systematically</li>
        <li class="academic-text"><strong>Sorting and filtering:</strong> When you need to organize edges by weight, time, or other properties</li>
        <li class="academic-text"><strong>Simple storage:</strong> When you want the most straightforward way to store and transmit graph data</li>
        <li class="academic-text"><strong>Batch processing:</strong> When you're analyzing entire networks rather than navigating from specific vertices</li>
    </ul>

    <pre class="code-block">// Method 3: Edge List Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class EdgeList {
private:
    // Simple list of all friendships
    vector&lt;pair&lt;string, string&gt;&gt; edges;
    
public:
    // Add friendship between two people
    void addEdge(const string&amp; person1, const string&amp; person2) {
        edges.push_back({person1, person2});
    }
    
    // Get all edges/friendships - VERY FAST!
    const vector&lt;pair&lt;string, string&gt;&gt;&amp; getAllEdges() {
        return edges;
    }
    
    // Check if two people are friends (slow - must search all edges)
    bool areFriends(const string&amp; person1, const string&amp; person2) {
        for (const auto&amp; edge : edges) {
            if ((edge.first == person1 &amp;&amp; edge.second == person2) ||
                (edge.first == person2 &amp;&amp; edge.second == person1)) {
                return true;
            }
        }
        return false;
    }
    
    // Count total number of friendships
    int getTotalFriendships() {
        return edges.size();
    }
    
    // Print all friendships
    void printAllFriendships() {
        cout &lt;&lt; "All Friendships:" &lt;&lt; endl;
        for (size_t i = 0; i &lt; edges.size(); i++) {
            cout &lt;&lt; "Friendship " &lt;&lt; (i + 1) &lt;&lt; ": " 
                 &lt;&lt; edges[i].first &lt;&lt; " - " &lt;&lt; edges[i].second &lt;&lt; endl;
        }
    }
    
    // Find all friends of a person (slow - must search all edges)
    vector&lt;string&gt; getFriends(const string&amp; person) {
        vector&lt;string&gt; friends;
        for (const auto&amp; edge : edges) {
            if (edge.first == person) {
                friends.push_back(edge.second);
            } else if (edge.second == person) {
                friends.push_back(edge.first);
            }
        }
        return friends;
    }
};</pre>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Quick Comparison: Which Method to Choose?</strong><br><br>
        <table style="width: 100%; border-collapse: collapse; font-size: 12pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333;">
                    <th style="text-align: left; padding: 8px; font-weight: bold;">What you want to do</th>
                    <th style="text-align: left; padding: 8px; font-weight: bold;">Best Method</th>
                    <th style="text-align: left; padding: 8px; font-weight: bold;">Why?</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 8px;">Quickly check if two people are friends</td>
                    <td style="padding: 8px;"><strong>Matrix</strong></td>
                    <td style="padding: 8px;">Instant lookup</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Find all of someone's friends</td>
                    <td style="padding: 8px;"><strong>List</strong></td>
                    <td style="padding: 8px;">Already organized by person</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Save memory with few friendships</td>
                    <td style="padding: 8px;"><strong>List or Edge List</strong></td>
                    <td style="padding: 8px;">Only stores actual friendships</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Process all friendships one by one</td>
                    <td style="padding: 8px;"><strong>Edge List</strong></td>
                    <td style="padding: 8px;">Simple to iterate through</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2 class="section-title" id="ch1-5">1.5 Graphs Are Everywhere: Real Examples You Know</h2>

    <p class="academic-text">Once you understand graphs, you'll see them everywhere! Here are some examples from your daily life:</p>

    <p class="academic-text"><strong>1. Social Media (Facebook, Instagram, Twitter)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> You and your friends</li>
            <li class="academic-text"><strong>Edges:</strong> Friend connections or follows</li>
            <li class="academic-text"><strong>What it helps with:</strong> "People you may know" suggestions, showing mutual friends</li>
            <li class="academic-text"><strong>Cool fact:</strong> You're usually connected to anyone in the world through just 6 people!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>2. GPS Navigation (Google Maps, Apple Maps)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Intersections, cities, landmarks</li>
            <li class="academic-text"><strong>Edges:</strong> Roads, highways, walking paths (with distances and speed limits)</li>
            <li class="academic-text"><strong>What it helps with:</strong> Finding the fastest route, avoiding traffic, calculating travel time</li>
            <li class="academic-text"><strong>Cool fact:</strong> Your GPS considers millions of possible routes in seconds!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>3. The Internet</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Websites, servers, your computer</li>
            <li class="academic-text"><strong>Edges:</strong> Links between websites, network connections</li>
            <li class="academic-text"><strong>What it helps with:</strong> Finding paths for your data, web page ranking (Google search), detecting broken links</li>
            <li class="academic-text"><strong>Cool fact:</strong> When you click a link, you're following an edge in the world's largest graph!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>4. Course Prerequisites (College/University)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Classes (Math 101, Physics 201, etc.)</li>
            <li class="academic-text"><strong>Edges:</strong> "Must take this class before that one" relationships</li>
            <li class="academic-text"><strong>What it helps with:</strong> Planning your course schedule, making sure you meet requirements</li>
            <li class="academic-text"><strong>Cool fact:</strong> This type of graph can't have cycles - you can't have circular prerequisites!</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>5. Recommendation Systems (Netflix, Amazon, Spotify)</strong></p>
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 15px; margin: 15px 0;">
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> You, other users, movies, products, songs</li>
            <li class="academic-text"><strong>Edges:</strong> "User likes this item" or "Users who are similar"</li>
            <li class="academic-text"><strong>What it helps with:</strong> "People who bought this also bought...", "Because you watched..."</li>
            <li class="academic-text"><strong>Cool fact:</strong> The system finds people with similar tastes to you and recommends what they liked!</li>
        </ul>
    </div>

    <pre class="code-block">// Simple course planning system - like a college advisor!
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;set&gt;
using namespace std;

class CourseAdvisor {
private:
    // Each course has a list of courses you need to take first
    unordered_map&lt;string, vector&lt;string&gt;&gt; prerequisites;
    
public:
    // Add a requirement: "To take course X, you must first complete course Y"
    void addRequirement(string course, string mustTakeFirst) {
        prerequisites[course].push_back(mustTakeFirst);
    }
    
    // Check if a student can take a specific course
    bool canStudentTakeCourse(string course, set&lt;string&gt; completedCourses) {
        // Check each requirement for this course
        for (const string&amp; requiredCourse : prerequisites[course]) {
            if (completedCourses.find(requiredCourse) == completedCourses.end()) {
                return false; // Missing a required course!
            }
        }
        return true; // All requirements met!
    }
    
    // Find all courses a student can take right now
    vector&lt;string&gt; getCoursesStudentCanTake(set&lt;string&gt; completedCourses) {
        vector&lt;string&gt; availableCourses;
        
        for (const auto&amp; [course, requirements] : prerequisites) {
            // Skip courses already completed
            if (completedCourses.find(course) != completedCourses.end()) continue;
            
            // Check if student can take this course
            if (canStudentTakeCourse(course, completedCourses)) {
                availableCourses.push_back(course);
            }
        }
        return availableCourses;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🎯 Try This Yourself!</h3>
        <p class="academic-text">Now that you understand graphs, let's practice! Pick something from your daily life and turn it into a graph:</p>
        
        <div style="background-color: white; border-radius: 8px; padding: 20px; margin: 15px 0;">
            <h4 style="color: #2e7d32; margin-top: 0;">Example: Your School or Workplace</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>Nodes:</strong> Classrooms, offices, cafeteria, library, parking lots</li>
                <li class="academic-text"><strong>Edges:</strong> Hallways, stairs, walkways</li>
                <li class="academic-text"><strong>Weights:</strong> Walking time between locations</li>
                <li class="academic-text"><strong>Type:</strong> Undirected (you can walk both ways), Weighted (different distances)</li>
                <li class="academic-text"><strong>Use:</strong> Find shortest path to your next class!</li>
            </ul>
        </div>
        
        <p class="academic-text"><strong>Your turn:</strong></p>
        <ol style="margin: 12px 0; padding-left: 20px;">
            <li class="academic-text">Pick a system you know well (your neighborhood, a video game, your family, etc.)</li>
            <li class="academic-text">What are the nodes? (people, places, things)</li>
            <li class="academic-text">What are the edges? (relationships, connections, paths)</li>
            <li class="academic-text">Does direction matter? Are some connections stronger than others?</li>
            <li class="academic-text">What questions could you answer with this graph?</li>
        </ol>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Congratulations!</h3>
        <p class="academic-text">You now understand the fundamental building blocks of graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Nodes and edges</strong> - the dots and lines that make up any graph</li>
            <li class="academic-text">✅ <strong>Different types</strong> - directed vs undirected, weighted vs unweighted</li>
            <li class="academic-text">✅ <strong>Storage methods</strong> - matrices, lists, and edge lists</li>
            <li class="academic-text">✅ <strong>Real-world examples</strong> - from social media to GPS navigation</li>
        </ul>
        
        <p class="academic-text">These concepts are the foundation for everything else in graph theory. In the next chapter, we'll dive deeper into <strong>trees</strong> - special graphs that are everywhere in computer science, from file systems to decision making!</p>
        
        <p class="academic-text" style="font-style: italic; color: #666;">Remember: Every expert was once a beginner. You're building something amazing, one concept at a time! 🚀</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch2">
        
    <div class="chapter-number">Chapter 2</div>
    <h1 class="chapter-title">Graph Properties & Special Types</h1>
    
    <div class="definition-box">
        "Not all graphs are created equal - understanding their special properties unlocks the right algorithms and solutions."
    </div>

    <p class="academic-text">Now that you understand basic graphs, let's dive deeper into their special properties. Just like people have different personalities, graphs have characteristics that determine what you can do with them and which algorithms work best.</p>
    
    <p class="academic-text">In this chapter, we'll explore the key properties that graph theorists and computer scientists use to classify and analyze graphs:</p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Connectivity:</strong> Can you get from anywhere to anywhere?</li>
        <li class="academic-text"><strong>Cycles:</strong> Are there circular paths in your graph?</li>
        <li class="academic-text"><strong>Bipartite structure:</strong> Can you divide nodes into two groups?</li>
        <li class="academic-text"><strong>Density:</strong> How many connections exist vs. how many could exist?</li>
    </ul>
    
    <p class="academic-text">These properties aren't just academic curiosities - they directly impact which algorithms you can use and how efficiently they'll run. Let's explore each one!</p>

    <h2 class="section-title" id="ch2-1">2.1 Connectivity: The Fundamental Structure of Networks</h2>
    
    <p class="academic-text">Connectivity is perhaps the most fundamental and revealing property of any graph. It tells us whether our network forms a unified whole or consists of separate, isolated communities. This seemingly simple concept has profound implications for how information flows, how systems behave, and which algorithms we can effectively apply.</p>

    <p class="academic-text">In the real world, connectivity determines whether a social network can spread information to everyone, whether a transportation system can get you anywhere you want to go, or whether a computer network can route data between any two points. Understanding connectivity is essential for network design, failure analysis, and system optimization.</p>

    <p class="academic-text">The mathematical definition of connectivity is elegant in its simplicity, but its implications are far-reaching. A connected graph ensures that no vertex is truly isolated - there's always a way to reach any vertex from any other vertex, even if it requires going through intermediate connections.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Graph Connectivity Defined</h3>
        <p class="academic-text">A graph is <strong>connected</strong> if there exists a path between every pair of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path:</strong> A sequence of edges that allows you to travel from one vertex to another</li>
            <li class="academic-text"><strong>Reachability:</strong> If you can find a path from vertex A to vertex B, then B is reachable from A</li>
            <li class="academic-text"><strong>Universal reachability:</strong> In a connected graph, every vertex is reachable from every other vertex</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Why connectivity is crucial for algorithms and applications:</strong> Many of the most important graph algorithms assume connectivity, or must be adapted to handle disconnected graphs. Shortest path algorithms, for example, can only find paths between vertices that are actually connected. Network analysis tools must identify separate components to understand the true structure of complex systems. Even simple operations like counting vertices become more complex when you need to account for isolated components.</p>

    <p class="academic-text">In practical systems, connectivity often determines resilience and efficiency. A connected transportation network ensures you can travel anywhere; a disconnected one leaves some destinations unreachable. A connected social network allows information to potentially reach everyone; a disconnected one creates isolated communities that may never interact.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Connected Graph (Everyone Can Reach Everyone):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            B --- C[Carol]
            C --- D[Dave]
            A --- D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Alice can reach Dave through Bob or Carol - everyone is reachable!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Technical note:</strong> In a connected graph with n vertices, you need at least n-1 edges. This is because you need enough edges to "link" all vertices together without leaving anyone isolated.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Disconnected Graph (Isolated Groups):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            C[Carol] --- D[Dave]
            E[Eve]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Three separate components - Alice can't reach Carol, and Eve is completely isolated</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A graph is disconnected if it contains two or more connected components that are not connected to each other.
        </div>
    </div>

    <p class="academic-text"><strong>Real-World Examples:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Connected:</strong> Internet (you can reach any website), highway system, social networks</li>
        <li class="academic-text"><strong>Disconnected:</strong> Separate friend groups, isolated computer networks, different continents without bridges</li>
    </ul>

    <pre class="code-block">// Check if a graph is connected using DFS
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
using namespace std;

class ConnectivityChecker {
private:
    unordered_map<string, vector<string>> graph;
    
    // Depth-First Search to visit all reachable nodes
    void dfs(const string& node, unordered_set<string>& visited) {
        visited.insert(node);
        for (const string& neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                dfs(neighbor, visited);
            }
        }
    }
    
public:
    void addEdge(const string& u, const string& v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Check if the graph is connected
    bool isConnected() {
        if (graph.empty()) return true;
        
        unordered_set<string> visited;
        string startNode = graph.begin()->first;
        
        // Start DFS from any node
        dfs(startNode, visited);
        
        // If we visited all nodes, the graph is connected
        return visited.size() == graph.size();
    }
    
    // Find all connected components
    vector<vector<string>> getConnectedComponents() {
        vector<vector<string>> components;
        unordered_set<string> globalVisited;
        
        for (const auto& [node, neighbors] : graph) {
            if (globalVisited.find(node) == globalVisited.end()) {
                unordered_set<string> componentVisited;
                dfs(node, componentVisited);
                
                vector<string> component;
                for (const string& n : componentVisited) {
                    component.push_back(n);
                    globalVisited.insert(n);
                }
                components.push_back(component);
            }
        }
        return components;
    }
};</pre>

    <h2 class="section-title" id="ch2-2">2.2 Strongly Connected Components: The Direction Matters</h2>

    <p class="academic-text">In directed graphs, connectivity gets more interesting! A <strong>strongly connected component (SCC)</strong> is a group of nodes where you can get from any node to any other node following the arrow directions.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Strongly Connected Components Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --> B[Bob]
            B --> C[Carol]
            C --> A
            
            D[Dave] --> E[Eve]
            E --> F[Frank]
            F --> D
            
            B --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two SCCs: {Alice, Bob, Carol} and {Dave, Eve, Frank}. You can go from Alice→Bob→Carol→Alice, but not back from Dave to Bob!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A strongly connected component is a maximal set of vertices such that for every pair of vertices u and v, there is a directed path from u to v and from v to u.
        </div>
    </div>

    <p class="academic-text"><strong>Why SCCs Matter:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Web analysis:</strong> Groups of websites that link to each other</li>
        <li class="academic-text"><strong>Social networks:</strong> Tight-knit communities where everyone follows everyone</li>
        <li class="academic-text"><strong>Software dependencies:</strong> Circular dependencies that need to be resolved together</li>
    </ul>

    <h2 class="section-title" id="ch2-3">2.3 Directed Acyclic Graphs (DAGs): The Foundation of Ordered Systems</h2>

    <p class="academic-text">A <strong>Directed Acyclic Graph (DAG)</strong> represents one of the most important and useful structures in computer science and mathematics. It's a directed graph with no cycles - meaning you can never follow the arrows and return to where you started. This seemingly simple constraint creates a powerful mathematical structure that naturally represents hierarchies, dependencies, and ordered processes.</p>

    <p class="academic-text">DAGs are everywhere in computer science because they model systems where order matters and circular dependencies would be problematic or impossible. Think about course prerequisites - you can't take Advanced Calculus before Basic Calculus, and you certainly can't have a situation where Advanced Calculus is a prerequisite for Basic Calculus! This natural ordering property makes DAGs perfect for representing dependency relationships, scheduling problems, and hierarchical structures.</p>

    <p class="academic-text">The absence of cycles in a DAG guarantees that we can always find a valid ordering of vertices called a "topological ordering" - an arrangement where all edges point "forward" in the sequence. This property is fundamental to many algorithms and applications, from project scheduling to compiler design to version control systems.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DAG Example (Course Prerequisites):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> B[Math 201]
            A --> C[Physics 101]
            B --> D[Math 301]
            C --> E[Physics 201]
            D --> F[Advanced Math]
            E --> F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Clear progression from basic to advanced courses - no circular prerequisites!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A DAG is a directed graph with no directed cycles. It has a topological ordering where vertices can be arranged so all edges point "forward."
        </div>
    </div>

    <p class="academic-text"><strong>DAG Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Task scheduling:</strong> Project tasks with dependencies</li>
        <li class="academic-text"><strong>Build systems:</strong> Compile order for software modules</li>
        <li class="academic-text"><strong>Family trees:</strong> Ancestry relationships</li>
        <li class="academic-text"><strong>Decision trees:</strong> Step-by-step decision making</li>
    </ul>

    <pre class="code-block">// Simple DAG implementation for task scheduling
#include <iostream>
#include <vector>
#include <unordered_map>
#include <queue>
#include <string>
using namespace std;

class TaskScheduler {
private:
    unordered_map<string, vector<string>> dependencies; // task -> list of tasks it depends on
    unordered_map<string, vector<string>> dependents;   // task -> list of tasks that depend on it
    unordered_map<string, int> inDegree;               // task -> number of dependencies
    
public:
    void addTask(const string& task) {
        if (dependencies.find(task) == dependencies.end()) {
            dependencies[task] = vector<string>();
            dependents[task] = vector<string>();
            inDegree[task] = 0;
        }
    }
    
    // Add dependency: taskB depends on taskA (taskA must be done before taskB)
    void addDependency(const string& taskA, const string& taskB) {
        addTask(taskA);
        addTask(taskB);
        
        dependencies[taskB].push_back(taskA);
        dependents[taskA].push_back(taskB);
        inDegree[taskB]++;
    }
    
    // Get the order in which tasks should be completed (topological sort)
    vector<string> getTaskOrder() {
        vector<string> result;
        queue<string> readyTasks;
        unordered_map<string, int> currentInDegree = inDegree;
        
        // Find tasks with no dependencies
        for (const auto& [task, degree] : currentInDegree) {
            if (degree == 0) {
                readyTasks.push(task);
            }
        }
        
        while (!readyTasks.empty()) {
            string currentTask = readyTasks.front();
            readyTasks.pop();
            result.push_back(currentTask);
            
            // Remove this task and update dependencies
            for (const string& dependent : dependents[currentTask]) {
                currentInDegree[dependent]--;
                if (currentInDegree[dependent] == 0) {
                    readyTasks.push(dependent);
                }
            }
        }
        
        // Check if we have a cycle (couldn't complete all tasks)
        if (result.size() != dependencies.size()) {
            cout << "Error: Circular dependency detected!" << endl;
            return vector<string>();
        }
        
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch2-4">2.4 Bipartite Graphs and Graph Density: Special Structures</h2>

    <p class="academic-text"><strong>Bipartite Graphs: Modeling Two-Sided Relationships</strong></p>
    <p class="academic-text">A <strong>bipartite graph</strong> represents a special and incredibly useful type of network structure where vertices can be divided into two distinct groups, and relationships only exist between groups - never within a group. Think of it as modeling situations where you have two different types of entities that interact with each other, but entities of the same type don't directly connect.</p>

    <p class="academic-text">Bipartite graphs are everywhere in real-world systems. Consider students and courses - students enroll in courses, but students don't directly "connect" to other students in this relationship, and courses don't connect to other courses. Or think about customers and products in an e-commerce system, actors and movies in a film database, or researchers and papers in an academic network. These natural two-sided relationships are perfectly captured by bipartite graphs.</p>

    <p class="academic-text">The power of recognizing bipartite structure lies in the specialized algorithms and analysis techniques that become available. Bipartite graphs have unique properties - they can always be colored with just two colors, they have special matching algorithms, and they enable powerful recommendation systems. Many seemingly complex network problems become much more tractable when you recognize the underlying bipartite structure.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bipartite Graph (Students and Courses):</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph Students
                A[Alice]
                B[Bob]
                C[Carol]
            end
            
            subgraph Courses
                D[Math]
                E[Physics]
                F[Chemistry]
            end
            
            A --- D
            A --- E
            B --- D
            B --- F
            C --- E
            C --- F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Students only connect to courses, courses only connect to students - no student-to-student edges!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A bipartite graph G = (V, E) has vertex set V that can be partitioned into two disjoint sets V₁ and V₂ such that every edge connects a vertex in V₁ to a vertex in V₂.
        </div>
    </div>

    <p class="academic-text"><strong>Graph Density: Measuring Network Interconnectedness</strong></p>
    <p class="academic-text">Graph density is a fundamental metric that quantifies how interconnected a network is by measuring what fraction of all possible connections actually exist. It's like asking: "Out of all the friendships that could theoretically exist in this social network, how many actually do exist?" This simple ratio reveals profound insights about network structure, behavior, and the algorithms that will work best on it.</p>

    <p class="academic-text">Density profoundly affects how networks behave and which algorithms are most efficient. Dense networks - where most vertices are connected to most other vertices - behave very differently from sparse networks where each vertex has relatively few connections. Social networks tend to be sparse (you're not friends with most people), while certain biological networks can be quite dense (many genes interact with many other genes).</p>

    <p class="academic-text">Understanding density is crucial for choosing the right data structures and algorithms. Dense graphs often benefit from adjacency matrix representations and algorithms optimized for high connectivity, while sparse graphs are better served by adjacency lists and algorithms that take advantage of the limited number of edges. The density of your graph can determine whether an algorithm runs in seconds or hours.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Density Examples:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Sparse Graph (Low Density)"
                A1[A] --- B1[B]
                C1[C] --- D1[D]
            end
            
            subgraph "Dense Graph (High Density)"
                A2[A] --- B2[B]
                A2 --- C2[C]
                A2 --- D2[D]
                B2 --- C2
                B2 --- D2
                C2 --- D2
            end
            
            style A1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style D1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            
            style A2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Sparse: 2 edges out of 6 possible (33% density) vs Dense: 6 edges out of 6 possible (100% density)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> For an undirected graph with n vertices, density = 2|E| / (n(n-1)), where |E| is the number of edges. Range: 0 (no edges) to 1 (complete graph).
        </div>
    </div>

    <pre class="code-block">// Graph analysis tools
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <string>
using namespace std;

class GraphAnalyzer {
private:
    unordered_map<string, vector<string>> graph;
    
public:
    void addEdge(const string& u, const string& v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Calculate graph density
    double getDensity() {
        int n = graph.size();
        if (n <= 1) return 0.0;
        
        int edges = 0;
        for (const auto& [node, neighbors] : graph) {
            edges += neighbors.size();
        }
        edges /= 2; // Each edge counted twice in undirected graph
        
        int maxPossibleEdges = n * (n - 1) / 2;
        return (double)edges / maxPossibleEdges;
    }
    
    // Check if graph is bipartite using 2-coloring
    bool isBipartite() {
        if (graph.empty()) return true;
        
        unordered_map<string, int> color; // 0 = uncolored, 1 = red, 2 = blue
        
        for (const auto& [startNode, neighbors] : graph) {
            if (color[startNode] == 0) {
                // Start BFS/DFS from this component
                vector<string> queue = {startNode};
                color[startNode] = 1;
                
                for (size_t i = 0; i < queue.size(); i++) {
                    string current = queue[i];
                    int currentColor = color[current];
                    int neighborColor = (currentColor == 1) ? 2 : 1;
                    
                    for (const string& neighbor : graph[current]) {
                        if (color[neighbor] == 0) {
                            color[neighbor] = neighborColor;
                            queue.push_back(neighbor);
                        } else if (color[neighbor] == currentColor) {
                            return false; // Same color as neighbor - not bipartite!
                        }
                    }
                }
            }
        }
        return true;
    }
    
    void printAnalysis() {
        cout << "Graph Analysis:" << endl;
        cout << "Nodes: " << graph.size() << endl;
        cout << "Density: " << (getDensity() * 100) << "%" << endl;
        cout << "Bipartite: " << (isBipartite() ? "Yes" : "No") << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🎯 Quick Reference: Graph Properties</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Connectivity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Connected:</strong> Path between any two nodes</li>
                    <li class="academic-text"><strong>SCC:</strong> Directed cycles in directed graphs</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Structure</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>DAG:</strong> No cycles, has ordering</li>
                    <li class="academic-text"><strong>Bipartite:</strong> Two groups, edges between groups</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 2 Complete!</h3>
        <p class="academic-text">You now understand the key properties that make graphs special:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Connectivity</strong> - whether you can reach everywhere</li>
            <li class="academic-text">✅ <strong>Strong connectivity</strong> - directed graph communities</li>
            <li class="academic-text">✅ <strong>DAGs</strong> - ordered structures without cycles</li>
            <li class="academic-text">✅ <strong>Bipartite graphs</strong> - two-sided relationships</li>
            <li class="academic-text">✅ <strong>Graph density</strong> - how connected your graph is</li>
        </ul>
        
        <p class="academic-text">These properties help you choose the right algorithms and understand what's possible with your graph. Next up: <strong>Trees</strong> - the most important special case of graphs!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch3">
        
    <div class="chapter-number">Chapter 3</div>
    <h1 class="chapter-title">Trees — The Simplest Graphs</h1>
    
    <div class="definition-box">
        "Trees are everywhere - from your family tree to your computer's file system. They're the most useful special case of graphs."
    </div>

    <p class="academic-text">Trees represent one of the most elegant and powerful structures in computer science - they're connected graphs with no cycles, creating a perfect balance of structure and simplicity that makes them indispensable for organizing, searching, and processing hierarchical data. This seemingly simple constraint - being connected yet acyclic - gives trees remarkable mathematical properties and makes them the foundation for countless algorithms and data structures.</p>
    
    <p class="academic-text">The beauty of trees lies in their natural ability to model hierarchical relationships that pervade both the digital and physical world. Unlike general graphs where relationships can be complex and multidirectional, trees impose a clear structure: there's exactly one path between any two nodes, creating unambiguous parent-child relationships that mirror how we naturally think about organization, classification, and decision-making processes.</p>

    <p class="academic-text">Trees are fundamental to computer science because they solve the critical problem of organizing data in ways that enable efficient searching, sorting, and retrieval. They provide the mathematical foundation for databases, file systems, compilers, artificial intelligence, and countless other applications. Understanding trees is essential because they appear everywhere - from the simple decision trees that power recommendation algorithms to the complex B-trees that make database queries lightning-fast.</p>
    
    <p class="academic-text"><strong>Trees surround you in daily digital life:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>File systems:</strong> Every folder and file on your computer forms a tree structure, enabling efficient navigation and organization of millions of files</li>
        <li class="academic-text"><strong>Family genealogy:</strong> Ancestry relationships naturally form trees, allowing us to trace lineage and understand genetic inheritance patterns</li>
        <li class="academic-text"><strong>Corporate hierarchies:</strong> Organization charts use tree structures to define reporting relationships and decision-making authority</li>
        <li class="academic-text"><strong>Decision processes:</strong> From medical diagnosis to financial planning, decision trees help break complex choices into manageable, sequential decisions</li>
        <li class="academic-text"><strong>Web technologies:</strong> HTML DOM structures, XML documents, and JSON data all use tree formats for organizing and parsing information</li>
        <li class="academic-text"><strong>Search engines:</strong> Google's search algorithms use tree structures to index and rapidly retrieve information from billions of web pages</li>
    </ul>

    <h2 class="section-title" id="ch3-1">3.1 Tree Properties and Terminology</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌳 Tree Definition</h3>
        <p class="academic-text">A <strong>tree</strong> is a connected graph with no cycles.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Connected:</strong> You can reach any node from any other node</li>
            <li class="academic-text"><strong>Acyclic:</strong> No circular paths - there's exactly one path between any two nodes</li>
            <li class="academic-text"><strong>Minimal:</strong> Remove any edge and it becomes disconnected</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>The mathematical elegance of trees:</strong> The simple definition of trees as connected acyclic graphs leads to a cascade of remarkable mathematical properties that make them incredibly useful and predictable. These properties aren't just theoretical curiosities - they're the foundation for designing efficient algorithms and understanding why trees work so well for organizing data.</p>

    <p class="academic-text">Understanding these properties is crucial because they tell us exactly what we can expect from any tree structure, regardless of its size or application. They provide guarantees about connectivity, uniqueness of paths, and structural constraints that algorithms can rely on. This predictability is what makes trees so powerful for computer science applications.</p>
    
    <p class="academic-text"><strong>Fundamental tree properties with profound implications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Exact edge count:</strong> A tree with n vertices has exactly n-1 edges - no more, no less. This precise relationship means trees are "minimally connected" - they have just enough edges to stay connected, with no redundancy.</li>
        <li class="academic-text"><strong>Unique path property:</strong> There's exactly one path between any two vertices. This eliminates ambiguity in navigation and makes algorithms deterministic - there's never a question about which route to take.</li>
        <li class="academic-text"><strong>Cycle creation:</strong> Adding any single edge to a tree creates exactly one cycle. This property is fundamental to algorithms that build minimum spanning trees and detect when graphs become cyclic.</li>
        <li class="academic-text"><strong>Fragility property:</strong> Removing any edge disconnects the tree into exactly two components. This makes trees vulnerable to edge failures but also enables efficient tree-cutting algorithms.</li>
        <li class="academic-text"><strong>Minimality:</strong> Trees are minimal connected graphs - you can't remove any edge without losing connectivity, making them the most efficient way to connect n vertices.</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Example (Family Tree):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Grandpa] --> B[Dad]
            A --> C[Uncle]
            B --> D[You]
            B --> E[Sister]
            C --> F[Cousin]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">6 nodes, 5 edges - exactly n-1 edges for n nodes!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A tree is a connected acyclic graph. For n vertices, it has exactly n-1 edges.
        </div>
    </div>

    <p class="academic-text"><strong>Tree Terminology:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Root:</strong> The top node (Grandpa in our example)</li>
        <li class="academic-text"><strong>Parent:</strong> Node directly above (Dad is parent of You)</li>
        <li class="academic-text"><strong>Child:</strong> Node directly below (You are child of Dad)</li>
        <li class="academic-text"><strong>Leaf:</strong> Node with no children (You, Sister, Cousin)</li>
        <li class="academic-text"><strong>Height:</strong> Longest path from root to leaf (3 levels)</li>
        <li class="academic-text"><strong>Depth:</strong> Distance from root to a node</li>
    </ul>

    <pre class="code-block">// Simple Node structure
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple node - just holds data and connections
struct Node {
    string data;
    vector<Node*> children;
    
    Node(string value) : data(value) {}
};

// Tree builder functions
class TreeBuilder {
public:
    // Create a simple family tree from arrays
    static Node* buildFamilyTree() {
        Node* grandpa = new Node("Grandpa");
        Node* dad = new Node("Dad");
        Node* uncle = new Node("Uncle");
        Node* you = new Node("You");
        Node* sister = new Node("Sister");
        Node* cousin = new Node("Cousin");
        
        // Build the tree structure
        grandpa->children = {dad, uncle};
        dad->children = {you, sister};
        uncle->children = {cousin};
        
        return grandpa;
    }
    
    // Build tree from parent-child pairs
    static Node* buildFromPairs(vector<pair<string, string>> relationships) {
        // relationships = {("parent", "child"), ("parent", "child2"), ...}
        // Implementation would map relationships to tree structure
        // Simplified for clarity
        return nullptr;
    }
    
    // Print tree in a simple way
    static void printTree(Node* root, int indent = 0) {
        if (root == nullptr) return;
        
        for (int i = 0; i < indent; i++) cout << "  ";
        cout << root->data << endl;
        
        for (Node* child : root->children) {
            printTree(child, indent + 1);
        }
    }
    
    // Check if node is a leaf (no children)
    static bool isLeaf(Node* node) {
        return node->children.empty();
    }
};</pre>

    <h2 class="section-title" id="ch3-2">3.2 Binary Trees, N-ary Trees, Binary Search Trees</h2>

    <p class="academic-text"><strong>Binary Trees: The Foundation of Efficient Data Structures</strong></p>
    <p class="academic-text">Binary trees represent one of the most important and versatile data structures in computer science. By restricting each node to have at most two children - conventionally called "left" and "right" - binary trees create a perfect balance between simplicity and power. This constraint enables elegant recursive algorithms and provides the foundation for numerous advanced data structures including heaps, AVL trees, and red-black trees.</p>

    <p class="academic-text">The power of binary trees lies in their recursive structure: every subtree of a binary tree is itself a binary tree. This self-similarity makes them perfect for divide-and-conquer algorithms and enables elegant recursive solutions to complex problems. The binary constraint also ensures that tree operations have predictable performance characteristics, especially when the tree is balanced.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[A] --> B[B]
            A --> C[C]
            B --> D[D]
            B --> E[E]
            C --> F[F]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each node has at most 2 children</p>
    </div>

    <p class="academic-text"><strong>Binary Search Trees: Ordered Structures for Logarithmic Performance</strong></p>
    <p class="academic-text">Binary Search Trees (BSTs) represent one of the most elegant solutions to the fundamental problem of maintaining sorted data while enabling fast insertion, deletion, and search operations. By imposing a simple ordering constraint - left child < parent < right child - BSTs transform the linear search problem into a logarithmic one, dramatically improving performance for large datasets.</p>

    <p class="academic-text">The genius of BSTs lies in how they maintain order through structure rather than explicit sorting. Every insertion and search operation uses the ordering property to eliminate half of the remaining possibilities at each step, creating the same efficiency as binary search but in a dynamic structure that can grow and shrink. This makes BSTs perfect for applications like databases, symbol tables, and any system that needs to maintain sorted collections with frequent updates.</p>

    <p class="academic-text">The ordering property also enables powerful operations like finding minimum/maximum elements, predecessor/successor queries, and range searches - all with excellent performance characteristics. When balanced, BSTs provide O(log n) performance for all major operations, making them competitive with the best sorting and searching algorithms.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Binary Search Tree Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[50] --> B[30]
            A --> C[70]
            B --> D[20]
            B --> E[40]
            C --> F[60]
            C --> G[80]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Left < Parent < Right rule makes searching O(log n)</p>
    </div>

    <pre class="code-block">// Simple Binary Search Tree
#include <iostream>
using namespace std;

// Simple binary node
struct BinaryNode {
    int data;
    BinaryNode* left;
    BinaryNode* right;
    
    BinaryNode(int value) : data(value), left(nullptr), right(nullptr) {}
};

// BST helper functions
class BST {
public:
    // Build a sample BST
    static BinaryNode* buildSampleBST() {
        BinaryNode* root = new BinaryNode(50);
        root->left = new BinaryNode(30);
        root->right = new BinaryNode(70);
        root->left->left = new BinaryNode(20);
        root->left->right = new BinaryNode(40);
        root->right->left = new BinaryNode(60);
        root->right->right = new BinaryNode(80);
        return root;
    }
    
    // Simple search function
    static bool search(BinaryNode* root, int target) {
        if (root == nullptr) return false;
        if (root->data == target) return true;
        
        if (target < root->data) {
            return search(root->left, target);
        } else {
            return search(root->right, target);
        }
    }
    
    // Insert a new value
    static BinaryNode* insert(BinaryNode* root, int value) {
        if (root == nullptr) {
            return new BinaryNode(value);
        }
        
        if (value < root->data) {
            root->left = insert(root->left, value);
        } else if (value > root->data) {
            root->right = insert(root->right, value);
        }
        return root;
    }
    
    // Print in sorted order
    static void printInOrder(BinaryNode* root) {
        if (root != nullptr) {
            printInOrder(root->left);
            cout << root->data << " ";
            printInOrder(root->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-3">3.3 Tree Traversals: Different Ways to Visit Nodes</h2>

    <p class="academic-text">Tree traversal represents one of the most fundamental operations in computer science - systematically visiting every node in a tree structure. The order in which we visit nodes profoundly affects what we can accomplish, from copying trees to evaluating expressions to processing hierarchical data. Understanding different traversal patterns is essential because each serves specific algorithmic purposes and reveals different aspects of the tree's structure.</p>

    <p class="academic-text">The four main traversal patterns - preorder, inorder, postorder, and level-order - each provide a different perspective on the tree's data. Preorder traversal processes parents before children, making it perfect for copying or serializing tree structures. Inorder traversal visits nodes in sorted order for BSTs, enabling efficient data retrieval. Postorder traversal processes children before parents, ideal for cleanup operations and calculating aggregate values. Level-order traversal processes nodes by depth, perfect for breadth-first analysis and finding shortest paths.</p>

    <p class="academic-text">These traversal patterns form the building blocks for countless tree algorithms. Compilers use traversals to parse and evaluate expressions, file systems use them to calculate directory sizes, and search algorithms use them to explore solution spaces. Mastering tree traversals is crucial because they provide the systematic approach needed to solve complex problems on hierarchical data.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Tree Traversal Orders:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[2]
            A --> C[3]
            B --> D[4]
            B --> E[5]
            C --> F[6]
            C --> G[7]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">
            <strong>Preorder:</strong> 1, 2, 4, 5, 3, 6, 7 (Root first)<br>
            <strong>Inorder:</strong> 4, 2, 5, 1, 6, 3, 7 (Left, Root, Right)<br>
            <strong>Postorder:</strong> 4, 5, 2, 6, 7, 3, 1 (Root last)<br>
            <strong>Level-order:</strong> 1, 2, 3, 4, 5, 6, 7 (Level by level)
        </p>
    </div>

    <p class="academic-text"><strong>When to Use Each Traversal:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Preorder:</strong> Copy/clone tree, prefix expressions</li>
        <li class="academic-text"><strong>Inorder:</strong> Get sorted order from BST</li>
        <li class="academic-text"><strong>Postorder:</strong> Delete tree, calculate directory sizes</li>
        <li class="academic-text"><strong>Level-order:</strong> Print tree level by level, shortest path</li>
    </ul>

    <pre class="code-block">// Simple tree traversal functions
#include <iostream>
#include <queue>
using namespace std;

class TreeTraversal {
public:
    // Preorder: Root -> Left -> Right
    static void preorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        cout << node->data << " ";  // Visit root first
        preorder(node->left);       // Then left subtree
        preorder(node->right);      // Then right subtree
    }
    
    // Inorder: Left -> Root -> Right (gives sorted order for BST)
    static void inorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        inorder(node->left);        // Visit left subtree first
        cout << node->data << " ";  // Then root
        inorder(node->right);       // Then right subtree
    }
    
    // Postorder: Left -> Right -> Root
    static void postorder(BinaryNode* node) {
        if (node == nullptr) return;
        
        postorder(node->left);      // Visit left subtree first
        postorder(node->right);     // Then right subtree
        cout << node->data << " ";  // Then root last
    }
    
    // Level-order: Visit level by level using queue
    static void levelOrder(BinaryNode* root) {
        if (root == nullptr) return;
        
        queue<BinaryNode*> q;
        q.push(root);
        
        while (!q.empty()) {
            BinaryNode* current = q.front();
            q.pop();
            
            cout << current->data << " ";
            
            if (current->left) q.push(current->left);
            if (current->right) q.push(current->right);
        }
    }
};</pre>

    <h2 class="section-title" id="ch3-4">3.4 Applications in File Systems and Hierarchies</h2>

    <p class="academic-text">Trees aren't just abstract data structures - they're the invisible backbone of the digital systems you interact with every day. From the moment you boot your computer to browsing the web to organizing your photos, tree structures are working behind the scenes to organize, search, and manage information efficiently. Understanding these real-world applications helps you see why trees are so fundamental to computer science.</p>

    <p class="academic-text"><strong>File Systems: The Universal Tree Application</strong></p>
    <p class="academic-text">Every modern computer's file system is built on tree structure, creating a hierarchical organization that mirrors how humans naturally think about containment and categorization. Directories (folders) serve as internal nodes that can contain other directories or files, while files themselves are leaf nodes that contain actual data. This tree structure enables efficient navigation, prevents circular references, and provides a clear path to every file in the system.</p>

    <p class="academic-text">The tree structure of file systems isn't just convenient - it's essential for performance and organization. It enables efficient path resolution (finding files by their full path), supports recursive operations (like calculating directory sizes), and provides the foundation for file permissions, backup systems, and search indexing. Without tree structure, managing millions of files would be chaotic and inefficient.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>File System Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[/] --> B[home]
            A --> C[usr]
            A --> D[var]
            B --> E[user1]
            B --> F[user2]
            E --> G[Documents]
            E --> H[Pictures]
            G --> I[resume.pdf]
            G --> J[notes.txt]
            H --> K[vacation.jpg]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#ffebee,stroke:#f44336,stroke-width:2px
            style H fill:#ffebee,stroke:#f44336,stroke-width:2px
            style I fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
            style J fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
            style K fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Each path from root to file is unique - no cycles!</p>
    </div>

    <pre class="code-block">// Simple file system tree
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple file/folder node
struct FileNode {
    string name;
    bool isFile;
    vector<FileNode*> children;
    int size; // for files only
    
    FileNode(string n, bool file = false, int s = 0) 
        : name(n), isFile(file), size(s) {}
};

class FileSystem {
public:
    // Build a sample file system
    static FileNode* buildSampleFileSystem() {
        FileNode* root = new FileNode("/", false);
        FileNode* home = new FileNode("home", false);
        FileNode* user = new FileNode("user1", false);
        FileNode* docs = new FileNode("Documents", false);
        FileNode* pics = new FileNode("Pictures", false);
        
        FileNode* resume = new FileNode("resume.pdf", true, 1024);
        FileNode* notes = new FileNode("notes.txt", true, 512);
        FileNode* photo = new FileNode("vacation.jpg", true, 2048);
        
        // Build the tree structure
        root->children = {home};
        home->children = {user};
        user->children = {docs, pics};
        docs->children = {resume, notes};
        pics->children = {photo};
        
        return root;
    }
    
    // Print file system tree
    static void printFileSystem(FileNode* root, int indent = 0) {
        if (root == nullptr) return;
        
        for (int i = 0; i < indent; i++) cout << "  ";
        cout << root->name;
        if (root->isFile) {
            cout << " (" << root->size << " bytes)";
        } else {
            cout << "/";
        }
        cout << endl;
        
        for (FileNode* child : root->children) {
            printFileSystem(child, indent + 1);
        }
    }
    
    // Calculate total directory size
    static int getTotalSize(FileNode* root) {
        if (root->isFile) return root->size;
        
        int total = 0;
        for (FileNode* child : root->children) {
            total += getTotalSize(child);
        }
        return total;
    }
};</pre>

    <p class="academic-text"><strong>Other Tree Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Organization Charts:</strong> Company hierarchy</li>
        <li class="academic-text"><strong>Decision Trees:</strong> AI and machine learning</li>
        <li class="academic-text"><strong>Parse Trees:</strong> Compilers and language processing</li>
        <li class="academic-text"><strong>Game Trees:</strong> Chess, tic-tac-toe game states</li>
        <li class="academic-text"><strong>Heap Trees:</strong> Priority queues (coming in Chapter 5!)</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🌳 Tree Properties Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Key Properties</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Connected + No cycles</li>
                    <li class="academic-text">n nodes = n-1 edges</li>
                    <li class="academic-text">Unique path between any two nodes</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Common Types</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Binary Tree (≤2 children)</li>
                    <li class="academic-text">BST (ordered binary tree)</li>
                    <li class="academic-text">N-ary Tree (any # children)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 3 Complete!</h3>
        <p class="academic-text">You now understand trees - the most important special graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Tree properties</strong> - connected, acyclic, n-1 edges</li>
            <li class="academic-text">✅ <strong>Binary trees & BSTs</strong> - organized for fast operations</li>
            <li class="academic-text">✅ <strong>Tree traversals</strong> - different ways to visit nodes</li>
            <li class="academic-text">✅ <strong>Real applications</strong> - file systems, hierarchies</li>
        </ul>
        
        <p class="academic-text">Trees are the foundation for many advanced data structures. Next: <strong>Tries</strong> - specialized trees for string processing!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch4">
        
    <div class="chapter-number">Chapter 4</div>
    <h1 class="chapter-title">Tries and Prefix Structures</h1>
    
    <div class="definition-box">
        "Tries are the secret behind autocomplete, spell checkers, and fast string searches. They're trees specialized for text!"
    </div>

    <p class="academic-text">Ever wonder how your smartphone can predict entire words after you type just a few letters? Or how Google can suggest millions of search queries in milliseconds as you type? The secret behind these seemingly magical text prediction systems is an elegant data structure called a <strong>trie</strong> (pronounced "try" - from "reTRIEval"). Tries represent one of the most specialized and powerful applications of tree structures, designed specifically to solve the complex challenges of text processing, string matching, and prefix-based operations.</p>
    
    <p class="academic-text">Tries revolutionize text processing by exploiting a fundamental property of human language: words often share common prefixes. Instead of storing each word independently, tries create a shared tree structure where common beginnings are stored only once. This elegant approach not only saves enormous amounts of memory but also enables lightning-fast prefix operations that would be impossible with traditional data structures. The result is a system that can handle millions of words while providing instant responses to text queries.</p>

    <p class="academic-text">The power of tries extends far beyond simple word storage. They enable sophisticated algorithms for autocomplete, spell checking, pattern matching, and even network routing. By organizing text data hierarchically based on character sequences, tries transform complex string problems into simple tree traversal operations. This makes them indispensable for any application that needs to process, search, or analyze text efficiently.</p>
    
    <p class="academic-text"><strong>Tries power the text technologies you use every day:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> Google's instant search suggestions analyze billions of queries using trie structures to predict what you're looking for before you finish typing</li>
        <li class="academic-text"><strong>Code editors:</strong> IDEs like VS Code use tries to provide instant autocomplete for variable names, function calls, and API methods across massive codebases</li>
        <li class="academic-text"><strong>Spell checkers:</strong> Word processors and browsers use tries containing entire dictionaries to instantly identify misspellings and suggest corrections</li>
        <li class="academic-text"><strong>Mobile keyboards:</strong> Smartphone keyboards use tries to enable predictive text, swipe typing, and multilingual input across thousands of languages</li>
        <li class="academic-text"><strong>Network routing:</strong> Internet routers use tries to match IP addresses and efficiently route data packets across the global internet infrastructure</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> DNA sequence analysis uses tries to identify genetic patterns and mutations in massive genomic databases</li>
    </ul>

    <h2 class="section-title" id="ch4-1">4.1 Trie Data Structure and Operations</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔤 Trie Definition</h3>
        <p class="academic-text">A <strong>trie</strong> (prefix tree) is a tree where each path from root represents a string, and each node represents a character.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path = Word:</strong> Each root-to-node path spells out a prefix or complete word</li>
            <li class="academic-text"><strong>Shared Prefixes:</strong> Words with common beginnings share the same path</li>
            <li class="academic-text"><strong>Marked Endings:</strong> Special markers indicate where complete words end</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>The brilliance of trie design:</strong> Tries achieve remarkable efficiency by recognizing that human language is inherently hierarchical. Words like "CAR", "CARD", "CARE", and "CAREFUL" don't need to be stored as separate entities - they can share the common "CAR" prefix in the tree structure. This sharing principle scales beautifully: a trie containing a million English words might share thousands of common prefixes, dramatically reducing memory usage while simultaneously speeding up search operations.</p>

    <p class="academic-text">The mathematical elegance of tries lies in how they transform string operations from linear searches into tree traversals. Finding a word becomes a simple path-following operation, where each character guides you to the next level of the tree. This approach guarantees that search time depends only on the length of the word being searched, not on how many words are stored in the trie - a remarkable property that enables tries to scale to enormous datasets.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Trie Example (Words: CAT, CAR, CARD, CARE, CAREFUL):</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D[D*]
            R --> E[E*]
            E --> F[F]
            F --> U[U]
            U --> L[L*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style A fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style R fill:#ffebee,stroke:#f44336,stroke-width:3px
            style D fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style E fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style F fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style U fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style L fill:#f1f8e9,stroke:#8bc34a,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">* marks end of word. Path ROOT→C→A→T spells "CAT"</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A trie is a tree data structure where each node represents a character and each path from root to a marked node represents a stored string.
        </div>
    </div>

    <p class="academic-text"><strong>Why Tries Are Amazing:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Shared prefixes:</strong> "CAR", "CARD", "CARE" share the path C→A→R</li>
        <li class="academic-text"><strong>Fast lookup:</strong> Find any word in O(word length) time</li>
        <li class="academic-text"><strong>Prefix magic:</strong> Find all words starting with "CA" instantly</li>
        <li class="academic-text"><strong>Memory efficient:</strong> Common prefixes stored only once</li>
    </ul>

    <pre class="code-block">// Simple Trie implementation
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Simple trie node
struct TrieNode {
    vector<TrieNode*> children;
    bool isEndOfWord;
    char character;
    
    TrieNode(char c = '\0') : character(c), isEndOfWord(false) {
        children.resize(26, nullptr); // for a-z
    }
};

class SimpleTrie {
private:
    TrieNode* root;
    
    int charToIndex(char c) {
        return c - 'a'; // convert 'a' to 0, 'b' to 1, etc.
    }
    
public:
    SimpleTrie() {
        root = new TrieNode();
    }
    
    // Insert a word into the trie
    void insert(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            
            if (current->children[index] == nullptr) {
                current->children[index] = new TrieNode(c);
            }
            current = current->children[index];
        }
        current->isEndOfWord = true;
    }
    
    // Search for a word
    bool search(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return current->isEndOfWord;
    }
    
    // Check if any word starts with this prefix
    bool startsWith(string prefix) {
        TrieNode* current = root;
        
        for (char c : prefix) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return true; // We found the complete prefix path
    }
    
    // Build a sample trie with common words
    static SimpleTrie* buildSampleTrie() {
        SimpleTrie* trie = new SimpleTrie();
        vector<string> words = {"cat", "car", "card", "care", "careful", "dog", "dodge"};
        
        for (string word : words) {
            trie->insert(word);
        }
        return trie;
    }
};</pre>

    <h2 class="section-title" id="ch4-2">4.2 String Searching and Autocomplete Systems</h2>

    <p class="academic-text"><strong>Autocomplete: The Art of Prediction</strong></p>
    <p class="academic-text">Autocomplete represents one of the most impressive applications of tries, transforming the simple act of typing into an intelligent conversation between human and machine. When you type "ca" and instantly see suggestions like "cat", "car", "care", you're witnessing a sophisticated algorithm that traverses a trie structure to find all possible completions of your partial input. This seemingly simple feature requires complex engineering to handle millions of words, rank suggestions by relevance, and respond in milliseconds.</p>

    <p class="academic-text">The magic of autocomplete lies in how tries make prefix matching trivial. Instead of scanning through entire dictionaries to find words that start with "ca", the system simply follows the path C→A in the trie and then explores all branches below that point. Every path from that node to a word ending represents a valid completion. This approach scales beautifully - whether you're searching through a hundred words or a hundred million, the time to find all completions depends only on the length of your prefix and the number of matching results.</p>

    <p class="academic-text">Modern autocomplete systems extend this basic concept with sophisticated ranking algorithms, personalization, and context awareness. They might prioritize frequently used words, consider your typing history, or even predict entire phrases based on patterns in your communication. But at the core, they all rely on the fundamental efficiency of trie-based prefix matching.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Autocomplete Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            Root --> D[D]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D1[D*]
            R --> E[E*]
            D --> O[O]
            O --> G[G*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#ffeb3b,stroke:#333,stroke-width:4px
            style A fill:#ffeb3b,stroke:#333,stroke-width:4px
            style T fill:#ff9800,stroke:#333,stroke-width:2px
            style R fill:#ff9800,stroke:#333,stroke-width:2px
            style D1 fill:#ff9800,stroke:#333,stroke-width:2px
            style E fill:#ff9800,stroke:#333,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style O fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style G fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">User types "CA" → Highlighted path shows all words starting with "CA": CAT, CAR, CARD, CARE</p>
    </div>

    <p class="academic-text"><strong>How Autocomplete Works:</strong></p>
    <ol style="margin: 8px 0 16px 24px;">
        <li class="academic-text">User types a prefix (like "ca")</li>
        <li class="academic-text">Find the node representing that prefix in the trie</li>
        <li class="academic-text">Collect all complete words in the subtree below that node</li>
        <li class="academic-text">Return the suggestions to the user</li>
    </ol>

    <pre class="code-block">// Autocomplete system using trie
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class AutoComplete {
private:
    SimpleTrie* trie;
    
    // Helper function to collect all words from a node
    void collectWords(TrieNode* node, string currentWord, vector<string>& results) {
        if (node == nullptr) return;
        
        if (node->isEndOfWord) {
            results.push_back(currentWord);
        }
        
        for (int i = 0; i < 26; i++) {
            if (node->children[i] != nullptr) {
                char nextChar = 'a' + i;
                collectWords(node->children[i], currentWord + nextChar, results);
            }
        }
    }
    
    // Find the node representing a prefix
    TrieNode* findPrefixNode(string prefix) {
        TrieNode* current = trie->root;
        
        for (char c : prefix) {
            int index = c - 'a';
            if (current->children[index] == nullptr) {
                return nullptr; // Prefix not found
            }
            current = current->children[index];
        }
        return current;
    }
    
public:
    AutoComplete() {
        trie = SimpleTrie::buildSampleTrie();
    }
    
    // Get autocomplete suggestions for a prefix
    vector<string> getSuggestions(string prefix) {
        vector<string> suggestions;
        
        TrieNode* prefixNode = findPrefixNode(prefix);
        if (prefixNode == nullptr) {
            return suggestions; // No words with this prefix
        }
        
        collectWords(prefixNode, prefix, suggestions);
        return suggestions;
    }
    
    // Add a new word to the dictionary
    void addWord(string word) {
        trie->insert(word);
    }
    
    // Demo function
    static void demo() {
        AutoComplete ac;
        
        cout << "Autocomplete Demo:" << endl;
        vector<string> prefixes = {"ca", "car", "d"};
        
        for (string prefix : prefixes) {
            cout << "Typing '" << prefix << "' suggests: ";
            vector<string> suggestions = ac.getSuggestions(prefix);
            
            for (string suggestion : suggestions) {
                cout << suggestion << " ";
            }
            cout << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch4-3">4.3 Applications: Spell Checkers, Dictionaries, IP Routing</h2>

    <p class="academic-text">The versatility of tries extends far beyond autocomplete, powering a remarkable range of applications that touch nearly every aspect of modern computing. From the spell checker that catches your typos to the routers that deliver this webpage to your device, tries provide the algorithmic foundation for systems that process, analyze, and route text-based information at massive scale.</p>

    <p class="academic-text"><strong>1. Spell Checkers: Intelligent Error Detection and Correction</strong></p>
    <p class="academic-text">Modern spell checkers represent sophisticated applications of trie technology that go far beyond simple dictionary lookups. When you misspell "receive" as "recieve", the spell checker doesn't just identify the error - it uses advanced algorithms to generate plausible corrections by systematically exploring variations of your input. The system might try inserting, deleting, or substituting characters to find words in its trie-based dictionary that are "close" to your misspelling.</p>

    <p class="academic-text">The power of trie-based spell checking lies in its ability to efficiently explore the space of possible corrections. Instead of generating every possible variation of a misspelled word and checking each one individually, sophisticated spell checkers can traverse the trie while simultaneously considering multiple types of errors. This enables them to find corrections quickly even for severely mangled words, while ranking suggestions based on factors like edit distance, word frequency, and contextual appropriateness.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Spell Checker Strategy:</strong><br><br>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dictionary trie:</strong> Contains all correct words</li>
            <li class="academic-text"><strong>Check word:</strong> Search in trie - if not found, it's misspelled</li>
            <li class="academic-text"><strong>Find suggestions:</strong> Try small changes (add/remove/change letters)</li>
            <li class="academic-text"><strong>Rank suggestions:</strong> Prefer words with similar prefixes</li>
        </ul>
    </div>

    <p class="academic-text"><strong>2. IP Address Routing: The Internet's Navigation System</strong></p>
    <p class="academic-text">One of the most critical and fascinating applications of tries operates invisibly behind every webpage you visit, every email you send, and every video you stream. Internet routers use specialized tries called "routing tables" to make split-second decisions about where to forward your data packets across the global network. When you request a webpage, your data must traverse multiple routers, each using trie-based algorithms to determine the optimal next hop toward the destination.</p>

    <p class="academic-text">IP routing tries work by treating IP addresses as strings of binary digits, creating a tree where each level represents one bit of the address. This binary trie structure enables routers to perform longest prefix matching - finding the most specific route available for any given destination. The beauty of this system lies in its scalability: even as the internet grows to billions of devices, routers can make forwarding decisions in constant time by following a path through their routing trie.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>IP Routing Trie Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> Zero[0]
            Root --> One[1]
            Zero --> Z0[0]
            Zero --> Z1[1]
            One --> O0[0]
            One --> O1[1]
            Z0 --> Route1[Route A*]
            Z1 --> Route2[Route B*]
            O0 --> Route3[Route C*]
            O1 --> Route4[Route D*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style Zero fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style One fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style Z0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Z1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Route1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route2 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route3 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route4 fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">IP 192.168.1.1 → Binary 11000000... → Follow path 1→1→0→0... to find route</p>
    </div>

    <pre class="code-block">// Simple spell checker using trie
#include <iostream>
#include <vector>
#include <string>
#include <set>
using namespace std;

class SpellChecker {
private:
    SimpleTrie* dictionary;
    
    // Generate words with one character changed
    set<string> generateEdits(string word) {
        set<string> edits;
        
        // Try changing each character
        for (int i = 0; i < word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                if (c != word[i]) {
                    string edited = word;
                    edited[i] = c;
                    edits.insert(edited);
                }
            }
        }
        
        // Try removing each character
        for (int i = 0; i < word.length(); i++) {
            string edited = word.substr(0, i) + word.substr(i + 1);
            edits.insert(edited);
        }
        
        // Try adding a character at each position
        for (int i = 0; i <= word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                string edited = word.substr(0, i) + c + word.substr(i);
                edits.insert(edited);
            }
        }
        
        return edits;
    }
    
public:
    SpellChecker() {
        dictionary = SimpleTrie::buildSampleTrie();
        // Add more common words
        dictionary->insert("hello");
        dictionary->insert("world");
        dictionary->insert("computer");
        dictionary->insert("science");
    }
    
    // Check if word is spelled correctly
    bool isCorrect(string word) {
        return dictionary->search(word);
    }
    
    // Get spelling suggestions
    vector<string> getSuggestions(string misspelledWord) {
        vector<string> suggestions;
        
        if (isCorrect(misspelledWord)) {
            return suggestions; // Word is already correct
        }
        
        set<string> possibleEdits = generateEdits(misspelledWord);
        
        for (string edit : possibleEdits) {
            if (dictionary->search(edit)) {
                suggestions.push_back(edit);
            }
        }
        
        return suggestions;
    }
    
    // Demo function
    static void demo() {
        SpellChecker checker;
        
        cout << "Spell Checker Demo:" << endl;
        vector<string> testWords = {"cat", "cta", "carr", "carefull"};
        
        for (string word : testWords) {
            if (checker.isCorrect(word)) {
                cout << "'" << word << "' is spelled correctly!" << endl;
            } else {
                cout << "'" << word << "' is misspelled. Suggestions: ";
                vector<string> suggestions = checker.getSuggestions(word);
                for (string suggestion : suggestions) {
                    cout << suggestion << " ";
                }
                cout << endl;
            }
        }
    }
};</pre>

    <p class="academic-text"><strong>Other Amazing Trie Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Search Engines:</strong> Google uses tries for query suggestions</li>
        <li class="academic-text"><strong>Code Editors:</strong> Autocomplete for variable names and functions</li>
        <li class="academic-text"><strong>Phone Contacts:</strong> T9 predictive text on old phones</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> DNA sequence matching</li>
        <li class="academic-text"><strong>Compression:</strong> Finding repeated patterns in text</li>
        <li class="academic-text"><strong>Games:</strong> Word games like Scrabble and Boggle</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🔤 Trie Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Search:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Prefix check:</strong> O(prefix length)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Shared prefixes save memory</li>
                    <li class="academic-text">Fast prefix operations</li>
                    <li class="academic-text">Natural autocomplete structure</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 4 Complete!</h3>
        <p class="academic-text">You now understand tries - specialized trees for text processing:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Trie structure</strong> - character nodes forming word paths</li>
            <li class="academic-text">✅ <strong>Core operations</strong> - insert, search, prefix checking</li>
            <li class="academic-text">✅ <strong>Autocomplete systems</strong> - how suggestions work</li>
            <li class="academic-text">✅ <strong>Real applications</strong> - spell checkers, routing, search engines</li>
        </ul>
        
        <p class="academic-text">Tries show how specialized data structures solve specific problems elegantly. Next: <strong>Heaps</strong> - trees optimized for priority and ordering!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch5">
        
    <div class="chapter-number">Chapter 5</div>
    <h1 class="chapter-title">Heaps and Priority Structures</h1>
    
    <div class="definition-box">
        "Heaps are the secret sauce behind priority queues, efficient sorting, and many graph algorithms like Dijkstra's shortest path!"
    </div>

    <p class="academic-text">Imagine you're managing a hospital emergency room where life-and-death decisions happen every second. You can't treat patients in the order they arrive - you must prioritize based on the severity of their condition. A heart attack patient takes precedence over a broken finger, regardless of who arrived first. This is exactly the problem that heaps solve with mathematical precision: maintaining dynamic priority order while enabling efficient insertion, removal, and access to the most important element.</p>
    
    <p class="academic-text">Heaps represent one of the most ingenious applications of tree structure, solving the fundamental challenge of priority management that appears throughout computer science. Unlike general trees that organize data hierarchically, or tries that optimize for string operations, heaps are laser-focused on one critical task: ensuring that the most important element is always instantly accessible at the root, while maintaining this property efficiently as elements are added and removed.</p>

    <p class="academic-text">The brilliance of heaps lies in their elegant balance between simplicity and power. By imposing a simple ordering constraint - parents must be greater than (or less than) their children - heaps create a structure that guarantees O(log n) insertion and removal while providing O(1) access to the priority element. This combination of properties makes heaps indispensable for algorithms that need to repeatedly process elements in priority order.</p>
    
    <p class="academic-text"><strong>Heaps are the invisible engines powering critical systems around you:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Operating systems:</strong> Every modern OS uses heap-based priority queues to schedule processes, ensuring critical system tasks get CPU time before less important applications</li>
        <li class="academic-text"><strong>Network infrastructure:</strong> Internet routers use heaps to prioritize packet transmission, ensuring video calls and emergency communications get priority over file downloads</li>
        <li class="academic-text"><strong>Graph algorithms:</strong> Dijkstra's shortest path algorithm relies on heaps to efficiently find optimal routes in GPS navigation and network routing protocols</li>
        <li class="academic-text"><strong>Event-driven systems:</strong> Simulation engines and game systems use heaps to process events in chronological order, maintaining causality in complex systems</li>
        <li class="academic-text"><strong>Data compression:</strong> Huffman coding algorithms use heaps to build optimal compression trees, reducing file sizes for everything from images to videos</li>
        <li class="academic-text"><strong>Database systems:</strong> Query optimizers use heaps to efficiently sort and merge large datasets, enabling fast database operations on millions of records</li>
    </ul>

    <h2 class="section-title" id="ch5-1">5.1 Heap Properties: Min-Heap and Max-Heap</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🏄 Heap Definition</h3>
        <p class="academic-text">A <strong>heap</strong> is a complete binary tree with the heap property: every parent node has a specific ordering relationship with its children.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Complete binary tree:</strong> All levels filled except possibly the last (filled left to right)</li>
            <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
            <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Two types of heaps:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Min-heap:</strong> Parent ≤ children (smallest at top)</li>
        <li class="academic-text"><strong>Max-heap:</strong> Parent ≥ children (largest at top)</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Heap Example (Smallest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[3]
            A --> C[2]
            B --> D[7]
            B --> E[8]
            C --> F[5]
            C --> G[4]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ≤ Children: 1≤3,2 | 3≤7,8 | 2≤5,4</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A min-heap is a complete binary tree where every parent node has a value ≤ its children.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Max-Heap Example (Largest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[10] --> B[8]
            A --> C[9]
            B --> D[4]
            B --> E[7]
            C --> F[5]
            C --> G[6]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ≥ Children: 10≥8,9 | 8≥4,7 | 9≥5,6</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A max-heap is a complete binary tree where every parent node has a value ≥ its children.
        </div>
    </div>

    <p class="academic-text"><strong>Key Heap Properties:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Complete tree:</strong> All levels filled except possibly the last (filled left to right)</li>
        <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
        <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        <li class="academic-text"><strong>Array representation:</strong> Can be stored efficiently in an array</li>
    </ul>

    <pre class="code-block">// Simple heap implementation using array
#include <iostream>
#include <vector>
using namespace std;

class MinHeap {
private:
    vector<int> heap;
    
    // Get parent, left child, right child indices
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    // Swap two elements
    void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
public:
    // Check if heap is empty
    bool isEmpty() {
        return heap.empty();
    }
    
    // Get the minimum element (root)
    int getMin() {
        if (isEmpty()) return -1;
        return heap[0];
    }
    
    // Get heap size
    int size() {
        return heap.size();
    }
    
    // Print heap as array
    void printHeap() {
        cout << "Heap: ";
        for (int val : heap) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    // Build a sample min-heap
    static MinHeap* buildSampleHeap() {
        MinHeap* h = new MinHeap();
        vector<int> values = {3, 7, 1, 8, 2, 5, 4};
        
        for (int val : values) {
            h->insert(val);
        }
        return h;
    }
};</pre>

    <h2 class="section-title" id="ch5-2">5.2 Heap Operations: Insert, Extract, Heapify</h2>

    <p class="academic-text"><strong>Insert: Adding New Elements</strong></p>
    <p class="academic-text">To insert into a heap: add at the end, then "bubble up" until heap property is restored.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Insert Process (Adding 1 to Min-Heap):</strong><br><br>
        <div class="mermaid">
        graph TD
            subgraph "Step 1: Add at end"
                A1[3] --> B1[7]
                A1 --> C1[5]
                B1 --> D1[8]
                B1 --> E1[1]
                
                style E1 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 2: Bubble up"
                A2[3] --> B2[1]
                A2 --> C2[5]
                B2 --> D2[8]
                B2 --> E2[7]
                
                style B2 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 3: Final result"
                A3[1] --> B3[3]
                A3 --> C3[5]
                B3 --> D3[8]
                B3 --> E3[7]
                
                style A3 fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            end
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">1 bubbles up: 1<7 (swap) → 1<3 (swap) → Done!</p>
    </div>

    <p class="academic-text"><strong>Extract: Removing the Root</strong></p>
    <p class="academic-text">To extract from a heap: remove root, move last element to root, then "bubble down".</p>

    <pre class="code-block">// Heap operations implementation
class MinHeap {
    // ... previous code ...
    
    // Bubble up to maintain heap property after insert
    void bubbleUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    // Bubble down to maintain heap property after extract
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        // Find the smallest among parent and children
        if (left < heap.size() && heap[left] < heap[minIndex]) {
            minIndex = left;
        }
        if (right < heap.size() && heap[right] < heap[minIndex]) {
            minIndex = right;
        }
        
        // If parent is not the smallest, swap and continue
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Insert a new element
    void insert(int value) {
        heap.push_back(value);
        bubbleUp(heap.size() - 1);
    }
    
    // Extract the minimum element
    int extractMin() {
        if (isEmpty()) return -1;
        
        int min = heap[0];
        
        // Move last element to root and remove last
        heap[0] = heap[heap.size() - 1];
        heap.pop_back();
        
        // Restore heap property
        if (!isEmpty()) {
            bubbleDown(0);
        }
        
        return min;
    }
    
    // Build heap from array (heapify)
    void buildHeap(vector<int> array) {
        heap = array;
        
        // Start from last non-leaf node and bubble down
        for (int i = (heap.size() / 2) - 1; i >= 0; i--) {
            bubbleDown(i);
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-3">5.3 Priority Queues and Applications</h2>

    <p class="academic-text"><strong>Priority Queue: The Heap's Superpower</strong></p>
    <p class="academic-text">A priority queue lets you always get the most important item first. Heaps make this super efficient!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Hospital Emergency Room Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Critical: 1] --> B[Urgent: 3]
            A --> C[Urgent: 2]
            B --> D[Standard: 7]
            B --> E[Standard: 5]
            C --> F[Standard: 4]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style E fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style F fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Lower numbers = higher priority. Critical patient (1) treated first!</p>
    </div>

    <p class="academic-text"><strong>Real-World Priority Queue Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Operating Systems:</strong> Process scheduling by priority</li>
        <li class="academic-text"><strong>Network Routing:</strong> Packet prioritization</li>
        <li class="academic-text"><strong>Game AI:</strong> Action selection by importance</li>
        <li class="academic-text"><strong>Graph Algorithms:</strong> Dijkstra's shortest path</li>
        <li class="academic-text"><strong>Event Simulation:</strong> Process events by time</li>
    </ul>

    <pre class="code-block">// Priority Queue using heap
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Task with priority
struct Task {
    string description;
    int priority;
    
    Task(string desc, int prio) : description(desc), priority(prio) {}
};

class PriorityQueue {
private:
    vector<Task> tasks;
    
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    void swap(int i, int j) {
        Task temp = tasks[i];
        tasks[i] = tasks[j];
        tasks[j] = temp;
    }
    
    void bubbleUp(int index) {
        while (index > 0 && tasks[parent(index)].priority > tasks[index].priority) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < tasks.size() && tasks[left].priority < tasks[minIndex].priority) {
            minIndex = left;
        }
        if (right < tasks.size() && tasks[right].priority < tasks[minIndex].priority) {
            minIndex = right;
        }
        
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Add task with priority
    void addTask(string description, int priority) {
        tasks.push_back(Task(description, priority));
        bubbleUp(tasks.size() - 1);
    }
    
    // Get highest priority task
    Task getNextTask() {
        if (tasks.empty()) return Task("No tasks", -1);
        
        Task nextTask = tasks[0];
        
        tasks[0] = tasks[tasks.size() - 1];
        tasks.pop_back();
        
        if (!tasks.empty()) {
            bubbleDown(0);
        }
        
        return nextTask;
    }
    
    bool isEmpty() {
        return tasks.empty();
    }
    
    // Demo function
    static void demo() {
        PriorityQueue pq;
        
        pq.addTask("Fix critical bug", 1);
        pq.addTask("Write documentation", 5);
        pq.addTask("Review code", 3);
        pq.addTask("Deploy to production", 2);
        pq.addTask("Update tests", 4);
        
        cout << "Tasks in priority order:" << endl;
        while (!pq.isEmpty()) {
            Task task = pq.getNextTask();
            cout << "Priority " << task.priority << ": " << task.description << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-4">5.4 Heap Sort and Graph Algorithm Preparation</h2>

    <p class="academic-text"><strong>Heap Sort: Sorting with Heaps</strong></p>
    <p class="academic-text">Heap sort uses a heap to sort efficiently: build a max-heap, then repeatedly extract the maximum!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Heap Sort Process:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Unsorted Array] --> B[Build Max-Heap]
            B --> C[Extract Max]
            C --> D[Place at End]
            D --> E[Heapify Remaining]
            E --> F{More Elements?}
            F -->|Yes| C
            F -->|No| G[Sorted Array]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style G fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">O(n log n) time complexity - efficient and in-place!</p>
    </div>

    <p class="academic-text"><strong>Heaps in Graph Algorithms</strong></p>
    <p class="academic-text">Heaps are crucial for many graph algorithms you'll learn next:</p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> Find shortest paths using min-heap</li>
        <li class="academic-text"><strong>Prim's Algorithm:</strong> Find minimum spanning tree</li>
        <li class="academic-text"><strong>A* Search:</strong> Pathfinding with priority queue</li>
        <li class="academic-text"><strong>Huffman Coding:</strong> Data compression using heaps</li>
    </ul>

    <pre class="code-block">// Heap Sort implementation
#include <iostream>
#include <vector>
using namespace std;

class HeapSort {
private:
    static void heapify(vector<int>& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        // Find largest among root and children
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // If largest is not root, swap and continue heapifying
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
    
public:
    static void sort(vector<int>& arr) {
        int n = arr.size();
        
        // Step 1: Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Step 2: Extract elements one by one
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            swap(arr[0], arr[i]);
            
            // Heapify the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    // Demo function
    static void demo() {
        vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
        
        cout << "Original array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
        
        sort(arr);
        
        cout << "Sorted array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
    }
};

// Graph algorithm preparation - Dijkstra's preview
class GraphAlgorithmPrep {
public:
    // Simple structure for graph edges with weights
    struct Edge {
        int to;
        int weight;
        
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    // Distance-node pair for priority queue
    struct DistanceNode {
        int distance;
        int node;
        
        DistanceNode(int d, int n) : distance(d), node(n) {}
        
        // For min-heap comparison
        bool operator>(const DistanceNode& other) const {
            return distance > other.distance;
        }
    };
    
    static void dijkstraPreview() {
        cout << "Coming up in Part II:" << endl;
        cout << "- Dijkstra's algorithm will use min-heap for shortest paths" << endl;
        cout << "- Prim's algorithm will use min-heap for minimum spanning trees" << endl;
        cout << "- Priority queues will be essential for efficient graph traversal" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🏔️ Heap Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Extract:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Peek:</strong> O(1)</li>
                    <li class="academic-text"><strong>Build heap:</strong> O(n)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space & Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Space:</strong> O(n)</li>
                    <li class="academic-text"><strong>Array-based:</strong> Cache-friendly</li>
                    <li class="academic-text"><strong>In-place:</strong> No extra pointers</li>
                    <li class="academic-text"><strong>Stable:</strong> Predictable performance</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Part I Complete!</h3>
        <p class="academic-text">Congratulations! You've mastered the foundations of graph thinking:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Chapter 1:</strong> Basic graphs and representations</li>
            <li class="academic-text">✅ <strong>Chapter 2:</strong> Graph properties and special types</li>
            <li class="academic-text">✅ <strong>Chapter 3:</strong> Trees and hierarchical structures</li>
            <li class="academic-text">✅ <strong>Chapter 4:</strong> Tries and string processing</li>
            <li class="academic-text">✅ <strong>Chapter 5:</strong> Heaps and priority structures</li>
        </ul>
        
        <p class="academic-text"><strong>You're now ready for Part II: Core Algorithms!</strong> You have all the data structures needed to understand graph traversal, shortest paths, and spanning trees. The real adventure begins!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch6">
        
    <div class="chapter-number">Chapter 6</div>
    <h1 class="chapter-title">Traversal Algorithms</h1>
    
    <div class="definition-box">
        "Graph traversal is like exploring a maze - you need systematic strategies to visit every room without getting lost."
    </div>

    <p class="academic-text">Welcome to the algorithmic heart of graph theory! Having mastered the fundamental structures - graphs, trees, tries, and heaps - you're now ready to explore the algorithms that bring these structures to life. Graph traversal algorithms represent the foundation upon which virtually every graph algorithm is built, from the simplest connectivity checks to the most sophisticated network analysis and artificial intelligence systems.</p>
    
    <p class="academic-text">Traversal algorithms solve the fundamental challenge of systematic exploration: how do you visit every node in a graph exactly once, in a predictable order, without getting lost or missing anything? This seemingly simple problem underlies countless applications - web crawlers exploring the internet, social media algorithms analyzing friend networks, GPS systems finding routes, and AI systems searching through solution spaces. The strategies you learn here will appear again and again throughout computer science.</p>

    <p class="academic-text">The beauty of graph traversal lies in how two simple, contrasting strategies - breadth-first and depth-first search - can solve an enormous range of problems. These aren't just academic exercises; they're the algorithmic building blocks that power search engines, social networks, navigation systems, and countless other technologies you use daily. Understanding these traversal patterns will give you the foundation to tackle complex algorithmic challenges across every domain of computer science.</p>
    
    <p class="academic-text"><strong>The two fundamental exploration strategies that power modern computing:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Breadth-First Search (BFS):</strong> Explores systematically by distance, like ripples spreading from a stone dropped in water - perfect for finding shortest paths and analyzing network structure</li>
        <li class="academic-text"><strong>Depth-First Search (DFS):</strong> Explores by going as deep as possible before backtracking, like a maze solver following each path to its end - ideal for detecting cycles and analyzing connectivity</li>
    </ul>

    <h2 class="section-title" id="ch6-1">6.1 Breadth-First Search (BFS)</h2>
    
    <p class="academic-text">BFS explores a graph level by level, like ripples spreading out from a stone dropped in water. It visits all nodes at distance 1, then all nodes at distance 2, and so on.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌊 BFS Strategy</h3>
        <p class="academic-text"><strong>Breadth-First Search</strong> systematically explores nodes in order of their distance from the starting node.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Level-by-level:</strong> Visit all nodes at distance k before any at distance k+1</li>
            <li class="academic-text"><strong>Queue-based:</strong> Uses a FIFO queue to maintain exploration order</li>
            <li class="academic-text"><strong>Shortest paths:</strong> Finds shortest unweighted paths naturally</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>BFS Exploration Example (Starting from A):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A:0] --- B[B:1]
            A --- C[C:1]
            B --- D[D:2]
            B --- E[E:2]
            C --- F[F:2]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show distance from A. BFS visits: A(0) → B,C(1) → D,E,F(2)</p>
    </div>

    <pre class="code-block">// BFS Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_set>
using namespace std;

class BFS {
private:
    vector<vector<int>> graph;
    
public:
    BFS(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u); // undirected
    }
    
    // BFS traversal from start node
    vector<int> bfsTraversal(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            result.push_back(current);
            
            // Visit all unvisited neighbors
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
        return result;
    }
    
    // Find shortest path using BFS
    vector<int> shortestPath(int start, int target) {
        vector<int> parent(graph.size(), -1);
        vector<bool> visited(graph.size(), false);
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            
            if (current == target) break;
            
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    q.push(neighbor);
                }
            }
        }
        
        // Reconstruct path
        vector<int> path;
        for (int node = target; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        return path;
    }
};</pre>

    <h2 class="section-title" id="ch6-2">6.2 Depth-First Search (DFS)</h2>
    
    <p class="academic-text">DFS explores a graph by going as deep as possible along each branch before backtracking. It's like exploring a maze by always taking the first unexplored path you see.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🕳️ DFS Strategy</h3>
        <p class="academic-text"><strong>Depth-First Search</strong> explores as far as possible along each branch before backtracking.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Deep exploration:</strong> Follow paths to their end before trying alternatives</li>
            <li class="academic-text"><strong>Stack-based:</strong> Uses recursion or explicit stack (LIFO)</li>
            <li class="academic-text"><strong>Memory efficient:</strong> Only stores current path, not all discovered nodes</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DFS vs BFS Comparison:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[A] --- B[B]
            A --- C[C]
            B --- D[D]
            B --- E[E]
            C --- F[F]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">BFS order: A → B,C → D,E,F | DFS order: A → B → D → E → C → F</p>
    </div>

    <pre class="code-block">// DFS Implementation
class DFS {
private:
    vector<vector<int>> graph;
    
    void dfsRecursive(int node, vector<bool>& visited, vector<int>& result) {
        visited[node] = true;
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                dfsRecursive(neighbor, visited, result);
            }
        }
    }
    
public:
    DFS(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Recursive DFS
    vector<int> dfsTraversal(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        dfsRecursive(start, visited, result);
        return result;
    }
    
    // Iterative DFS using stack
    vector<int> dfsIterative(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        stack<int> s;
        
        s.push(start);
        
        while (!s.empty()) {
            int current = s.top();
            s.pop();
            
            if (!visited[current]) {
                visited[current] = true;
                result.push_back(current);
                
                // Add neighbors to stack (reverse order for consistent traversal)
                for (auto it = graph[current].rbegin(); it != graph[current].rend(); ++it) {
                    if (!visited[*it]) {
                        s.push(*it);
                    }
                }
            }
        }
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch6-3">6.3 Cycle Detection Using DFS</h2>
    
    <p class="academic-text">One of DFS's superpowers is detecting cycles in graphs. This is crucial for many applications like detecting deadlocks, finding dependencies, and validating DAGs.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔄 Cycle Detection</h3>
        <p class="academic-text">DFS can detect cycles by tracking the recursion stack and looking for back edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Back edge:</strong> An edge to an ancestor in the DFS tree</li>
            <li class="academic-text"><strong>Three colors:</strong> White (unvisited), Gray (processing), Black (finished)</li>
            <li class="academic-text"><strong>Cycle found:</strong> When we encounter a gray node</li>
        </ul>
    </div>

    <pre class="code-block">// Cycle Detection
class CycleDetector {
private:
    vector<vector<int>> graph;
    enum Color { WHITE, GRAY, BLACK };
    
    bool hasCycleDFS(int node, vector<Color>& colors) {
        colors[node] = GRAY;
        
        for (int neighbor : graph[node]) {
            if (colors[neighbor] == GRAY) {
                return true; // Back edge found - cycle detected!
            }
            if (colors[neighbor] == WHITE && hasCycleDFS(neighbor, colors)) {
                return true;
            }
        }
        
        colors[node] = BLACK;
        return false;
    }
    
public:
    CycleDetector(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v); // directed edge
    }
    
    bool hasCycle() {
        vector<Color> colors(graph.size(), WHITE);
        
        for (int i = 0; i < graph.size(); i++) {
            if (colors[i] == WHITE) {
                if (hasCycleDFS(i, colors)) {
                    return true;
                }
            }
        }
        return false;
    }
};</pre>

    <h2 class="section-title" id="ch6-4">6.4 Applications in Social Networks and Web Crawling</h2>
    
    <p class="academic-text">BFS and DFS power many real-world applications. Let's see how they work in systems you use every day.</p>
    
    <p class="academic-text"><strong>Social Network Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Friend suggestions:</strong> BFS finds mutual friends at distance 2</li>
        <li class="academic-text"><strong>Influence analysis:</strong> DFS explores how information spreads</li>
        <li class="academic-text"><strong>Community detection:</strong> Connected components using DFS</li>
    </ul>
    
    <p class="academic-text"><strong>Web Crawling Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> BFS for broad web exploration</li>
        <li class="academic-text"><strong>Site mapping:</strong> DFS for deep site structure analysis</li>
        <li class="academic-text"><strong>Link validation:</strong> Cycle detection for broken link loops</li>
    </ul>

    <pre class="code-block">// Social Network Friend Suggestions
class SocialNetwork {
private:
    vector<vector<int>> friendships;
    
public:
    SocialNetwork(int users) : friendships(users) {}
    
    void addFriendship(int user1, int user2) {
        friendships[user1].push_back(user2);
        friendships[user2].push_back(user1);
    }
    
    // Find mutual friends (distance 2 connections)
    vector<int> suggestFriends(int user) {
        set<int> suggestions;
        set<int> directFriends(friendships[user].begin(), friendships[user].end());
        
        // BFS to distance 2
        for (int friend_id : friendships[user]) {
            for (int friend_of_friend : friendships[friend_id]) {
                // Suggest if not already friend and not self
                if (friend_of_friend != user && 
                    directFriends.find(friend_of_friend) == directFriends.end()) {
                    suggestions.insert(friend_of_friend);
                }
            }
        }
        
        return vector<int>(suggestions.begin(), suggestions.end());
    }
    
    // Find connected components (friend groups)
    vector<vector<int>> findCommunities() {
        vector<vector<int>> communities;
        vector<bool> visited(friendships.size(), false);
        
        for (int i = 0; i < friendships.size(); i++) {
            if (!visited[i]) {
                vector<int> community;
                dfsComponent(i, visited, community);
                communities.push_back(community);
            }
        }
        return communities;
    }
    
private:
    void dfsComponent(int user, vector<bool>& visited, vector<int>& component) {
        visited[user] = true;
        component.push_back(user);
        
        for (int friend_id : friendships[user]) {
            if (!visited[friend_id]) {
                dfsComponent(friend_id, visited, component);
            }
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🚀 Traversal Algorithm Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">BFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Shortest paths, level-order</li>
                    <li class="academic-text"><strong>Memory:</strong> Higher (stores all discovered)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Best for:</strong> Cycles, components, paths</li>
                    <li class="academic-text"><strong>Memory:</strong> Lower (only current path)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 6 Complete!</h3>
        <p class="academic-text">You've mastered the fundamental graph traversal algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>BFS</strong> - level-by-level exploration for shortest paths</li>
            <li class="academic-text">✅ <strong>DFS</strong> - deep exploration for cycles and components</li>
            <li class="academic-text">✅ <strong>Cycle detection</strong> - using DFS with three-color approach</li>
            <li class="academic-text">✅ <strong>Real applications</strong> - social networks and web crawling</li>
        </ul>
        
        <p class="academic-text">These traversal algorithms are the foundation for almost every graph algorithm you'll learn next. Understanding BFS and DFS deeply will make shortest path algorithms, minimum spanning trees, and network flow much easier to grasp!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch7">
        
    <div class="chapter-number">Chapter 7</div>
    <h1 class="chapter-title">Shortest Path Algorithms</h1>
    
    <div class="definition-box">
        "Finding the shortest path is one of the most fundamental problems in computer science - from GPS navigation to network routing to game AI."
    </div>

    <p class="academic-text">Every time you navigate with GPS, send a message across the internet, or watch an AI character find its way through a game world, you're witnessing the power of shortest path algorithms in action. These algorithms represent some of the most practically important and mathematically elegant solutions in computer science, solving the fundamental optimization problem: given multiple possible routes between two points, which one is truly optimal?</p>
    
    <p class="academic-text">Shortest path algorithms transcend simple navigation to become the foundation for optimization across countless domains. They power the routing protocols that deliver your emails across global networks, the recommendation algorithms that suggest connections on social media, the resource allocation systems that optimize supply chains, and the AI pathfinding that makes video game characters appear intelligent. Understanding these algorithms gives you insight into how modern systems solve complex optimization problems efficiently.</p>

    <p class="academic-text">The mathematical beauty of shortest path algorithms lies in how they transform complex optimization problems into systematic graph exploration. By carefully maintaining and updating distance estimates while exploring the graph, these algorithms guarantee optimal solutions while remaining computationally efficient. Each algorithm represents a different approach to the same fundamental challenge, optimized for different constraints and use cases.</p>
    
    <p class="academic-text"><strong>The four pillars of shortest path computation, each solving different optimization challenges:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> The gold standard for single-source shortest paths in graphs with non-negative weights - powers GPS navigation and network routing protocols</li>
        <li class="academic-text"><strong>Bellman-Ford Algorithm:</strong> Handles negative edge weights and detects negative cycles - essential for currency arbitrage detection and network analysis with costs</li>
        <li class="academic-text"><strong>A* Algorithm:</strong> Combines Dijkstra's optimality with heuristic guidance for dramatically faster pathfinding - the backbone of game AI and robotics navigation</li>
        <li class="academic-text"><strong>Floyd-Warshall Algorithm:</strong> Computes shortest paths between all pairs of vertices - crucial for network analysis and transportation planning</li>
    </ul>

    <h2 class="section-title" id="ch7-1">7.1 Dijkstra's Algorithm</h2>
    
    <p class="academic-text">Dijkstra's algorithm is the gold standard for finding shortest paths in weighted graphs with non-negative edge weights. It's the algorithm behind GPS navigation systems and network routing protocols.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🛣️ Dijkstra's Strategy</h3>
        <p class="academic-text"><strong>Dijkstra's Algorithm</strong> finds shortest paths by always exploring the closest unvisited node first.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Greedy approach:</strong> Always pick the node with minimum distance</li>
            <li class="academic-text"><strong>Priority queue:</strong> Uses min-heap to efficiently get next closest node</li>
            <li class="academic-text"><strong>Relaxation:</strong> Updates distances when shorter paths are found</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Shortest path contains shortest subpaths</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Dijkstra's Algorithm Example (Finding shortest path from A):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A:0] -->|4| B[B:4]
            A -->|2| C[C:2]
            B -->|3| D[D:7]
            C -->|1| D[D:3]
            C -->|5| E[E:7]
            D -->|2| E[E:5]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#ffeb3b,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show shortest distances from A. Path A→C→D gives distance 3, better than A→B→D (distance 7)</p>
    </div>

    <pre class="code-block">// Dijkstra's Algorithm Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <limits>
using namespace std;

class DijkstraGraph {
private:
    struct Edge {
        int to;
        int weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    
public:
    DijkstraGraph(int n) : graph(n) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Dijkstra's shortest path algorithm
    pair<vector<int>, vector<int>> dijkstra(int start) {
        int n = graph.size();
        vector<int> dist(n, INT_MAX);
        vector<int> parent(n, -1);
        
        // Priority queue: (distance, node)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        dist[start] = 0;
        pq.push({0, start});
        
        while (!pq.empty()) {
            int currentDist = pq.top().first;
            int currentNode = pq.top().second;
            pq.pop();
            
            // Skip if we've already found a better path
            if (currentDist > dist[currentNode]) continue;
            
            // Explore all neighbors
            for (const Edge& edge : graph[currentNode]) {
                int newDist = dist[currentNode] + edge.weight;
                
                // Relaxation: update if we found a shorter path
                if (newDist < dist[edge.to]) {
                    dist[edge.to] = newDist;
                    parent[edge.to] = currentNode;
                    pq.push({newDist, edge.to});
                }
            }
        }
        
        return {dist, parent};
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int start, int end, const vector<int>& parent) {
        vector<int> path;
        for (int node = end; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        
        // Check if path exists
        if (path[0] != start) return {};
        return path;
    }
    
    // Demo function
    static void demo() {
        DijkstraGraph g(5);
        g.addEdge(0, 1, 4);  // A -> B: 4
        g.addEdge(0, 2, 2);  // A -> C: 2
        g.addEdge(1, 3, 3);  // B -> D: 3
        g.addEdge(2, 3, 1);  // C -> D: 1
        g.addEdge(2, 4, 5);  // C -> E: 5
        g.addEdge(3, 4, 2);  // D -> E: 2
        
        auto [distances, parents] = g.dijkstra(0);
        
        cout << "Shortest distances from A:" << endl;
        vector<char> labels = {'A', 'B', 'C', 'D', 'E'};
        for (int i = 0; i < 5; i++) {
            cout << "To " << labels[i] << ": " << distances[i] << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-2">7.2 Bellman-Ford Algorithm</h2>
    
    <p class="academic-text">While Dijkstra's algorithm is fast, it can't handle negative edge weights. Bellman-Ford algorithm is slower but more versatile - it can detect negative cycles and handle negative weights.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">⚖️ Bellman-Ford Strategy</h3>
        <p class="academic-text"><strong>Bellman-Ford Algorithm</strong> finds shortest paths by relaxing all edges repeatedly.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Edge relaxation:</strong> Try to improve distances using each edge</li>
            <li class="academic-text"><strong>V-1 iterations:</strong> Guarantees finding shortest paths in V-1 steps</li>
            <li class="academic-text"><strong>Negative cycle detection:</strong> Extra iteration detects negative cycles</li>
            <li class="academic-text"><strong>Handles negative weights:</strong> Works where Dijkstra fails</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bellman-Ford vs Dijkstra Comparison:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] -->|2| B[B]
            A -->|-1| C[C]
            C -->|3| B
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffeb3b,stroke:#333,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Negative edge A→C: -1. Dijkstra fails, but Bellman-Ford finds A→C→B = 2 < A→B = 2</p>
    </div>

    <pre class="code-block">// Bellman-Ford Algorithm Implementation
class BellmanFordGraph {
private:
    struct Edge {
        int from, to, weight;
        Edge(int f, int t, int w) : from(f), to(t), weight(w) {}
    };
    
    vector<Edge> edges;
    int numVertices;
    
public:
    BellmanFordGraph(int n) : numVertices(n) {}
    
    void addEdge(int from, int to, int weight) {
        edges.push_back(Edge(from, to, weight));
    }
    
    // Bellman-Ford shortest path algorithm
    pair<vector<int>, bool> bellmanFord(int start) {
        vector<int> dist(numVertices, INT_MAX);
        dist[start] = 0;
        
        // Relax all edges V-1 times
        for (int i = 0; i < numVertices - 1; i++) {
            for (const Edge& edge : edges) {
                if (dist[edge.from] != INT_MAX && 
                    dist[edge.from] + edge.weight < dist[edge.to]) {
                    dist[edge.to] = dist[edge.from] + edge.weight;
                }
            }
        }
        
        // Check for negative cycles
        bool hasNegativeCycle = false;
        for (const Edge& edge : edges) {
            if (dist[edge.from] != INT_MAX && 
                dist[edge.from] + edge.weight < dist[edge.to]) {
                hasNegativeCycle = true;
                break;
            }
        }
        
        return {dist, hasNegativeCycle};
    }
    
    // Demo function
    static void demo() {
        BellmanFordGraph g(4);
        g.addEdge(0, 1, 4);   // A -> B: 4
        g.addEdge(0, 2, -2);  // A -> C: -2 (negative!)
        g.addEdge(2, 1, 3);   // C -> B: 3
        g.addEdge(1, 3, 2);   // B -> D: 2
        g.addEdge(2, 3, 4);   // C -> D: 4
        
        auto [distances, hasNegCycle] = g.bellmanFord(0);
        
        if (hasNegCycle) {
            cout << "Negative cycle detected!" << endl;
        } else {
            cout << "Shortest distances from A (with negative edges):" << endl;
            vector<char> labels = {'A', 'B', 'C', 'D'};
            for (int i = 0; i < 4; i++) {
                cout << "To " << labels[i] << ": " << distances[i] << endl;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-3">7.3 A* Algorithm with Heuristics</h2>
    
    <p class="academic-text">A* (A-star) is Dijkstra's algorithm enhanced with heuristics. It's the go-to algorithm for pathfinding in games, robotics, and any scenario where you know the target location.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🎯 A* Strategy</h3>
        <p class="academic-text"><strong>A* Algorithm</strong> combines actual distance with estimated distance to goal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>f(n) = g(n) + h(n):</strong> Total cost = actual cost + heuristic estimate</li>
            <li class="academic-text"><strong>Admissible heuristic:</strong> Never overestimates the actual cost</li>
            <li class="academic-text"><strong>Guided search:</strong> Explores toward the goal more efficiently</li>
            <li class="academic-text"><strong>Optimal:</strong> Finds shortest path if heuristic is admissible</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>A* Pathfinding Example (Grid with obstacles):</strong><br><br>
        <div class="mermaid">
        graph TD
            S[Start] --> A[A]
            S --> B[B]
            A --> C[C]
            B --> D[D]
            C --> G[Goal]
            D --> G
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style G fill:#ffeb3b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A* uses heuristic (like Manhattan distance) to guide search toward goal</p>
    </div>

    <pre class="code-block">// A* Algorithm Implementation
#include <cmath>

class AStarGraph {
private:
    struct Node {
        int id;
        double x, y;  // Coordinates for heuristic
        Node(int i, double px, double py) : id(i), x(px), y(py) {}
    };
    
    struct AStarNode {
        int id;
        double g, h, f;  // g: actual cost, h: heuristic, f: total
        int parent;
        
        AStarNode(int i, double gc, double hc, int p) 
            : id(i), g(gc), h(hc), f(gc + hc), parent(p) {}
        
        bool operator>(const AStarNode& other) const {
            return f > other.f;
        }
    };
    
    vector<Node> nodes;
    vector<vector<pair<int, double>>> graph;
    
    // Manhattan distance heuristic
    double heuristic(int from, int to) {
        return abs(nodes[from].x - nodes[to].x) + abs(nodes[from].y - nodes[to].y);
    }
    
public:
    AStarGraph(int n) : graph(n) {}
    
    void addNode(int id, double x, double y) {
        nodes.push_back(Node(id, x, y));
    }
    
    void addEdge(int from, int to, double weight) {
        graph[from].push_back({to, weight});
    }
    
    // A* pathfinding algorithm
    vector<int> aStar(int start, int goal) {
        priority_queue<AStarNode, vector<AStarNode>, greater<AStarNode>> openSet;
        unordered_set<int> closedSet;
        unordered_map<int, double> gScore;
        unordered_map<int, int> parent;
        
        gScore[start] = 0;
        openSet.push(AStarNode(start, 0, heuristic(start, goal), -1));
        
        while (!openSet.empty()) {
            AStarNode current = openSet.top();
            openSet.pop();
            
            if (current.id == goal) {
                // Reconstruct path
                vector<int> path;
                for (int node = goal; node != -1; node = parent[node]) {
                    path.push_back(node);
                }
                reverse(path.begin(), path.end());
                return path;
            }
            
            closedSet.insert(current.id);
            
            for (auto& [neighbor, weight] : graph[current.id]) {
                if (closedSet.count(neighbor)) continue;
                
                double tentativeG = gScore[current.id] + weight;
                
                if (gScore.find(neighbor) == gScore.end() || tentativeG < gScore[neighbor]) {
                    gScore[neighbor] = tentativeG;
                    parent[neighbor] = current.id;
                    openSet.push(AStarNode(neighbor, tentativeG, heuristic(neighbor, goal), current.id));
                }
            }
        }
        
        return {}; // No path found
    }
    
    // Demo function for grid pathfinding
    static void demo() {
        AStarGraph g(6);
        
        // Add nodes with coordinates
        g.addNode(0, 0, 0);  // Start
        g.addNode(1, 1, 0);
        g.addNode(2, 0, 1);
        g.addNode(3, 1, 1);
        g.addNode(4, 2, 1);
        g.addNode(5, 2, 2);  // Goal
        
        // Add edges (grid connections)
        g.addEdge(0, 1, 1);  // Horizontal/vertical moves cost 1
        g.addEdge(0, 2, 1);
        g.addEdge(1, 3, 1);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 4, 1);
        g.addEdge(4, 5, 1);
        
        vector<int> path = g.aStar(0, 5);
        
        cout << "A* path from start to goal: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <h2 class="section-title" id="ch7-4">7.4 Floyd-Warshall All-Pairs Shortest Path</h2>
    
    <p class="academic-text">Sometimes you need shortest paths between ALL pairs of vertices, not just from one source. Floyd-Warshall algorithm efficiently computes the shortest path matrix for the entire graph.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌐 Floyd-Warshall Strategy</h3>
        <p class="academic-text"><strong>Floyd-Warshall Algorithm</strong> finds shortest paths between all pairs of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dynamic programming:</strong> Builds solution by considering intermediate vertices</li>
            <li class="academic-text"><strong>All-pairs:</strong> Computes shortest paths between every pair of vertices</li>
            <li class="academic-text"><strong>Handles negatives:</strong> Works with negative weights (but not negative cycles)</li>
            <li class="academic-text"><strong>Simple implementation:</strong> Three nested loops, easy to understand</li>
        </ul>
    </div>

    <pre class="code-block">// Floyd-Warshall Algorithm Implementation
class FloydWarshallGraph {
private:
    vector<vector<int>> dist;
    vector<vector<int>> next;
    int n;
    
public:
    FloydWarshallGraph(int vertices) : n(vertices) {
        dist.assign(n, vector<int>(n, INT_MAX));
        next.assign(n, vector<int>(n, -1));
        
        // Initialize diagonal to 0
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
    }
    
    void addEdge(int from, int to, int weight) {
        dist[from][to] = weight;
        next[from][to] = to;
    }
    
    // Floyd-Warshall all-pairs shortest path
    void floydWarshall() {
        // Try each vertex as intermediate
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                            next[i][j] = next[i][k];
                        }
                    }
                }
            }
        }
    }
    
    // Get shortest distance between two vertices
    int getDistance(int from, int to) {
        return dist[from][to];
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int from, int to) {
        if (next[from][to] == -1) return {};
        
        vector<int> path;
        path.push_back(from);
        
        while (from != to) {
            from = next[from][to];
            path.push_back(from);
        }
        
        return path;
    }
    
    // Print distance matrix
    void printDistanceMatrix() {
        cout << "All-pairs shortest distances:" << endl;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == INT_MAX) {
                    cout << "∞ ";
                } else {
                    cout << dist[i][j] << " ";
                }
            }
            cout << endl;
        }
    }
    
    // Demo function
    static void demo() {
        FloydWarshallGraph g(4);
        
        g.addEdge(0, 1, 3);
        g.addEdge(0, 3, 7);
        g.addEdge(1, 0, 8);
        g.addEdge(1, 2, 2);
        g.addEdge(2, 0, 5);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 0, 2);
        
        g.floydWarshall();
        g.printDistanceMatrix();
        
        // Example path
        vector<int> path = g.getPath(1, 3);
        cout << "Path from 1 to 3: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">⚡ Shortest Path Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Single-Source Algorithms</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Dijkstra:</strong> O((V+E) log V), no negative weights</li>
                    <li class="academic-text"><strong>Bellman-Ford:</strong> O(VE), handles negative weights</li>
                    <li class="academic-text"><strong>A*:</strong> O(b^d), guided by heuristics</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">All-Pairs Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Floyd-Warshall:</strong> O(V³), all pairs</li>
                    <li class="academic-text"><strong>Dense graphs:</strong> More efficient than V × Dijkstra</li>
                    <li class="academic-text"><strong>Simple code:</strong> Easy to implement and understand</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">Algorithm Selection Guide</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>GPS Navigation:</strong> A* with Euclidean distance heuristic</li>
                <li class="academic-text"><strong>Network Routing:</strong> Dijkstra for positive weights, Bellman-Ford for policy routing</li>
                <li class="academic-text"><strong>Game AI:</strong> A* for pathfinding with obstacles</li>
                <li class="academic-text"><strong>Social Networks:</strong> Floyd-Warshall for analyzing all relationships</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 7 Complete!</h3>
        <p class="academic-text">You've mastered the essential shortest path algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Dijkstra's Algorithm</strong> - the gold standard for non-negative weights</li>
            <li class="academic-text">✅ <strong>Bellman-Ford Algorithm</strong> - handles negative weights and cycle detection</li>
            <li class="academic-text">✅ <strong>A* Algorithm</strong> - heuristic-guided pathfinding for games and robotics</li>
            <li class="academic-text">✅ <strong>Floyd-Warshall Algorithm</strong> - all-pairs shortest paths analysis</li>
        </ul>
        
        <p class="academic-text">These algorithms power everything from GPS navigation to internet routing to game AI. You now understand the core techniques that make modern connected systems possible. Next up: spanning tree algorithms that find the most efficient ways to connect networks!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch8">
        
    <div class="chapter-number">Chapter 8</div>
    <h1 class="chapter-title">Minimum Spanning Trees</h1>
    
    <div class="definition-box">
        "Minimum spanning trees find the cheapest way to connect all nodes in a network - essential for designing efficient infrastructure."
    </div>

    <p class="academic-text">Imagine you're tasked with designing a telecommunications network to connect every city in a country with fiber optic cables, but you have a limited budget and need to minimize the total cost. Or perhaps you're planning an electrical grid that must reach every neighborhood while using the least amount of wire. These real-world optimization challenges represent minimum spanning tree problems - some of the most elegant and practically important problems in computer science.</p>
    
    <p class="academic-text">Minimum Spanning Trees represent the perfect intersection of mathematical theory and practical application. A spanning tree connects all vertices in a graph using exactly n-1 edges (the minimum needed to maintain connectivity), while a minimum spanning tree does this with the smallest possible total weight. This optimization problem appears everywhere from infrastructure design to data analysis, demonstrating how graph theory solves real-world challenges with mathematical precision.</p>

    <p class="academic-text">The beauty of MST algorithms lies in their guarantee of optimality through surprisingly simple strategies. These algorithms prove that greedy approaches - making locally optimal choices at each step - can lead to globally optimal solutions. This insight has profound implications beyond spanning trees, influencing algorithm design across computer science and operations research.</p>
    
    <p class="academic-text"><strong>MSTs power critical systems and applications across industries:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Infrastructure networks:</strong> Designing optimal layouts for telecommunications, power grids, water systems, and transportation networks that minimize cost while ensuring connectivity</li>
        <li class="academic-text"><strong>Circuit design:</strong> Minimizing wire length and signal delay in computer chips and electronic devices, where every millimeter of wire affects performance and cost</li>
        <li class="academic-text"><strong>Data clustering:</strong> Finding natural groupings in machine learning and data analysis by connecting similar data points with minimum total distance</li>
        <li class="academic-text"><strong>Approximation algorithms:</strong> Serving as the foundation for solving more complex optimization problems like the traveling salesman problem and facility location</li>
        <li class="academic-text"><strong>Network reliability:</strong> Identifying critical connections in networks and designing backup systems that maintain connectivity with minimal redundancy</li>
    </ul>

    <h2 class="section-title" id="ch8-1">8.1 Kruskal's Algorithm</h2>
    
    <p class="academic-text">Kruskal's algorithm builds the MST by considering edges in order of increasing weight, adding each edge if it doesn't create a cycle. It's a greedy algorithm that always makes the locally optimal choice.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Kruskal's Strategy</h3>
        <p class="academic-text"><strong>Kruskal's Algorithm</strong> builds MST by adding edges in order of increasing weight.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Sort edges:</strong> Order all edges by weight from smallest to largest</li>
            <li class="academic-text"><strong>Greedy selection:</strong> Add the smallest edge that doesn't create a cycle</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use Union-Find to efficiently detect cycles</li>
            <li class="academic-text"><strong>Stop condition:</strong> Stop when we have V-1 edges (tree property)</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Kruskal's Algorithm Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] ---|1| B[B]
            A ---|4| C[C]
            B ---|2| C[C]
            B ---|5| D[D]
            C ---|3| D[D]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Edge selection order: AB(1) → BC(2) → CD(3). Skip AC(4) and BD(5) as they create cycles.</p>
    </div>

    <pre class="code-block">// Kruskal's Algorithm Implementation
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class KruskalMST {
private:
    struct Edge {
        int u, v, weight;
        Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
        
        bool operator<(const Edge& other) const {
            return weight < other.weight;
        }
    };
    
    vector<Edge> edges;
    int numVertices;
    
public:
    KruskalMST(int n) : numVertices(n) {}
    
    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }
    
    // Find MST using Kruskal's algorithm
    vector<Edge> findMST() {
        vector<Edge> mst;
        
        // Sort edges by weight
        sort(edges.begin(), edges.end());
        
        // Initialize Union-Find
        UnionFind uf(numVertices);
        
        for (const Edge& edge : edges) {
            // If adding this edge doesn't create a cycle
            if (uf.find(edge.u) != uf.find(edge.v)) {
                mst.push_back(edge);
                uf.unite(edge.u, edge.v);
                
                // MST complete when we have V-1 edges
                if (mst.size() == numVertices - 1) break;
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<Edge> mst = findMST();
        int totalWeight = 0;
        for (const Edge& edge : mst) {
            totalWeight += edge.weight;
        }
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        KruskalMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<Edge> mst = graph.findMST();
        
        cout << "Kruskal's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (const Edge& edge : mst) {
            cout << labels[edge.u] << "-" << labels[edge.v] 
                 << " (weight: " << edge.weight << ")" << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-2">8.2 Prim's Algorithm</h2>
    
    <p class="academic-text">Prim's algorithm builds the MST by starting from a vertex and growing the tree one edge at a time, always adding the minimum weight edge that connects the tree to a new vertex.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌱 Prim's Strategy</h3>
        <p class="academic-text"><strong>Prim's Algorithm</strong> grows MST from a starting vertex by adding minimum edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Start with vertex:</strong> Begin with any vertex in the MST</li>
            <li class="academic-text"><strong>Grow incrementally:</strong> Add minimum edge connecting MST to new vertex</li>
            <li class="academic-text"><strong>Priority queue:</strong> Use min-heap to efficiently find minimum edge</li>
            <li class="academic-text"><strong>Cut property:</strong> Minimum edge crossing cut is safe to add</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Prim's vs Kruskal's Comparison:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Start: Pick any vertex] --> B[Prim's: Grow tree from vertex]
            A --> C[Kruskal's: Consider all edges globally]
            B --> D[Uses: Priority Queue]
            C --> E[Uses: Union-Find]
            D --> F[Good for: Dense graphs]
            E --> G[Good for: Sparse graphs]
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Both algorithms find the same MST but use different strategies</p>
    </div>

    <pre class="code-block">// Prim's Algorithm Implementation
#include <queue>
#include <climits>

class PrimMST {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    PrimMST(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int u, int v, int weight) {
        graph[u].push_back(Edge(v, weight));
        graph[v].push_back(Edge(u, weight)); // undirected
    }
    
    // Find MST using Prim's algorithm
    vector<pair<int, int>> findMST() {
        vector<pair<int, int>> mst;
        vector<bool> inMST(numVertices, false);
        vector<int> key(numVertices, INT_MAX);
        vector<int> parent(numVertices, -1);
        
        // Priority queue: (weight, vertex)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        // Start from vertex 0
        key[0] = 0;
        pq.push({0, 0});
        
        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();
            
            if (inMST[u]) continue;
            
            inMST[u] = true;
            
            // Add edge to MST (except for starting vertex)
            if (parent[u] != -1) {
                mst.push_back({parent[u], u});
            }
            
            // Update keys of adjacent vertices
            for (const Edge& edge : graph[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (!inMST[v] && weight < key[v]) {
                    key[v] = weight;
                    parent[v] = u;
                    pq.push({weight, v});
                }
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<pair<int, int>> mst = findMST();
        int totalWeight = 0;
        
        for (auto [u, v] : mst) {
            // Find edge weight between u and v
            for (const Edge& edge : graph[u]) {
                if (edge.to == v) {
                    totalWeight += edge.weight;
                    break;
                }
            }
        }
        
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        PrimMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<pair<int, int>> mst = graph.findMST();
        
        cout << "Prim's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (auto [u, v] : mst) {
            cout << labels[u] << "-" << labels[v] << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-3">8.3 Union-Find Data Structure</h2>
    
    <p class="academic-text">Union-Find (also called Disjoint Set Union) is a crucial data structure for Kruskal's algorithm. It efficiently tracks which vertices belong to which connected components and can quickly determine if adding an edge would create a cycle.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Union-Find Operations</h3>
        <p class="academic-text"><strong>Union-Find</strong> maintains disjoint sets with two key operations:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Find(x):</strong> Determine which set contains element x</li>
            <li class="academic-text"><strong>Union(x, y):</strong> Merge the sets containing x and y</li>
            <li class="academic-text"><strong>Path compression:</strong> Optimize find by flattening tree structure</li>
            <li class="academic-text"><strong>Union by rank:</strong> Optimize union by balancing tree height</li>
        </ul>
    </div>

    <pre class="code-block">// Union-Find Data Structure Implementation
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        // Initially, each element is its own parent
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // Find with path compression
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    // Union by rank
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            // Union by rank: attach smaller tree to larger tree
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    
    // Check if two elements are in the same set
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // Count number of disjoint sets
    int countSets() {
        unordered_set<int> roots;
        for (int i = 0; i < parent.size(); i++) {
            roots.insert(find(i));
        }
        return roots.size();
    }
    
    // Demo function
    static void demo() {
        UnionFind uf(5);
        
        cout << "Initial sets: " << uf.countSets() << endl;
        
        uf.unite(0, 1);  // Connect 0 and 1
        uf.unite(2, 3);  // Connect 2 and 3
        
        cout << "After unions: " << uf.countSets() << endl;
        cout << "0 and 1 connected: " << uf.connected(0, 1) << endl;
        cout << "0 and 2 connected: " << uf.connected(0, 2) << endl;
        
        uf.unite(1, 2);  // Connect the two components
        cout << "Final sets: " << uf.countSets() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-4">8.4 Applications in Network Design</h2>
    
    <p class="academic-text">MST algorithms have countless real-world applications in designing efficient networks and infrastructure. Let's explore some practical examples.</p>
    
    <p class="academic-text"><strong>Network Infrastructure Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Computer networks:</strong> Connecting offices with minimum cable cost</li>
        <li class="academic-text"><strong>Power grids:</strong> Connecting power stations to minimize transmission costs</li>
        <li class="academic-text"><strong>Transportation:</strong> Building road networks with minimum construction cost</li>
        <li class="academic-text"><strong>Telecommunications:</strong> Laying fiber optic cables efficiently</li>
    </ul>
    
    <p class="academic-text"><strong>Data Analysis Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Clustering:</strong> Finding natural groupings in data</li>
        <li class="academic-text"><strong>Image segmentation:</strong> Identifying regions in images</li>
        <li class="academic-text"><strong>Social network analysis:</strong> Finding communities</li>
        <li class="academic-text"><strong>Phylogenetic trees:</strong> Evolutionary relationships</li>
    </ul>

    <pre class="code-block">// Network Design Application
class NetworkDesigner {
private:
    struct Connection {
        int city1, city2;
        double cost;
        string type; // "fiber", "cable", "wireless"
        
        Connection(int c1, int c2, double c, string t) 
            : city1(c1), city2(c2), cost(c), type(t) {}
    };
    
    vector<string> cityNames;
    vector<Connection> possibleConnections;
    
public:
    void addCity(const string& name) {
        cityNames.push_back(name);
    }
    
    void addPossibleConnection(int city1, int city2, double cost, const string& type) {
        possibleConnections.push_back(Connection(city1, city2, cost, type));
    }
    
    // Design minimum cost network using MST
    vector<Connection> designNetwork() {
        vector<Connection> network;
        
        // Sort connections by cost
        sort(possibleConnections.begin(), possibleConnections.end(),
             [](const Connection& a, const Connection& b) {
                 return a.cost < b.cost;
             });
        
        UnionFind uf(cityNames.size());
        
        for (const Connection& conn : possibleConnections) {
            if (uf.find(conn.city1) != uf.find(conn.city2)) {
                network.push_back(conn);
                uf.unite(conn.city1, conn.city2);
                
                if (network.size() == cityNames.size() - 1) break;
            }
        }
        
        return network;
    }
    
    // Calculate total network cost
    double getTotalCost() {
        vector<Connection> network = designNetwork();
        double totalCost = 0;
        for (const Connection& conn : network) {
            totalCost += conn.cost;
        }
        return totalCost;
    }
    
    // Demo function
    static void demo() {
        NetworkDesigner designer;
        
        // Add cities
        designer.addCity("New York");
        designer.addCity("Boston");
        designer.addCity("Philadelphia");
        designer.addCity("Washington DC");
        
        // Add possible connections with costs (in millions)
        designer.addPossibleConnection(0, 1, 15.5, "fiber");    // NY-Boston
        designer.addPossibleConnection(0, 2, 8.2, "fiber");     // NY-Philadelphia
        designer.addPossibleConnection(0, 3, 12.1, "cable");    // NY-Washington
        designer.addPossibleConnection(1, 2, 18.7, "wireless"); // Boston-Philadelphia
        designer.addPossibleConnection(1, 3, 25.3, "cable");    // Boston-Washington
        designer.addPossibleConnection(2, 3, 6.8, "fiber");     // Philadelphia-Washington
        
        vector<Connection> network = designer.designNetwork();
        
        cout << "Optimal network design:" << endl;
        for (const Connection& conn : network) {
            cout << designer.cityNames[conn.city1] << " - " 
                 << designer.cityNames[conn.city2] 
                 << " (" << conn.type << ", $" << conn.cost << "M)" << endl;
        }
        cout << "Total cost: $" << designer.getTotalCost() << "M" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🌳 MST Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kruskal's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for Union-Find</li>
                    <li class="academic-text"><strong>Best for:</strong> Sparse graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Global edge selection</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Prim's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log V)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for priority queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Dense graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Incremental tree growth</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">When to Use Which Algorithm</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>Kruskal's:</strong> When edges are given as a list, sparse graphs, or when Union-Find is already available</li>
                <li class="academic-text"><strong>Prim's:</strong> When graph is represented as adjacency list/matrix, dense graphs, or when starting from specific vertex</li>
                <li class="academic-text"><strong>Both produce identical MST weight</strong> - choice depends on implementation convenience and graph density</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 8 Complete!</h3>
        <p class="academic-text">You've mastered minimum spanning tree algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Kruskal's Algorithm</strong> - global edge selection with Union-Find</li>
            <li class="academic-text">✅ <strong>Prim's Algorithm</strong> - incremental tree growth with priority queue</li>
            <li class="academic-text">✅ <strong>Union-Find Data Structure</strong> - efficient cycle detection and set operations</li>
            <li class="academic-text">✅ <strong>Network Design Applications</strong> - real-world infrastructure optimization</li>
        </ul>
        
        <p class="academic-text">MST algorithms are fundamental tools for optimization problems involving connectivity. They're used everywhere from computer networks to data clustering to circuit design. Next: topological sorting for handling dependencies and scheduling!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch9">
        
    <div class="chapter-number">Chapter 9</div>
    <h1 class="chapter-title">Topological Sorting & Dynamic Programming on DAGs</h1>
    
    <div class="definition-box">
        "Topological sorting solves dependency problems - from course prerequisites to build systems to project scheduling."
    </div>

    <p class="academic-text">Every time your computer compiles a complex software project, installs packages with dependencies, or schedules tasks in the correct order, it's solving one of the most fundamental ordering problems in computer science: topological sorting. This elegant algorithm transforms the complex challenge of dependency management into a systematic process that ensures everything happens in the right sequence, preventing the chaos that would result from trying to do things out of order.</p>
    
    <p class="academic-text">Topological sorting represents the mathematical solution to dependency resolution - the process of arranging tasks, courses, or components in an order that respects all prerequisite relationships. In a world where complex systems depend on intricate webs of dependencies, topological sorting provides the algorithmic foundation that keeps everything running smoothly, from the software on your computer to the supply chains that deliver products to your door.</p>

    <p class="academic-text">The power of topological sorting extends far beyond simple ordering. When combined with dynamic programming on DAGs, it enables efficient solutions to complex optimization problems, from finding longest paths in project scheduling to optimizing resource allocation in distributed systems. This combination represents one of the most powerful algorithmic paradigms for solving real-world optimization challenges.</p>
    
    <p class="academic-text"><strong>Topological sorting powers the dependency management systems that make modern computing possible:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Academic planning:</strong> University systems use topological sorting to ensure students take prerequisite courses before advanced ones, preventing academic bottlenecks and ensuring proper knowledge progression</li>
        <li class="academic-text"><strong>Software build systems:</strong> Compilers and build tools use topological sorting to determine compilation order, ensuring libraries are built before the programs that depend on them</li>
        <li class="academic-text"><strong>Project management:</strong> Critical path method and PERT charts rely on topological sorting to schedule project tasks, identifying which activities can run in parallel and which must wait for dependencies</li>
        <li class="academic-text"><strong>Package management:</strong> Software package managers use topological sorting to install dependencies in the correct order, preventing installation failures and version conflicts</li>
        <li class="academic-text"><strong>Manufacturing and supply chains:</strong> Production scheduling systems use topological sorting to coordinate complex manufacturing processes where some steps must complete before others can begin</li>
    </ul>

    <h2 class="section-title" id="ch9-1">9.1 Topological Ordering and Kahn's Algorithm</h2>
    
    <p class="academic-text">Kahn's algorithm is an intuitive approach to topological sorting. It repeatedly removes vertices with no incoming edges, which represents tasks that have no remaining dependencies.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">📋 Kahn's Algorithm Strategy</h3>
        <p class="academic-text"><strong>Kahn's Algorithm</strong> builds topological order by removing vertices with no dependencies.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Track in-degrees:</strong> Count incoming edges for each vertex</li>
            <li class="academic-text"><strong>Start with zero in-degree:</strong> Process vertices with no dependencies first</li>
            <li class="academic-text"><strong>Remove and update:</strong> Remove vertex and decrease neighbors' in-degrees</li>
            <li class="academic-text"><strong>Cycle detection:</strong> If we can't process all vertices, there's a cycle</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Course Prerequisites Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> C[Physics 201]
            B[CS 101] --> D[Data Structures]
            A --> D
            C --> E[Advanced Physics]
            D --> F[Algorithms]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Valid order: Math 101, CS 101, Physics 201, Data Structures, Advanced Physics, Algorithms</p>
    </div>

    <pre class="code-block">// Kahn's Algorithm Implementation
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

class TopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> inDegree;
    int numVertices;
    
public:
    TopologicalSort(int n) : numVertices(n), graph(n), inDegree(n, 0) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
        inDegree[to]++;
    }
    
    // Kahn's algorithm for topological sorting
    vector<int> kahnSort() {
        vector<int> result;
        queue<int> zeroInDegree;
        
        // Find all vertices with no incoming edges
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                zeroInDegree.push(i);
            }
        }
        
        while (!zeroInDegree.empty()) {
            int current = zeroInDegree.front();
            zeroInDegree.pop();
            result.push_back(current);
            
            // Remove current vertex and update in-degrees
            for (int neighbor : graph[current]) {
                inDegree[neighbor]--;
                if (inDegree[neighbor] == 0) {
                    zeroInDegree.push(neighbor);
                }
            }
        }
        
        // Check for cycles
        if (result.size() != numVertices) {
            return {}; // Cycle detected - no valid topological order
        }
        
        return result;
    }
    
    // Check if graph is a DAG
    bool isDAG() {
        return kahnSort().size() == numVertices;
    }
};</pre>

    <h2 class="section-title" id="ch9-2">9.2 DFS-Based Topological Sort</h2>
    
    <p class="academic-text">Another approach to topological sorting uses DFS. The key insight is that in a DFS traversal of a DAG, a vertex should appear in the topological order after all vertices in its DFS subtree.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔍 DFS Topological Strategy</h3>
        <p class="academic-text"><strong>DFS Topological Sort</strong> uses post-order DFS traversal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Post-order traversal:</strong> Add vertex to result after visiting all descendants</li>
            <li class="academic-text"><strong>Reverse order:</strong> Reverse the post-order to get topological order</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use three colors to detect back edges</li>
            <li class="academic-text"><strong>Recursive approach:</strong> Natural recursive implementation</li>
        </ul>
    </div>

    <pre class="code-block">// DFS-Based Topological Sort
class DFSTopologicalSort {
private:
    vector<vector<int>> graph;
    vector<int> color; // 0: white, 1: gray, 2: black
    vector<int> result;
    bool hasCycle;
    
    void dfsVisit(int vertex) {
        color[vertex] = 1; // Mark as gray (processing)
        
        for (int neighbor : graph[vertex]) {
            if (color[neighbor] == 1) {
                hasCycle = true; // Back edge found - cycle detected
                return;
            }
            if (color[neighbor] == 0) {
                dfsVisit(neighbor);
            }
        }
        
        color[vertex] = 2; // Mark as black (finished)
        result.push_back(vertex); // Add to result in post-order
    }
    
public:
    DFSTopologicalSort(int n) : graph(n), color(n, 0), hasCycle(false) {}
    
    void addEdge(int from, int to) {
        graph[from].push_back(to);
    }
    
    vector<int> topologicalSort() {
        result.clear();
        hasCycle = false;
        fill(color.begin(), color.end(), 0);
        
        // Start DFS from all unvisited vertices
        for (int i = 0; i < graph.size(); i++) {
            if (color[i] == 0) {
                dfsVisit(i);
                if (hasCycle) return {}; // Cycle detected
            }
        }
        
        // Reverse to get correct topological order
        reverse(result.begin(), result.end());
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch9-3">9.3 Dynamic Programming on DAGs</h2>
    
    <p class="academic-text">DAGs have a special property that makes dynamic programming very natural: they have no cycles, so we can process vertices in topological order and guarantee that when we process a vertex, all its dependencies have already been computed.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">⚡ DP on DAGs Strategy</h3>
        <p class="academic-text"><strong>Dynamic Programming on DAGs</strong> leverages topological ordering for optimal substructure.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Topological order:</strong> Process vertices in dependency order</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Solution depends on optimal solutions to subproblems</li>
            <li class="academic-text"><strong>No cycles:</strong> No need to worry about circular dependencies</li>
            <li class="academic-text"><strong>Memoization:</strong> Store computed results to avoid recomputation</li>
        </ul>
    </div>

    <pre class="code-block">// Dynamic Programming on DAGs
class DAGDynamicProgramming {
private:
    vector<vector<pair<int, int>>> graph; // adjacency list with weights
    vector<int> dp;
    vector<bool> visited;
    
public:
    DAGDynamicProgramming(int n) : graph(n), dp(n, -1), visited(n, false) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back({to, weight});
    }
    
    // Find longest path from source using DP
    int longestPath(int source, int target) {
        if (source == target) return 0;
        if (visited[source]) return dp[source];
        
        visited[source] = true;
        dp[source] = INT_MIN; // Initialize to negative infinity
        
        for (auto [neighbor, weight] : graph[source]) {
            int pathLength = longestPath(neighbor, target);
            if (pathLength != INT_MIN) {
                dp[source] = max(dp[source], weight + pathLength);
            }
        }
        
        return dp[source];
    }
    
    // Count number of paths from source to target
    int countPaths(int source, int target) {
        if (source == target) return 1;
        
        vector<int> pathCount(graph.size(), -1);
        return countPathsHelper(source, target, pathCount);
    }
    
private:
    int countPathsHelper(int current, int target, vector<int>& pathCount) {
        if (current == target) return 1;
        if (pathCount[current] != -1) return pathCount[current];
        
        pathCount[current] = 0;
        for (auto [neighbor, weight] : graph[current]) {
            pathCount[current] += countPathsHelper(neighbor, target, pathCount);
        }
        
        return pathCount[current];
    }
};</pre>

    <h2 class="section-title" id="ch9-4">9.4 Longest and Shortest Paths in DAGs</h2>
    
    <p class="academic-text">Finding longest and shortest paths in general graphs can be complex, but in DAGs, we can solve these problems efficiently using topological sorting and dynamic programming.</p>

    <pre class="code-block">// Longest and Shortest Paths in DAGs
class DAGPaths {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    DAGPaths(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Find shortest paths from source using topological sort
    vector<int> shortestPaths(int source) {
        vector<int> dist(numVertices, INT_MAX);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MAX) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight < dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
    // Find longest paths from source
    vector<int> longestPaths(int source) {
        vector<int> dist(numVertices, INT_MIN);
        vector<int> topoOrder = getTopologicalOrder();
        
        dist[source] = 0;
        
        for (int u : topoOrder) {
            if (dist[u] != INT_MIN) {
                for (const Edge& edge : graph[u]) {
                    if (dist[u] + edge.weight > dist[edge.to]) {
                        dist[edge.to] = dist[u] + edge.weight;
                    }
                }
            }
        }
        
        return dist;
    }
    
private:
    vector<int> getTopologicalOrder() {
        vector<int> inDegree(numVertices, 0);
        for (int u = 0; u < numVertices; u++) {
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]++;
            }
        }
        
        queue<int> q;
        for (int i = 0; i < numVertices; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        vector<int> topoOrder;
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            topoOrder.push_back(u);
            
            for (const Edge& edge : graph[u]) {
                inDegree[edge.to]--;
                if (inDegree[edge.to] == 0) {
                    q.push(edge.to);
                }
            }
        }
        
        return topoOrder;
    }
    
public:
    // Demo function for project scheduling
    static void demo() {
        DAGPaths scheduler(6);
        
        // Project tasks with durations (weights)
        scheduler.addEdge(0, 1, 3);  // Task A -> B (3 days)
        scheduler.addEdge(0, 2, 2);  // Task A -> C (2 days)
        scheduler.addEdge(1, 3, 4);  // Task B -> D (4 days)
        scheduler.addEdge(2, 3, 1);  // Task C -> D (1 day)
        scheduler.addEdge(3, 4, 2);  // Task D -> E (2 days)
        scheduler.addEdge(1, 5, 3);  // Task B -> F (3 days)
        
        vector<int> longest = scheduler.longestPaths(0);
        
        cout << "Critical path analysis:" << endl;
        char labels[] = {'A', 'B', 'C', 'D', 'E', 'F'};
        for (int i = 0; i < 6; i++) {
            cout << "Task " << labels[i] << ": " << longest[i] << " days" << endl;
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">📊 Topological Sorting Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kahn's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Approach:</strong> Remove vertices with no dependencies</li>
                    <li class="academic-text"><strong>Intuitive:</strong> Mirrors real-world scheduling</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS-Based Sort</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Approach:</strong> Post-order DFS traversal</li>
                    <li class="academic-text"><strong>Natural:</strong> Recursive implementation</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 9 Complete!</h3>
        <p class="academic-text">You've mastered topological sorting and DAG algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Kahn's Algorithm</strong> - intuitive dependency-based sorting</li>
            <li class="academic-text">✅ <strong>DFS Topological Sort</strong> - recursive post-order approach</li>
            <li class="academic-text">✅ <strong>Dynamic Programming on DAGs</strong> - leveraging topological order</li>
            <li class="academic-text">✅ <strong>Path Problems in DAGs</strong> - longest/shortest paths efficiently</li>
        </ul>
        
        <p class="academic-text">These algorithms solve fundamental scheduling and dependency problems that appear everywhere in computer science and project management. You now have the complete toolkit for core graph algorithms!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch10">
        
    <div class="chapter-number">Chapter 10</div>
    <h1 class="chapter-title">Flow Networks and Optimization</h1>
    
    <div class="definition-box">
        "Flow networks model how resources move through systems - from water in pipes to data in networks to goods in supply chains."
    </div>

    <p class="academic-text">Flow networks represent one of the most powerful and versatile modeling frameworks in computer science, capturing the essence of resource movement, capacity constraints, and optimization in systems ranging from physical infrastructure to abstract computational problems. These networks model situations where you have limited capacity connections and want to maximize the flow of resources - whether that's water through pipes, data through internet cables, or goods through supply chains.</p>
    
    <p class="academic-text">The mathematical beauty of flow networks lies in their ability to transform complex real-world optimization problems into elegant graph algorithms. By modeling capacity constraints as edge weights and flow conservation as fundamental laws, flow networks enable precise analysis and optimization of systems that would otherwise be intractably complex. The algorithms we'll explore don't just solve abstract mathematical problems - they power the infrastructure and systems that modern society depends on.</p>

    <p class="academic-text">Flow networks also reveal deep connections between seemingly unrelated problems. The same algorithmic framework that optimizes internet traffic can solve job assignment problems, image processing challenges, and supply chain optimization. This universality makes flow networks one of the most important algorithmic paradigms in computer science, with applications spanning from theoretical computer science to practical engineering.</p>
    
    <p class="academic-text"><strong>Flow networks power the optimization systems that keep modern infrastructure running:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Internet infrastructure:</strong> Network routers use flow algorithms to maximize data throughput and minimize congestion across global internet connections, ensuring your video calls and downloads work smoothly</li>
        <li class="academic-text"><strong>Transportation systems:</strong> Logistics companies use flow networks to optimize cargo movement through road, rail, and shipping networks, minimizing costs while meeting delivery deadlines</li>
        <li class="academic-text"><strong>Supply chain management:</strong> Manufacturers use flow algorithms to optimize product distribution from factories through warehouses to retail stores, balancing inventory costs with customer demand</li>
        <li class="academic-text"><strong>Resource allocation:</strong> Flow networks solve matching problems like assigning medical residents to hospitals, students to schools, or workers to projects, ensuring optimal allocation under capacity constraints</li>
        <li class="academic-text"><strong>Computer vision:</strong> Image processing algorithms use flow networks for segmentation, object recognition, and medical imaging, separating regions of interest from background noise</li>
        <li class="academic-text"><strong>Financial systems:</strong> Banks and trading systems use flow algorithms to optimize capital allocation, risk management, and transaction processing across complex financial networks</li>
    </ul>
    
    <p class="academic-text">This chapter explores the maximum flow problem - one of the most elegant and practically important optimization problems in computer science. We'll discover how simple flow conservation laws lead to powerful algorithms that solve complex real-world challenges with mathematical precision and computational efficiency.</p>

    <h2 class="section-title" id="ch10-1">10.1 Max Flow Problem and Min-Cut Theorem</h2>
    
    <p class="academic-text">The <strong>maximum flow problem</strong> asks: given a network with capacity constraints, what's the maximum amount of flow we can push from a source to a sink?</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">💧 Flow Network Definition</h3>
        <p class="academic-text">A <strong>flow network</strong> is a directed graph G = (V, E) with:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Capacity function c(u,v):</strong> Maximum flow allowed on edge (u,v)</li>
            <li class="academic-text"><strong>Source s:</strong> Where flow originates (one node)</li>
            <li class="academic-text"><strong>Sink t:</strong> Where flow terminates (one node)</li>
            <li class="academic-text"><strong>Flow f(u,v):</strong> Actual flow on edge (u,v), where 0 ≤ f(u,v) ≤ c(u,v)</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Flow Conservation Rule:</strong> For every node except source and sink, the total flow coming in must equal the total flow going out. Think of it like water - what flows in must flow out!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Simple Flow Network Example (Water Pipes):</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|10| A[Pump A]
            S -->|8| B[Pump B]
            A -->|6| C[Junction]
            A -->|4| D[Tank]
            B -->|5| C
            C -->|7| D
            D -->|15| T[Sink]
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers on edges represent capacity - maximum flow that can pass through</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A flow f is valid if: (1) Capacity constraint: 0 ≤ f(u,v) ≤ c(u,v) for all edges, (2) Flow conservation: Σ f(u,v) = Σ f(v,w) for all v ≠ s,t.
        </div>
    </div>

    <p class="academic-text"><strong>The Min-Cut Max-Flow Theorem</strong></p>
    <p class="academic-text">One of the most beautiful results in graph theory! A <strong>cut</strong> is a partition of vertices into two sets S and T, where source s ∈ S and sink t ∈ T. The capacity of a cut is the sum of capacities of edges going from S to T.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔪 Min-Cut Max-Flow Theorem</h3>
        <p class="academic-text">The maximum flow from s to t equals the minimum capacity of any cut separating s from t.</p>
        <p class="academic-text" style="margin-top: 10px;"><strong>Why it matters:</strong> This theorem tells us that the bottleneck in any network is determined by its weakest cut. Finding max flow also finds the min cut!</p>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Cut Visualization:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Set S (Source Side)"
                S[Source]
                A[Node A]
            end
            
            subgraph "Set T (Sink Side)"
                B[Node B]
                T[Sink]
            end
            
            S -->|5| A
            S -->|3| B
            A -->|4| B
            A -->|2| T
            B -->|6| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cut capacity = edges crossing from S to T: 3 (S→B) + 2 (A→T) = 5. This is the bottleneck!</p>
    </div>

    <h2 class="section-title" id="ch10-2">10.2 Ford-Fulkerson Method</h2>

    <p class="academic-text">The <strong>Ford-Fulkerson method</strong> is a general approach to computing maximum flow. It repeatedly finds augmenting paths (paths from source to sink with available capacity) and pushes flow along them until no more augmenting paths exist.</p>
    
    <p class="academic-text"><strong>Key Concept: Residual Graph</strong></p>
    <p class="academic-text">The residual graph shows remaining capacity. For each edge with flow f and capacity c, the residual capacity is c - f. We also add backward edges with capacity f (allowing us to "undo" flow).</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Ford-Fulkerson Algorithm Steps:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Initialize:</strong> Start with zero flow on all edges</li>
            <li style="margin-bottom: 8px;"><strong>Find augmenting path:</strong> Search for any path from s to t in residual graph</li>
            <li style="margin-bottom: 8px;"><strong>Compute bottleneck:</strong> Find minimum residual capacity along the path</li>
            <li style="margin-bottom: 8px;"><strong>Augment flow:</strong> Add bottleneck capacity to flow along the path</li>
            <li style="margin-bottom: 8px;"><strong>Repeat:</strong> Continue until no augmenting path exists</li>
        </ol>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Time Complexity:</strong> O(E × max_flow) where E is number of edges. Not polynomial in input size! This is why we need better implementations.
        </div>
    </div>

    <pre class="code-block">// Ford-Fulkerson Method Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
using namespace std;

class FordFulkerson {
private:
    int V; // Number of vertices
    vector&lt;vector&lt;int&gt;&gt; capacity;  // Capacity matrix
    vector&lt;vector&lt;int&gt;&gt; flow;      // Flow matrix
    
    // BFS to find if there's a path from source to sink
    bool bfs(int source, int sink, vector&lt;int&gt;&amp; parent) {
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            for (int v = 0; v &lt; V; v++) {
                // Check if there's residual capacity
                int residual = capacity[u][v] - flow[u][v];
                
                if (!visited[v] &amp;&amp; residual &gt; 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    FordFulkerson(int vertices) : V(vertices) {
        capacity.resize(V, vector&lt;int&gt;(V, 0));
        flow.resize(V, vector&lt;int&gt;(V, 0));
    }
    
    // Add edge with capacity
    void addEdge(int u, int v, int cap) {
        capacity[u][v] = cap;
    }
    
    // Compute maximum flow from source to sink
    int maxFlow(int source, int sink) {
        int totalFlow = 0;
        vector&lt;int&gt; parent(V);
        
        // While there exists an augmenting path
        while (bfs(source, sink, parent)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                int residual = capacity[u][v] - flow[u][v];
                pathFlow = min(pathFlow, residual);
            }
            
            // Update flow along the path
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                flow[u][v] += pathFlow;
                flow[v][u] -= pathFlow; // Backward edge
            }
            
            totalFlow += pathFlow;
        }
        
        return totalFlow;
    }
    
    // Get the min-cut (vertices reachable from source in residual graph)
    vector&lt;int&gt; getMinCut(int source) {
        vector&lt;int&gt; reachable;
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            reachable.push_back(u);
            
            for (int v = 0; v &lt; V; v++) {
                int residual = capacity[u][v] - flow[u][v];
                if (!visited[v] &amp;&amp; residual &gt; 0) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        
        return reachable;
    }
};</pre>

    <h2 class="section-title" id="ch10-3">10.3 Edmonds-Karp Algorithm</h2>

    <p class="academic-text">The <strong>Edmonds-Karp algorithm</strong> is a specific implementation of Ford-Fulkerson that uses BFS to find augmenting paths. This simple choice makes a huge difference - it guarantees polynomial time complexity!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">⚡ Edmonds-Karp Key Insight</h3>
        <p class="academic-text">By always choosing the <strong>shortest augmenting path</strong> (in terms of number of edges) using BFS, we guarantee that the algorithm terminates in O(V × E²) time.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Time Complexity:</strong> O(V × E²) - polynomial!</li>
            <li class="academic-text"><strong>Space Complexity:</strong> O(V²) for adjacency matrix or O(V + E) for adjacency list</li>
            <li class="academic-text"><strong>Why BFS matters:</strong> Shortest paths ensure we don't get stuck in bad augmenting paths</li>
        </ul>
    </div>

    <p class="academic-text"><strong>How Edmonds-Karp Improves Ford-Fulkerson:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Deterministic:</strong> Always finds shortest augmenting path, no arbitrary choices</li>
        <li class="academic-text"><strong>Bounded iterations:</strong> At most O(V × E) augmenting paths</li>
        <li class="academic-text"><strong>Practical:</strong> Works well on real networks, not just theoretical worst cases</li>
    </ul>

    <pre class="code-block">// Edmonds-Karp Algorithm (Ford-Fulkerson with BFS)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;

class EdmondsKarp {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; capacity;
    
    // BFS to find shortest augmenting path
    bool bfs(int source, int sink, vector&lt;int&gt;&amp; parent, 
             vector&lt;vector&lt;int&gt;&gt;&amp; residual) {
        vector&lt;bool&gt; visited(V, false);
        queue&lt;int&gt; q;
        q.push(source);
        visited[source] = true;
        parent[source] = -1;
        
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            
            // Try all neighbors
            for (int v = 0; v &lt; V; v++) {
                if (!visited[v] &amp;&amp; residual[u][v] &gt; 0) {
                    visited[v] = true;
                    parent[v] = u;
                    q.push(v);
                    
                    if (v == sink) return true;
                }
            }
        }
        return false;
    }
    
public:
    EdmondsKarp(int vertices) : V(vertices) {
        capacity.resize(V, vector&lt;int&gt;(V, 0));
    }
    
    void addEdge(int u, int v, int cap) {
        capacity[u][v] += cap; // Handle multiple edges
    }
    
    int maxFlow(int source, int sink) {
        // Create residual graph (initially same as capacity)
        vector&lt;vector&lt;int&gt;&gt; residual = capacity;
        vector&lt;int&gt; parent(V);
        int maxFlowValue = 0;
        
        // While there exists an augmenting path from source to sink
        while (bfs(source, sink, parent, residual)) {
            // Find minimum residual capacity along the path
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            // Update residual capacities
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow; // Add reverse edge
            }
            
            maxFlowValue += pathFlow;
        }
        
        return maxFlowValue;
    }
    
    // Print flow decomposition
    void printFlow(int source, int sink) {
        vector&lt;vector&lt;int&gt;&gt; residual = capacity;
        vector&lt;int&gt; parent(V);
        
        cout &lt;&lt; "Flow paths:" &lt;&lt; endl;
        int pathNum = 1;
        
        while (bfs(source, sink, parent, residual)) {
            int pathFlow = INT_MAX;
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                pathFlow = min(pathFlow, residual[u][v]);
            }
            
            cout &lt;&lt; "Path " &lt;&lt; pathNum++ &lt;&lt; " (flow=" &lt;&lt; pathFlow &lt;&lt; "): ";
            vector&lt;int&gt; path;
            for (int v = sink; v != source; v = parent[v]) {
                path.push_back(v);
            }
            path.push_back(source);
            
            for (int i = path.size() - 1; i &gt;= 0; i--) {
                cout &lt;&lt; path[i];
                if (i &gt; 0) cout &lt;&lt; " -> ";
            }
            cout &lt;&lt; endl;
            
            for (int v = sink; v != source; v = parent[v]) {
                int u = parent[v];
                residual[u][v] -= pathFlow;
                residual[v][u] += pathFlow;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch10-4">10.4 Applications in Logistics and Supply Chain</h2>

    <p class="academic-text">Flow networks aren't just theoretical - they solve real problems every day! Let's explore practical applications that power modern logistics and systems.</p>

    <p class="academic-text"><strong>Application 1: Bipartite Matching</strong></p>
    <p class="academic-text">Matching problems can be modeled as max flow! Connect source to all left nodes, all right nodes to sink, and add edges between compatible pairs with capacity 1.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Job Assignment Problem:</strong><br><br>
        <div class="mermaid">
        graph LR
            S[Source] -->|1| W1[Worker 1]
            S -->|1| W2[Worker 2]
            S -->|1| W3[Worker 3]
            
            W1 -->|1| J1[Job A]
            W1 -->|1| J2[Job B]
            W2 -->|1| J2
            W2 -->|1| J3[Job C]
            W3 -->|1| J1
            W3 -->|1| J3
            
            J1 -->|1| T[Sink]
            J2 -->|1| T
            J3 -->|1| T
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style W1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W2 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style W3 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style J1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J2 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style J3 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Max flow = maximum number of workers that can be assigned to jobs</p>
    </div>

    <p class="academic-text"><strong>Application 2: Supply Chain Optimization</strong></p>
    <p class="academic-text">Model factories as sources, stores as sinks, and distribution centers as intermediate nodes. Edge capacities represent transportation limits.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Multi-source multi-sink:</strong> Add super-source connected to all factories, super-sink connected to all stores</li>
        <li class="academic-text"><strong>Minimize cost:</strong> Use min-cost max-flow algorithms (beyond this chapter)</li>
        <li class="academic-text"><strong>Real-time routing:</strong> Update capacities based on traffic, weather, breakdowns</li>
    </ul>

    <p class="academic-text"><strong>Application 3: Network Reliability</strong></p>
    <p class="academic-text">The min-cut tells us the network's vulnerability! Edges in the min-cut are critical - if they fail, the network is disconnected.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Real-World Applications:</strong><br><br>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Internet routing:</strong> Maximize data throughput between servers</li>
            <li style="margin-bottom: 8px;"><strong>Airline scheduling:</strong> Assign crews to flights efficiently</li>
            <li style="margin-bottom: 8px;"><strong>Image segmentation:</strong> Separate objects from background using graph cuts</li>
            <li style="margin-bottom: 8px;"><strong>Baseball elimination:</strong> Determine if a team can still win the championship</li>
            <li style="margin-bottom: 8px;"><strong>Project selection:</strong> Choose profitable projects with dependencies</li>
        </ul>
    </div>

    <pre class="code-block">// Bipartite Matching using Max Flow
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class BipartiteMatching {
private:
    EdmondsKarp flowNetwork;
    int leftSize, rightSize;
    int source, sink;
    
public:
    BipartiteMatching(int left, int right) 
        : leftSize(left), rightSize(right),
          flowNetwork(left + right + 2) {
        source = 0;
        sink = left + right + 1;
        
        // Connect source to all left nodes
        for (int i = 1; i &lt;= left; i++) {
            flowNetwork.addEdge(source, i, 1);
        }
        
        // Connect all right nodes to sink
        for (int i = 1; i &lt;= right; i++) {
            flowNetwork.addEdge(left + i, sink, 1);
        }
    }
    
    // Add edge from left node to right node
    void addCompatibility(int leftNode, int rightNode) {
        // leftNode: 1 to leftSize
        // rightNode: 1 to rightSize
        flowNetwork.addEdge(leftNode, leftSize + rightNode, 1);
    }
    
    // Find maximum matching
    int maxMatching() {
        return flowNetwork.maxFlow(source, sink);
    }
};

// Example: Job assignment problem
void solveJobAssignment() {
    // 3 workers, 3 jobs
    BipartiteMatching matcher(3, 3);
    
    // Worker 1 can do jobs 1 and 2
    matcher.addCompatibility(1, 1);
    matcher.addCompatibility(1, 2);
    
    // Worker 2 can do jobs 2 and 3
    matcher.addCompatibility(2, 2);
    matcher.addCompatibility(2, 3);
    
    // Worker 3 can do jobs 1 and 3
    matcher.addCompatibility(3, 1);
    matcher.addCompatibility(3, 3);
    
    int maxAssignments = matcher.maxMatching();
    cout &lt;&lt; "Maximum workers that can be assigned: " 
         &lt;&lt; maxAssignments &lt;&lt; endl;
}</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">⚡ Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Ford-Fulkerson</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E × max_flow)</li>
                    <li class="academic-text"><strong>Pro:</strong> Simple to understand</li>
                    <li class="academic-text"><strong>Con:</strong> Can be slow on large flows</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Edmonds-Karp</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V × E²)</li>
                    <li class="academic-text"><strong>Pro:</strong> Polynomial guarantee</li>
                    <li class="academic-text"><strong>Pro:</strong> Practical and reliable</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 10 Complete!</h3>
        <p class="academic-text">You now understand flow networks and optimization:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Max flow problem</strong> - pushing maximum flow through networks</li>
            <li class="academic-text">✅ <strong>Min-cut theorem</strong> - the beautiful duality between flow and cuts</li>
            <li class="academic-text">✅ <strong>Ford-Fulkerson method</strong> - the foundational approach</li>
            <li class="academic-text">✅ <strong>Edmonds-Karp algorithm</strong> - efficient polynomial-time implementation</li>
            <li class="academic-text">✅ <strong>Real applications</strong> - logistics, matching, network design</li>
        </ul>
        
        <p class="academic-text">Flow networks are fundamental to optimization and operations research. These algorithms power everything from internet routing to supply chain management. You've now completed Part III - Advanced Topics!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch11">
        
    <div class="chapter-number">Chapter 11</div>
    <h1 class="chapter-title">Graph Coloring & Matching</h1>
    
    <div class="definition-box">
        "Graph coloring solves scheduling conflicts, while matching pairs resources optimally - two fundamental problems that power everything from exam scheduling to job assignments."
    </div>

    <p class="academic-text">Graph coloring and matching represent two of the most elegant and practically important optimization problems in computer science, solving fundamental challenges that appear everywhere from university scheduling to medical organ allocation. These problems ask seemingly simple questions - "How can we assign labels so no connected items share the same label?" and "How can we pair items optimally?" - but their solutions power critical systems across industries and reveal deep mathematical insights about computational complexity and optimization.</p>
    
    <p class="academic-text">The beauty of coloring and matching problems lies in their universality. The same mathematical framework that helps universities schedule exams without conflicts also enables compilers to optimize code, helps telecommunications companies allocate frequencies, and allows dating apps to suggest compatible matches. These problems demonstrate how abstract graph theory translates directly into practical solutions for resource allocation, conflict resolution, and optimization challenges.</p>

    <p class="academic-text">These problems also showcase the spectrum of computational complexity in computer science. While some instances can be solved efficiently with elegant algorithms, others represent some of the hardest problems in computer science, leading to important insights about what can and cannot be computed efficiently. Understanding these problems gives you insight into both practical algorithm design and fundamental questions about computation itself.</p>
    
    <p class="academic-text"><strong>Coloring and matching algorithms power critical systems across society:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Educational scheduling:</strong> Universities use graph coloring to schedule exams and classes, ensuring no student has time conflicts while minimizing the total scheduling period</li>
        <li class="academic-text"><strong>Compiler optimization:</strong> Modern compilers use graph coloring to assign CPU registers to program variables, maximizing performance by minimizing memory access</li>
        <li class="academic-text"><strong>Telecommunications:</strong> Wireless networks use coloring algorithms to assign frequencies to cell towers, preventing interference while maximizing coverage</li>
        <li class="academic-text"><strong>Healthcare systems:</strong> Organ donation networks use matching algorithms to pair donors with recipients, optimizing compatibility and urgency factors to save lives</li>
        <li class="academic-text"><strong>Online platforms:</strong> Dating apps and professional networking sites use sophisticated matching algorithms to suggest compatible connections based on preferences and compatibility</li>
        <li class="academic-text"><strong>Resource allocation:</strong> Cloud computing platforms use matching algorithms to assign computational tasks to servers, balancing load and minimizing response times</li>
    </ul>
    
    <p class="academic-text">This chapter explores both problems from theoretical foundations to practical implementations, showing how elegant mathematical concepts translate into algorithms that solve real-world challenges with precision and efficiency.</p>

    <h2 class="section-title" id="ch11-1">11.1 Greedy Coloring Algorithms</h2>
    
    <p class="academic-text">The <strong>graph coloring problem</strong> asks: what's the minimum number of colors needed to color all vertices such that no two adjacent vertices have the same color?</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🎨 Graph Coloring Definition</h3>
        <p class="academic-text">A <strong>k-coloring</strong> of graph G = (V, E) is an assignment of k colors to vertices such that:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Valid coloring:</strong> No two adjacent vertices have the same color</li>
            <li class="academic-text"><strong>Chromatic number χ(G):</strong> Minimum k for which a k-coloring exists</li>
            <li class="academic-text"><strong>NP-complete:</strong> Finding χ(G) is computationally hard for general graphs</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Special Cases with Known Chromatic Numbers:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Bipartite graphs:</strong> χ(G) = 2 (two colors suffice)</li>
        <li class="academic-text"><strong>Trees:</strong> χ(G) = 2 (also bipartite)</li>
        <li class="academic-text"><strong>Complete graphs K<sub>n</sub>:</strong> χ(G) = n (every vertex needs unique color)</li>
        <li class="academic-text"><strong>Cycle C<sub>n</sub>:</strong> χ(G) = 2 if n is even, 3 if n is odd</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Graph Coloring Example (Exam Scheduling):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Math] --- B[Physics]
            A --- C[Chemistry]
            B --- C
            B --- D[Biology]
            C --- D
            D --- E[History]
            
            style A fill:#ff6b6b,stroke:#333,stroke-width:2px
            style B fill:#4ecdc4,stroke:#333,stroke-width:2px
            style C fill:#ffe66d,stroke:#333,stroke-width:2px
            style D fill:#ff6b6b,stroke:#333,stroke-width:2px
            style E fill:#4ecdc4,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">3 colors needed: Red (Math, Biology), Blue (Physics, History), Yellow (Chemistry)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Interpretation:</strong> Edges connect courses with common students. Same color = same time slot. This graph needs 3 time slots minimum.
        </div>
    </div>

    <p class="academic-text"><strong>Greedy Coloring Algorithm</strong></p>
    <p class="academic-text">The simplest approach: process vertices one by one, assigning each vertex the smallest color not used by its neighbors. While not optimal, it's fast and gives reasonable results!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Greedy Algorithm Steps:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Order vertices:</strong> Choose an ordering (different orders give different results)</li>
            <li style="margin-bottom: 8px;"><strong>Process each vertex:</strong> Go through vertices in order</li>
            <li style="margin-bottom: 8px;"><strong>Find available color:</strong> Check which colors are used by neighbors</li>
            <li style="margin-bottom: 8px;"><strong>Assign smallest available:</strong> Use the smallest color number not taken</li>
        </ol>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Time Complexity:</strong> O(V + E) - very fast! Space: O(V). Upper bound: Uses at most Δ + 1 colors, where Δ is maximum degree.
        </div>
    </div>

    <pre class="code-block">// Greedy Graph Coloring Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;algorithm&gt;
using namespace std;

class GraphColoring {
private:
    int V; // Number of vertices
    vector&lt;vector&lt;int&gt;&gt; adj; // Adjacency list
    
public:
    GraphColoring(int vertices) : V(vertices) {
        adj.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    // Greedy coloring algorithm
    vector&lt;int&gt; greedyColoring() {
        vector&lt;int&gt; color(V, -1); // -1 means uncolored
        
        // Color first vertex with color 0
        color[0] = 0;
        
        // Color remaining vertices
        for (int u = 1; u &lt; V; u++) {
            // Find colors used by neighbors
            unordered_set&lt;int&gt; usedColors;
            for (int neighbor : adj[u]) {
                if (color[neighbor] != -1) {
                    usedColors.insert(color[neighbor]);
                }
            }
            
            // Find smallest available color
            int availableColor = 0;
            while (usedColors.count(availableColor)) {
                availableColor++;
            }
            
            color[u] = availableColor;
        }
        
        return color;
    }
    
    // Improved: Order by degree (largest first)
    vector&lt;int&gt; greedyColoringLargestFirst() {
        // Create vertex ordering by degree (descending)
        vector&lt;pair&lt;int, int&gt;&gt; degreeVertex;
        for (int i = 0; i &lt; V; i++) {
            degreeVertex.push_back({adj[i].size(), i});
        }
        sort(degreeVertex.rbegin(), degreeVertex.rend());
        
        vector&lt;int&gt; color(V, -1);
        
        // Color vertices in degree order
        for (auto [degree, u] : degreeVertex) {
            unordered_set&lt;int&gt; usedColors;
            for (int neighbor : adj[u]) {
                if (color[neighbor] != -1) {
                    usedColors.insert(color[neighbor]);
                }
            }
            
            int availableColor = 0;
            while (usedColors.count(availableColor)) {
                availableColor++;
            }
            
            color[u] = availableColor;
        }
        
        return color;
    }
    
    // Get chromatic number (number of colors used)
    int getChromaticNumber(const vector&lt;int&gt;&amp; coloring) {
        if (coloring.empty()) return 0;
        return *max_element(coloring.begin(), coloring.end()) + 1;
    }
    
    // Print coloring result
    void printColoring(const vector&lt;int&gt;&amp; coloring) {
        cout &lt;&lt; "Vertex Coloring:" &lt;&lt; endl;
        for (int i = 0; i &lt; V; i++) {
            cout &lt;&lt; "Vertex " &lt;&lt; i &lt;&lt; " -> Color " &lt;&lt; coloring[i] &lt;&lt; endl;
        }
        cout &lt;&lt; "Total colors used: " &lt;&lt; getChromaticNumber(coloring) &lt;&lt; endl;
    }
};</pre>

    <p class="academic-text"><strong>Vertex Ordering Strategies</strong></p>
    <p class="academic-text">The order in which we process vertices dramatically affects the result! Here are common strategies:</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Natural order:</strong> Process vertices 0, 1, 2, ... (simplest, often worst)</li>
        <li class="academic-text"><strong>Largest degree first:</strong> Color high-degree vertices first (often better)</li>
        <li class="academic-text"><strong>Smallest degree last:</strong> Recursively remove smallest degree vertex (Welsh-Powell)</li>
        <li class="academic-text"><strong>Random order:</strong> Try multiple random orderings, keep best</li>
    </ul>

    <h2 class="section-title" id="ch11-2">11.2 Bipartite Matching and Maximum Matching</h2>

    <p class="academic-text">A <strong>matching</strong> in a graph is a set of edges with no common vertices. Think of it as pairing up vertices where each vertex is in at most one pair.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">💑 Matching Definitions</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Matching M:</strong> Set of edges where no two edges share a vertex</li>
            <li class="academic-text"><strong>Maximum matching:</strong> Matching with the largest possible number of edges</li>
            <li class="academic-text"><strong>Perfect matching:</strong> Every vertex is matched (only possible if |V| is even)</li>
            <li class="academic-text"><strong>Maximal matching:</strong> Can't add any more edges (but may not be maximum)</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Matching Example (Job Assignment):</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph Workers
                W1[Alice]
                W2[Bob]
                W3[Carol]
            end
            
            subgraph Jobs
                J1[Designer]
                J2[Developer]
                J3[Manager]
            end
            
            W1 ---|matched| J1
            W1 --- J2
            W2 ---|matched| J2
            W2 --- J3
            W3 ---|matched| J3
            
            style W1 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style W2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style W3 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style J1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style J2 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style J3 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Perfect matching: All 3 workers assigned to jobs. Bold edges show the matching.</p>
    </div>

    <p class="academic-text"><strong>Bipartite Matching via Maximum Flow</strong></p>
    <p class="academic-text">For bipartite graphs, we can find maximum matching using max flow! Convert the matching problem to a flow problem:</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Flow Network Construction:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Add source s:</strong> Connect to all left vertices with capacity 1</li>
            <li style="margin-bottom: 8px;"><strong>Add sink t:</strong> Connect all right vertices to sink with capacity 1</li>
            <li style="margin-bottom: 8px;"><strong>Direct edges:</strong> Make all edges go left → right with capacity 1</li>
            <li style="margin-bottom: 8px;"><strong>Run max flow:</strong> Max flow value = maximum matching size!</li>
        </ol>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why it works:</strong> Capacity 1 ensures each vertex is matched at most once. Integer flow = valid matching.
        </div>
    </div>

    <pre class="code-block">// Bipartite Matching using DFS (Hungarian Algorithm variant)
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
using namespace std;

class BipartiteMatching {
private:
    int leftSize, rightSize;
    vector&lt;vector&lt;int&gt;&gt; adj; // adj[left] = list of compatible right vertices
    vector&lt;int&gt; match; // match[right] = matched left vertex (-1 if unmatched)
    vector&lt;bool&gt; visited;
    
    // Try to find augmenting path from left vertex u
    bool dfs(int u) {
        for (int v : adj[u]) {
            if (visited[v]) continue;
            visited[v] = true;
            
            // If v is unmatched or we can find alternate match for match[v]
            if (match[v] == -1 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
        return false;
    }
    
public:
    BipartiteMatching(int left, int right) 
        : leftSize(left), rightSize(right) {
        adj.resize(left);
        match.resize(right, -1);
    }
    
    // Add edge from left vertex u to right vertex v
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    // Find maximum matching
    int maxMatching() {
        int result = 0;
        
        // Try to find augmenting path for each left vertex
        for (int u = 0; u &lt; leftSize; u++) {
            visited.assign(rightSize, false);
            if (dfs(u)) {
                result++;
            }
        }
        
        return result;
    }
    
    // Get the matching edges
    vector&lt;pair&lt;int, int&gt;&gt; getMatching() {
        vector&lt;pair&lt;int, int&gt;&gt; matching;
        for (int v = 0; v &lt; rightSize; v++) {
            if (match[v] != -1) {
                matching.push_back({match[v], v});
            }
        }
        return matching;
    }
    
    // Check if perfect matching exists
    bool hasPerfectMatching() {
        return maxMatching() == min(leftSize, rightSize);
    }
};</pre>

    <p class="academic-text"><strong>General Graph Matching: Blossom Algorithm</strong></p>
    <p class="academic-text">For non-bipartite graphs, matching is harder! The <strong>Blossom algorithm</strong> (Edmonds, 1965) finds maximum matching in general graphs by handling odd cycles cleverly.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Key insight:</strong> Odd cycles (blossoms) can be contracted into single vertices</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(V²E) - polynomial but complex to implement</li>
        <li class="academic-text"><strong>Applications:</strong> Protein docking, chess tournament pairing, kidney exchange</li>
    </ul>

    <h2 class="section-title" id="ch11-3">11.3 Applications in Scheduling and Resource Allocation</h2>

    <p class="academic-text">Graph coloring and matching solve countless real-world problems. Let's explore practical applications you can implement today!</p>

    <p class="academic-text"><strong>Application 1: Exam Scheduling</strong></p>
    <p class="academic-text">Schedule exams so no student has two exams at the same time. Model as graph coloring!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Exam Scheduling Algorithm:</strong><br><br>
        <ol style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Build conflict graph:</strong> Vertices = exams, edges = common students</li>
            <li style="margin-bottom: 8px;"><strong>Color the graph:</strong> Each color = one time slot</li>
            <li style="margin-bottom: 8px;"><strong>Minimize colors:</strong> Fewer colors = fewer time slots needed</li>
        </ol>
    </div>

    <pre class="code-block">// Exam Scheduling using Graph Coloring
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
using namespace std;

class ExamScheduler {
private:
    vector&lt;string&gt; exams;
    unordered_map&lt;string, int&gt; examIndex;
    GraphColoring graph;
    
public:
    ExamScheduler(const vector&lt;string&gt;&amp; examList) 
        : exams(examList), graph(examList.size()) {
        for (int i = 0; i &lt; exams.size(); i++) {
            examIndex[exams[i]] = i;
        }
    }
    
    // Add conflict: two exams have common students
    void addConflict(const string&amp; exam1, const string&amp; exam2) {
        int u = examIndex[exam1];
        int v = examIndex[exam2];
        graph.addEdge(u, v);
    }
    
    // Schedule exams and return time slots
    unordered_map&lt;string, int&gt; scheduleExams() {
        vector&lt;int&gt; coloring = graph.greedyColoringLargestFirst();
        
        unordered_map&lt;string, int&gt; schedule;
        for (int i = 0; i &lt; exams.size(); i++) {
            schedule[exams[i]] = coloring[i];
        }
        
        return schedule;
    }
    
    // Print schedule by time slot
    void printSchedule() {
        auto schedule = scheduleExams();
        
        // Group by time slot
        unordered_map&lt;int, vector&lt;string&gt;&gt; slots;
        for (const auto&amp; [exam, slot] : schedule) {
            slots[slot].push_back(exam);
        }
        
        cout &lt;&lt; "Exam Schedule:" &lt;&lt; endl;
        for (const auto&amp; [slot, examList] : slots) {
            cout &lt;&lt; "Time Slot " &lt;&lt; slot &lt;&lt; ": ";
            for (const string&amp; exam : examList) {
                cout &lt;&lt; exam &lt;&lt; " ";
            }
            cout &lt;&lt; endl;
        }
        cout &lt;&lt; "Total time slots needed: " &lt;&lt; slots.size() &lt;&lt; endl;
    }
};</pre>

    <p class="academic-text"><strong>Application 2: Register Allocation in Compilers</strong></p>
    <p class="academic-text">CPUs have limited registers. Compilers use graph coloring to assign variables to registers!</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Program variables</li>
        <li class="academic-text"><strong>Edges:</strong> Variables that are "live" at the same time (can't share register)</li>
        <li class="academic-text"><strong>Colors:</strong> CPU registers (typically 8-32 available)</li>
        <li class="academic-text"><strong>Spilling:</strong> If not enough colors, store some variables in memory</li>
    </ul>

    <p class="academic-text"><strong>Application 3: Task Scheduling with Dependencies</strong></p>
    <p class="academic-text">Schedule tasks on multiple processors, respecting dependencies and resource constraints.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Scheduling Strategy:</strong><br><br>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Topological sort:</strong> Order tasks by dependencies</li>
            <li style="margin-bottom: 8px;"><strong>Build conflict graph:</strong> Tasks that can't run simultaneously</li>
            <li style="margin-bottom: 8px;"><strong>Color graph:</strong> Each color = one processor/time slot</li>
            <li style="margin-bottom: 8px;"><strong>Assign tasks:</strong> Schedule according to coloring</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Application 4: Frequency Assignment in Wireless Networks</strong></p>
    <p class="academic-text">Assign radio frequencies to cell towers so nearby towers don't interfere.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Cell towers</li>
        <li class="academic-text"><strong>Edges:</strong> Towers within interference range</li>
        <li class="academic-text"><strong>Colors:</strong> Radio frequencies</li>
        <li class="academic-text"><strong>Goal:</strong> Minimize frequencies used (expensive resource!)</li>
    </ul>

    <pre class="code-block">// Job Assignment using Bipartite Matching
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

class JobAssignment {
private:
    vector&lt;string&gt; workers;
    vector&lt;string&gt; jobs;
    unordered_map&lt;string, int&gt; workerIndex;
    unordered_map&lt;string, int&gt; jobIndex;
    BipartiteMatching matcher;
    
public:
    JobAssignment(const vector&lt;string&gt;&amp; workerList, 
                  const vector&lt;string&gt;&amp; jobList)
        : workers(workerList), jobs(jobList),
          matcher(workerList.size(), jobList.size()) {
        
        for (int i = 0; i &lt; workers.size(); i++) {
            workerIndex[workers[i]] = i;
        }
        for (int i = 0; i &lt; jobs.size(); i++) {
            jobIndex[jobs[i]] = i;
        }
    }
    
    // Add skill: worker can do this job
    void addSkill(const string&amp; worker, const string&amp; job) {
        int w = workerIndex[worker];
        int j = jobIndex[job];
        matcher.addEdge(w, j);
    }
    
    // Find optimal assignment
    vector&lt;pair&lt;string, string&gt;&gt; assignJobs() {
        auto matching = matcher.getMatching();
        
        vector&lt;pair&lt;string, string&gt;&gt; assignment;
        for (auto [w, j] : matching) {
            assignment.push_back({workers[w], jobs[j]});
        }
        
        return assignment;
    }
    
    // Print assignment
    void printAssignment() {
        auto assignment = assignJobs();
        
        cout &lt;&lt; "Job Assignments:" &lt;&lt; endl;
        for (const auto&amp; [worker, job] : assignment) {
            cout &lt;&lt; worker &lt;&lt; " -> " &lt;&lt; job &lt;&lt; endl;
        }
        
        int unassigned = workers.size() - assignment.size();
        if (unassigned &gt; 0) {
            cout &lt;&lt; unassigned &lt;&lt; " workers remain unassigned" &lt;&lt; endl;
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">⚡ Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Graph Coloring</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Greedy:</strong> O(V + E), fast but approximate</li>
                    <li class="academic-text"><strong>Optimal:</strong> NP-complete in general</li>
                    <li class="academic-text"><strong>Use case:</strong> Scheduling, register allocation</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Matching</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Bipartite:</strong> O(V²E), polynomial</li>
                    <li class="academic-text"><strong>General:</strong> O(V²E) with Blossom</li>
                    <li class="academic-text"><strong>Use case:</strong> Assignment, pairing</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 11 Complete!</h3>
        <p class="academic-text">You now understand graph coloring and matching:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Graph coloring</strong> - assign labels to avoid conflicts</li>
            <li class="academic-text">✅ <strong>Greedy algorithms</strong> - fast approximate coloring methods</li>
            <li class="academic-text">✅ <strong>Bipartite matching</strong> - optimal pairing in two-sided graphs</li>
            <li class="academic-text">✅ <strong>Maximum matching</strong> - finding largest possible matchings</li>
            <li class="academic-text">✅ <strong>Real applications</strong> - scheduling, resource allocation, job assignment</li>
        </ul>
        
        <p class="academic-text">These problems appear everywhere in computer science and operations research. From exam scheduling to compiler optimization to dating apps, coloring and matching provide elegant solutions to complex pairing and assignment problems!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch12">
        
    <div class="chapter-number">Chapter 12</div>
    <h1 class="chapter-title">Advanced Graph Concepts</h1>
    
    <div class="definition-box">
        "Understanding critical connections, strongly connected components, and special paths reveals the deep structure and vulnerabilities of networks."
    </div>

    <p class="academic-text">Advanced graph concepts reveal the hidden architecture and vulnerabilities that lie beneath the surface of complex networks. While basic graph algorithms help us navigate and optimize networks, these advanced concepts help us understand their fundamental structure, identify critical failure points, and discover special properties that enable sophisticated applications. These insights are crucial for designing resilient systems, analyzing network security, and solving complex optimization problems that appear in everything from circuit design to social network analysis.</p>
    
    <p class="academic-text">The concepts we'll explore represent some of the most elegant and practically important discoveries in graph theory. They reveal how networks can be decomposed into fundamental components, how to identify the most critical connections, and how to find special paths with unique properties. Understanding these concepts gives you the tools to analyze network robustness, design fault-tolerant systems, and solve optimization problems that would be intractable without these mathematical insights.</p>

    <p class="academic-text">These advanced concepts also showcase the deep mathematical beauty of graph theory, where simple definitions lead to profound insights about connectivity, structure, and optimization. The algorithms we'll study don't just solve abstract problems - they provide the foundation for critical infrastructure analysis, security assessment, and system design in domains ranging from telecommunications to transportation to social media.</p>
    
    <p class="academic-text"><strong>Advanced graph concepts power critical analysis and design across industries:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Infrastructure resilience:</strong> Network engineers use articulation points and bridges to identify critical connections whose failure would disconnect entire regions, enabling strategic redundancy planning</li>
        <li class="academic-text"><strong>Social network analysis:</strong> Platforms like Facebook and LinkedIn use strongly connected components to identify tight-knit communities and influential users who bridge different social groups</li>
        <li class="academic-text"><strong>Manufacturing optimization:</strong> Circuit designers use Eulerian paths to create efficient manufacturing processes that draw circuit patterns without backtracking, minimizing production time and costs</li>
        <li class="academic-text"><strong>Logistics and delivery:</strong> Companies use Hamiltonian path concepts to design delivery routes that visit all locations exactly once, optimizing fuel consumption and delivery times</li>
        <li class="academic-text"><strong>Cybersecurity analysis:</strong> Security researchers use graph decomposition to understand how malware spreads through networks and identify critical nodes for defense strategies</li>
        <li class="academic-text"><strong>Biological systems:</strong> Researchers analyze protein interaction networks and genetic pathways using these concepts to understand cellular processes and disease mechanisms</li>
    </ul>
    
    <p class="academic-text">These concepts represent the cutting edge of practical graph theory, where mathematical elegance meets real-world problem solving to create systems that are both robust and efficient.</p>

    <h2 class="section-title" id="ch12-1">12.1 Articulation Points and Bridges</h2>
    
    <p class="academic-text"><strong>Articulation points</strong> (cut vertices) and <strong>bridges</strong> (cut edges) are critical elements whose removal disconnects the graph. They represent single points of failure in networks!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Critical Connections</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Articulation point:</strong> A vertex whose removal increases the number of connected components</li>
            <li class="academic-text"><strong>Bridge:</strong> An edge whose removal increases the number of connected components</li>
            <li class="academic-text"><strong>Biconnected component:</strong> A maximal subgraph with no articulation points</li>
            <li class="academic-text"><strong>Critical for:</strong> Network reliability, vulnerability analysis, redundancy planning</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Articulation Points Example (Network Vulnerability):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Server A] --- B[Router B]
            B --- C[Server C]
            B --- D[Server D]
            C --- E[Server E]
            D --- E
            E --- F[Server F]
            
            style B fill:#ff6b6b,stroke:#333,stroke-width:3px
            style E fill:#ff6b6b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Red nodes (B and E) are articulation points - their failure disconnects the network!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why it matters:</strong> If Router B fails, Server A is isolated. If Server E fails, Server F is isolated. These are single points of failure!
        </div>
    </div>

    <p class="academic-text"><strong>Finding Articulation Points: Tarjan's Algorithm</strong></p>
    <p class="academic-text">We use DFS with two key values for each vertex:</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Discovery time (disc):</strong> When we first visit the vertex during DFS</li>
        <li class="academic-text"><strong>Low value (low):</strong> Minimum discovery time reachable from this vertex's subtree</li>
        <li class="academic-text"><strong>Key insight:</strong> A vertex u is an articulation point if it has a child v where low[v] ≥ disc[u]</li>
    </ul>

    <pre class="code-block">// Articulation Points and Bridges using Tarjan's Algorithm
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class ArticulationPoints {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;bool&gt; visited;
    vector&lt;int&gt; disc, low, parent;
    vector&lt;bool&gt; isAP;
    vector&lt;pair&lt;int, int&gt;&gt; bridges;
    int timer;
    
    void dfs(int u) {
        visited[u] = true;
        disc[u] = low[u] = timer++;
        int children = 0;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                children++;
                parent[v] = u;
                dfs(v);
                
                low[u] = min(low[u], low[v]);
                
                // Check articulation point
                if (parent[u] == -1 && children &gt; 1) {
                    isAP[u] = true;
                }
                if (parent[u] != -1 && low[v] &gt;= disc[u]) {
                    isAP[u] = true;
                }
                
                // Check bridge
                if (low[v] &gt; disc[u]) {
                    bridges.push_back({u, v});
                }
            }
            else if (v != parent[u]) {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    
public:
    ArticulationPoints(int vertices) : V(vertices), timer(0) {
        adj.resize(V);
        visited.resize(V, false);
        disc.resize(V);
        low.resize(V);
        parent.resize(V, -1);
        isAP.resize(V, false);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    void findArticulationPoints() {
        for (int i = 0; i &lt; V; i++) {
            if (!visited[i]) dfs(i);
        }
    }
    
    vector&lt;int&gt; getArticulationPoints() {
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; V; i++) {
            if (isAP[i]) result.push_back(i);
        }
        return result;
    }
    
    vector&lt;pair&lt;int, int&gt;&gt; getBridges() {
        return bridges;
    }
};</pre>

    <h2 class="section-title" id="ch12-2">12.2 Tarjan's Algorithm for SCCs</h2>

    <p class="academic-text"><strong>Strongly Connected Components (SCCs)</strong> are maximal subgraphs where every vertex can reach every other vertex. Tarjan's algorithm finds all SCCs in a single DFS pass!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔄 Strongly Connected Components</h3>
        <p class="academic-text">In a directed graph, an SCC is a maximal set of vertices where:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Mutual reachability:</strong> For any two vertices u, v, there's a path u → v and v → u</li>
            <li class="academic-text"><strong>Maximal:</strong> Adding any other vertex breaks the property</li>
            <li class="academic-text"><strong>Applications:</strong> Web clustering, social communities, dependency analysis</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>SCC Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] --> B[B]
            B --> C[C]
            C --> A
            D[D] --> E[E]
            E --> F[F]
            F --> D
            B --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two SCCs: {A, B, C} and {D, E, F}</p>
    </div>

    <pre class="code-block">// Tarjan's Algorithm for SCCs
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;

class TarjanSCC {
private:
    int V, timer;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;bool&gt; onStack, visited;
    vector&lt;int&gt; disc, low;
    stack&lt;int&gt; st;
    vector&lt;vector&lt;int&gt;&gt; sccs;
    
    void dfs(int u) {
        disc[u] = low[u] = timer++;
        visited[u] = true;
        st.push(u);
        onStack[u] = true;
        
        for (int v : adj[u]) {
            if (!visited[v]) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            }
            else if (onStack[v]) {
                low[u] = min(low[u], disc[v]);
            }
        }
        
        if (low[u] == disc[u]) {
            vector&lt;int&gt; scc;
            int v;
            do {
                v = st.top();
                st.pop();
                onStack[v] = false;
                scc.push_back(v);
            } while (v != u);
            sccs.push_back(scc);
        }
    }
    
public:
    TarjanSCC(int vertices) : V(vertices), timer(0) {
        adj.resize(V);
        onStack.resize(V, false);
        visited.resize(V, false);
        disc.resize(V);
        low.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    vector&lt;vector&lt;int&gt;&gt; findSCCs() {
        for (int i = 0; i &lt; V; i++) {
            if (!visited[i]) dfs(i);
        }
        return sccs;
    }
};</pre>

    <h2 class="section-title" id="ch12-3">12.3 Eulerian and Hamiltonian Paths</h2>

    <p class="academic-text">Two famous path problems with very different difficulty levels!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🛤️ Special Paths</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Eulerian path:</strong> Visits every <em>edge</em> exactly once</li>
            <li class="academic-text"><strong>Eulerian circuit:</strong> Eulerian path that starts and ends at same vertex</li>
            <li class="academic-text"><strong>Hamiltonian path:</strong> Visits every <em>vertex</em> exactly once</li>
            <li class="academic-text"><strong>Hamiltonian cycle:</strong> Hamiltonian path that returns to start</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Eulerian Paths: Easy to Check!</strong></p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Eulerian Path Conditions:</strong><br><br>
        <p style="margin: 10px 0; font-family: sans-serif; font-size: 12pt;"><strong>Undirected Graph:</strong></p>
        <ul style="margin: 10px 0 10px 24px; font-family: sans-serif; font-size: 12pt;">
            <li style="margin-bottom: 8px;"><strong>Eulerian circuit:</strong> All vertices have even degree</li>
            <li style="margin-bottom: 8px;"><strong>Eulerian path:</strong> Exactly 0 or 2 vertices have odd degree</li>
        </ul>
    </div>

    <pre class="code-block">// Eulerian Path Detection
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class EulerianPath {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;int&gt; degree;
    
public:
    EulerianPath(int vertices) : V(vertices) {
        adj.resize(V);
        degree.resize(V, 0);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
        degree[u]++;
        degree[v]++;
    }
    
    int checkEulerian() {
        int oddCount = 0;
        for (int i = 0; i &lt; V; i++) {
            if (degree[i] % 2 != 0) oddCount++;
        }
        
        if (oddCount == 0) return 2; // Circuit
        if (oddCount == 2) return 1; // Path
        return 0; // Neither
    }
};</pre>

    <p class="academic-text"><strong>Hamiltonian Paths: NP-Complete!</strong></p>
    <p class="academic-text">Unlike Eulerian paths, determining if a Hamiltonian path exists is NP-complete - no efficient algorithm is known!</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Applications:</strong> Traveling salesman, DNA sequencing, circuit routing</li>
        <li class="academic-text"><strong>Approaches:</strong> Backtracking O(n!), DP O(2^n × n), heuristics</li>
    </ul>

    <h2 class="section-title" id="ch12-4">12.4 Network Reliability Analysis</h2>

    <p class="academic-text">Combining concepts to analyze real-world network reliability.</p>

    <p class="academic-text"><strong>Network Reliability Metrics:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertex connectivity:</strong> Minimum vertices to remove to disconnect</li>
        <li class="academic-text"><strong>Edge connectivity:</strong> Minimum edges to remove to disconnect</li>
        <li class="academic-text"><strong>Articulation points:</strong> Single points of failure</li>
        <li class="academic-text"><strong>Bridges:</strong> Critical connections</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">⚡ Algorithm Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Articulation Points</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Method:</strong> DFS with low values</li>
                    <li class="academic-text"><strong>Use:</strong> Find critical nodes</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Tarjan's SCC</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Method:</strong> Single DFS pass</li>
                    <li class="academic-text"><strong>Use:</strong> Find communities</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 12 Complete!</h3>
        <p class="academic-text">You now understand advanced graph concepts:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Articulation points & bridges</strong> - critical network elements</li>
            <li class="academic-text">✅ <strong>Tarjan's SCC algorithm</strong> - finding strongly connected components</li>
            <li class="academic-text">✅ <strong>Eulerian paths</strong> - visiting every edge once</li>
            <li class="academic-text">✅ <strong>Hamiltonian paths</strong> - visiting every vertex once</li>
            <li class="academic-text">✅ <strong>Network reliability</strong> - analyzing system vulnerabilities</li>
        </ul>
        
        <p class="academic-text">These advanced concepts reveal the deep structure of networks and help identify vulnerabilities, communities, and special properties. You've completed Part III - Advanced Topics!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch13">
        
    <div class="chapter-number">Chapter 13</div>
    <h1 class="chapter-title">Graphs in Computer Science</h1>
    
    <div class="definition-box">
        "Graphs are the invisible backbone of computer science - from compilers to operating systems to AI, they power the systems you use every day."
    </div>

    <p class="academic-text">Graphs represent the invisible mathematical foundation that makes modern computing possible. Every time you compile a program, browse the web, train a neural network, or even boot your computer, you're witnessing the power of graph algorithms in action. Far from being abstract mathematical curiosities, graphs are the fundamental data structures that enable compilers to optimize code, operating systems to manage resources, databases to execute queries efficiently, and AI systems to learn and reason about complex relationships.</p>
    
    <p class="academic-text">The ubiquity of graphs in computer science stems from their unique ability to model relationships, dependencies, and structures that are inherent in computational systems. Whether it's the hierarchical structure of a program's syntax, the complex dependencies between software modules, the interconnected nature of web pages, or the layered architecture of neural networks, graphs provide the mathematical framework that makes these systems tractable and optimizable.</p>

    <p class="academic-text">Understanding how graphs power computer science will fundamentally change how you approach system design, debugging, and optimization. You'll begin to see the graph structures underlying every system you work with, enabling you to leverage decades of graph algorithm research to solve complex problems efficiently. This perspective transforms you from a user of systems to an architect who understands the mathematical principles that make those systems work.</p>
    
    <p class="academic-text"><strong>Graphs form the mathematical backbone of every major computer science domain:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Compiler design:</strong> Abstract syntax trees, control flow graphs, and dependency analysis enable compilers to transform and optimize code while preserving correctness</li>
        <li class="academic-text"><strong>Operating systems:</strong> Process scheduling, memory management, and resource allocation all rely on graph algorithms to manage system resources efficiently</li>
        <li class="academic-text"><strong>Database systems:</strong> Query optimization, indexing strategies, and transaction management use graph structures to ensure fast, consistent data access</li>
        <li class="academic-text"><strong>Artificial intelligence:</strong> Neural networks, knowledge graphs, and search algorithms use graph structures to represent and reason about complex relationships</li>
        <li class="academic-text"><strong>Network systems:</strong> Internet protocols, distributed systems, and cloud computing architectures rely on graph algorithms for routing, load balancing, and fault tolerance</li>
        <li class="academic-text"><strong>Software engineering:</strong> Dependency management, version control, and software architecture analysis all use graph structures to manage complexity in large systems</li>
    </ul>
    
    <p class="academic-text">Mastering these applications will give you the tools to design better systems, debug complex problems, and optimize performance across every domain of computer science.</p>

    <h2 class="section-title" id="ch13-1">13.1 Compilers and Abstract Syntax Trees</h2>
    
    <p class="academic-text">When you write code and hit compile, the compiler performs an intricate dance of graph transformations. It builds multiple interconnected graph structures - Abstract Syntax Trees, Control Flow Graphs, Data Dependency Graphs, and Call Graphs - each revealing different aspects of your program's structure and behavior.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌳 Compiler Graph Structures</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Abstract Syntax Tree (AST):</strong> Hierarchical tree representing program structure and operator precedence</li>
            <li class="academic-text"><strong>Control Flow Graph (CFG):</strong> Directed graph showing all possible execution paths through code</li>
            <li class="academic-text"><strong>Data Dependency Graph:</strong> Shows which operations depend on results of other operations</li>
            <li class="academic-text"><strong>Call Graph:</strong> Directed graph of function call relationships</li>
            <li class="academic-text"><strong>Interference Graph:</strong> Used for register allocation via graph coloring</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Abstract Syntax Trees: The Foundation</strong></p>
    <p class="academic-text">An AST is the first major graph structure a compiler builds. It transforms your linear source code into a tree that captures the hierarchical structure of expressions, statements, and declarations. Each node represents a construct in your code - operators, literals, variables, function calls - and edges represent the relationships between them.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>AST Example: Expression "a + b * c"</strong><br><br>
        <div class="mermaid">
        graph TD
            A[+ operator] --> B[variable: a]
            A --> C[* operator]
            C --> D[variable: b]
            C --> E[variable: c]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Tree structure automatically respects operator precedence: * is evaluated before +</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why trees?</strong> The tree structure naturally represents nested expressions and operator precedence. Post-order traversal gives us the evaluation order!
        </div>
    </div>

    <pre class="code-block">// Comprehensive AST Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
using namespace std;

enum class NodeType {
    NUMBER, VARIABLE, BINARY_OP, UNARY_OP, 
    ASSIGNMENT, IF_STMT, WHILE_LOOP, FUNCTION_CALL
};

class ASTNode {
public:
    NodeType type;
    string value;
    vector&lt;shared_ptr&lt;ASTNode&gt;&gt; children;
    
    ASTNode(NodeType t, string v = "") : type(t), value(v) {}
    
    void addChild(shared_ptr&lt;ASTNode&gt; child) {
        children.push_back(child);
    }
    
    // Evaluate expression tree with variable context
    double evaluate(unordered_map&lt;string, double&gt;&amp; variables) {
        switch (type) {
            case NodeType::NUMBER:
                return stod(value);
                
            case NodeType::VARIABLE:
                if (variables.find(value) != variables.end()) {
                    return variables[value];
                }
                throw runtime_error("Undefined variable: " + value);
                
            case NodeType::BINARY_OP: {
                double left = children[0]-&gt;evaluate(variables);
                double right = children[1]-&gt;evaluate(variables);
                
                if (value == "+") return left + right;
                if (value == "-") return left - right;
                if (value == "*") return left * right;
                if (value == "/") {
                    if (right == 0) throw runtime_error("Division by zero");
                    return left / right;
                }
                if (value == "^") return pow(left, right);
                break;
            }
            
            case NodeType::UNARY_OP: {
                double operand = children[0]-&gt;evaluate(variables);
                if (value == "-") return -operand;
                if (value == "!") return !operand;
                break;
            }
            
            case NodeType::ASSIGNMENT: {
                double val = children[0]-&gt;evaluate(variables);
                variables[value] = val;
                return val;
            }
            
            default:
                break;
        }
        return 0;
    }
    
    // Generate code from AST (simple example)
    string generateCode(int indent = 0) {
        string indentation(indent * 2, ' ');
        string code;
        
        switch (type) {
            case NodeType::BINARY_OP:
                code = "(" + children[0]-&gt;generateCode() + " " + 
                       value + " " + children[1]-&gt;generateCode() + ")";
                break;
                
            case NodeType::NUMBER:
            case NodeType::VARIABLE:
                code = value;
                break;
                
            case NodeType::ASSIGNMENT:
                code = value + " = " + children[0]-&gt;generateCode();
                break;
                
            default:
                code = "/* unhandled */";
        }
        return code;
    }
    
    // Pretty print the tree structure
    void print(int depth = 0) {
        for (int i = 0; i &lt; depth; i++) cout &lt;&lt; "  ";
        
        cout &lt;&lt; "[" &lt;&lt; typeToString(type) &lt;&lt; "] ";
        if (!value.empty()) cout &lt;&lt; value;
        cout &lt;&lt; endl;
        
        for (auto&amp; child : children) {
            child-&gt;print(depth + 1);
        }
    }
    
private:
    string typeToString(NodeType t) {
        switch (t) {
            case NodeType::NUMBER: return "NUM";
            case NodeType::VARIABLE: return "VAR";
            case NodeType::BINARY_OP: return "BINOP";
            case NodeType::UNARY_OP: return "UNOP";
            case NodeType::ASSIGNMENT: return "ASSIGN";
            default: return "UNKNOWN";
        }
    }
};

// Build AST for: result = a + b * c
shared_ptr&lt;ASTNode&gt; buildExampleAST() {
    // Create assignment node
    auto assignment = make_shared&lt;ASTNode&gt;(NodeType::ASSIGNMENT, "result");
    
    // Create expression: a + (b * c)
    auto plus = make_shared&lt;ASTNode&gt;(NodeType::BINARY_OP, "+");
    auto a = make_shared&lt;ASTNode&gt;(NodeType::VARIABLE, "a");
    auto mult = make_shared&lt;ASTNode&gt;(NodeType::BINARY_OP, "*");
    auto b = make_shared&lt;ASTNode&gt;(NodeType::VARIABLE, "b");
    auto c = make_shared&lt;ASTNode&gt;(NodeType::VARIABLE, "c");
    
    // Build tree structure
    mult-&gt;addChild(b);
    mult-&gt;addChild(c);
    plus-&gt;addChild(a);
    plus-&gt;addChild(mult);
    assignment-&gt;addChild(plus);
    
    return assignment;
}</pre>

    <p class="academic-text"><strong>Control Flow Graphs: Execution Paths</strong></p>
    <p class="academic-text">While ASTs represent program structure, Control Flow Graphs (CFGs) represent program behavior. A CFG is a directed graph where each node is a basic block (sequence of instructions with no branches except at the end), and edges represent possible control flow between blocks.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>CFG Example: If-Else with Loop</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Entry] --> B{if x &gt; 0}
            B -->|true| C[y = x * 2]
            B -->|false| D[y = -x]
            C --> E{while y &gt; 10}
            D --> E
            E -->|true| F[y = y - 1]
            F --> E
            E -->|false| G[return y]
            G --> H[Exit]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style H fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">CFG shows all possible execution paths. Notice the loop creates a cycle!</p>
    </div>

    <p class="academic-text"><strong>Compiler Optimizations Using Graphs:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Dead code elimination:</strong> Find unreachable nodes in CFG using DFS</li>
        <li class="academic-text"><strong>Loop detection:</strong> Find cycles in CFG using cycle detection algorithms</li>
        <li class="academic-text"><strong>Register allocation:</strong> Build interference graph, color it to assign registers</li>
        <li class="academic-text"><strong>Constant propagation:</strong> Data flow analysis through CFG</li>
        <li class="academic-text"><strong>Common subexpression elimination:</strong> Find duplicate subtrees in AST</li>
        <li class="academic-text"><strong>Inlining:</strong> Merge call graph nodes to eliminate function call overhead</li>
    </ul>

    <h2 class="section-title" id="ch13-2">13.2 Operating Systems: Scheduling and Deadlock Detection</h2>

    <p class="academic-text">Operating systems are masters of graph algorithms! They use graphs to manage resources, detect deadlocks, schedule processes, and ensure system stability. Understanding these graph-based techniques is crucial for building reliable concurrent systems.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">⚙️ OS Graph Applications</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Resource Allocation Graph:</strong> Tracks which processes hold which resources</li>
            <li class="academic-text"><strong>Wait-For Graph:</strong> Shows which processes are waiting for others</li>
            <li class="academic-text"><strong>Process Dependency Graph:</strong> Models task dependencies for scheduling</li>
            <li class="academic-text"><strong>Deadlock Detection:</strong> Cycle detection in resource graphs</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Resource Allocation Graphs</strong></p>
    <p class="academic-text">A Resource Allocation Graph (RAG) is a directed bipartite graph with two types of nodes: processes and resources. Edges represent either resource requests or allocations. A cycle in this graph indicates potential deadlock!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Resource Allocation Graph (Deadlock Scenario):</strong><br><br>
        <div class="mermaid">
        graph LR
            P1[Process 1] -->|requests| R2[Resource 2]
            R2 -->|held by| P2[Process 2]
            P2 -->|requests| R1[Resource 1]
            R1 -->|held by| P1
            
            style P1 fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style P2 fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style R1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style R2 fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Cycle detected: P1 → R2 → P2 → R1 → P1. This is a deadlock!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Deadlock conditions:</strong> A cycle in the RAG indicates deadlock when resources have single instances. With multiple instances, we need Banker's algorithm for detection.
        </div>
    </div>

    <pre class="code-block">// Comprehensive Deadlock Detection System
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;algorithm&gt;
using namespace std;

class DeadlockDetector {
private:
    int numProcesses, numResources;
    vector&lt;vector&lt;int&gt;&gt; waitForGraph;
    vector&lt;int&gt; available;
    vector&lt;vector&lt;int&gt;&gt; allocation, request;
    
    bool hasCycleDFS(int node, vector&lt;bool&gt;&amp; visited, 
                     vector&lt;bool&gt;&amp; recStack, vector&lt;int&gt;&amp; cycle) {
        visited[node] = true;
        recStack[node] = true;
        cycle.push_back(node);
        
        for (int neighbor : waitForGraph[node]) {
            if (!visited[neighbor]) {
                if (hasCycleDFS(neighbor, visited, recStack, cycle))
                    return true;
            }
            else if (recStack[neighbor]) {
                auto it = find(cycle.begin(), cycle.end(), neighbor);
                cycle.erase(cycle.begin(), it);
                return true;
            }
        }
        
        recStack[node] = false;
        cycle.pop_back();
        return false;
    }
    
public:
    DeadlockDetector(int processes, int resources) 
        : numProcesses(processes), numResources(resources) {
        waitForGraph.resize(processes);
        available.resize(resources);
        allocation.resize(processes, vector&lt;int&gt;(resources, 0));
        request.resize(processes, vector&lt;int&gt;(resources, 0));
    }
    
    void addWaitFor(int p1, int p2) {
        waitForGraph[p1].push_back(p2);
    }
    
    bool detectDeadlock(vector&lt;int&gt;&amp; deadlockedProcesses) {
        vector&lt;bool&gt; visited(numProcesses, false);
        vector&lt;bool&gt; recStack(numProcesses, false);
        
        for (int i = 0; i &lt; numProcesses; i++) {
            if (!visited[i]) {
                if (hasCycleDFS(i, visited, recStack, deadlockedProcesses))
                    return true;
            }
        }
        return false;
    }
    
    // Banker's Algorithm for deadlock avoidance
    bool isSafeState() {
        vector&lt;int&gt; work = available;
        vector&lt;bool&gt; finish(numProcesses, false);
        
        for (int count = 0; count &lt; numProcesses; count++) {
            bool found = false;
            for (int p = 0; p &lt; numProcesses; p++) {
                if (!finish[p]) {
                    bool canFinish = true;
                    for (int r = 0; r &lt; numResources; r++) {
                        if (request[p][r] &gt; work[r]) {
                            canFinish = false;
                            break;
                        }
                    }
                    
                    if (canFinish) {
                        for (int r = 0; r &lt; numResources; r++)
                            work[r] += allocation[p][r];
                        finish[p] = true;
                        found = true;
                    }
                }
            }
            if (!found) return false;
        }
        return true;
    }
    
    void printStatus() {
        vector&lt;int&gt; deadlocked;
        if (detectDeadlock(deadlocked)) {
            cout &lt;&lt; "⚠️  DEADLOCK DETECTED!" &lt;&lt; endl;
            cout &lt;&lt; "Deadlocked processes: ";
            for (int p : deadlocked) cout &lt;&lt; "P" &lt;&lt; p &lt;&lt; " ";
            cout &lt;&lt; endl;
        } else {
            cout &lt;&lt; "✓ No deadlock. System safe." &lt;&lt; endl;
        }
    }
};</pre>

    <p class="academic-text"><strong>Process Scheduling with Dependencies</strong></p>
    <p class="academic-text">When processes have dependencies, we model this as a DAG and use topological sorting to determine execution order. This is crucial for parallel task scheduling!</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Task graph:</strong> Vertices = tasks, edges = dependencies</li>
        <li class="academic-text"><strong>Topological sort:</strong> Gives valid execution order</li>
        <li class="academic-text"><strong>Critical path:</strong> Longest path determines minimum time</li>
        <li class="academic-text"><strong>Parallel execution:</strong> Tasks at same level run concurrently</li>
    </ul>

    <h2 class="section-title" id="ch13-3">13.3 Databases and Graph Databases</h2>

    <p class="academic-text">Traditional relational databases struggle with relationship queries - joining tables is expensive! Graph databases solve this by storing data as nodes and edges natively, making traversals orders of magnitude faster.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">💾 Graph Database Concepts</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Entities with properties (people, products, places)</li>
            <li class="academic-text"><strong>Edges:</strong> Relationships with properties (knows, bought, located_in)</li>
            <li class="academic-text"><strong>Labels:</strong> Types/categories for nodes and relationships</li>
            <li class="academic-text"><strong>Index-free adjacency:</strong> Each node directly references neighbors - O(1) traversal!</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Query Execution Plans in Relational Databases</strong></p>
    <p class="academic-text">Before graph databases, let's see how traditional databases use trees! Query optimizers build execution plan trees to find the most efficient way to execute SQL queries.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Query Execution Plan Tree:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[JOIN Users-Orders] --> B[SELECT age &gt; 25]
            A --> C[SELECT city = NYC]
            B --> D[SCAN Users Table]
            C --> E[SCAN Orders Table]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Optimizer chooses order: filter first (reduces data), then join</p>
    </div>

    <p class="academic-text"><strong>Graph Databases: Native Graph Storage</strong></p>
    <p class="academic-text">Graph databases like Neo4j, Amazon Neptune, and ArangoDB store data as graphs natively. This makes relationship traversals extremely fast - O(1) to find neighbors instead of O(log n) joins!</p>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Social Network in Graph Database:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] -->|KNOWS| B[Bob]
            A -->|KNOWS| C[Carol]
            B -->|KNOWS| C
            B -->|WORKS_AT| D[TechCorp]
            C -->|WORKS_AT| D
            A -->|LIKES| E[Product X]
            B -->|BOUGHT| E
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Nodes have labels (Person, Company, Product), edges have types (KNOWS, WORKS_AT, LIKES)</p>
    </div>

    <pre class="code-block">// Simple Graph Database Implementation
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;queue&gt;
using namespace std;

class GraphDatabase {
private:
    struct Node {
        string id, label;
        unordered_map&lt;string, string&gt; properties;
    };
    
    struct Edge {
        string from, to, type;
        unordered_map&lt;string, string&gt; properties;
    };
    
    unordered_map&lt;string, Node&gt; nodes;
    vector&lt;Edge&gt; edges;
    unordered_map&lt;string, vector&lt;Edge*&gt;&gt; outgoing, incoming;
    
public:
    void createNode(string id, string label, 
                    unordered_map&lt;string, string&gt; props = {}) {
        nodes[id] = {id, label, props};
    }
    
    void createRelationship(string from, string to, string type,
                           unordered_map&lt;string, string&gt; props = {}) {
        edges.push_back({from, to, type, props});
        outgoing[from].push_back(&amp;edges.back());
        incoming[to].push_back(&amp;edges.back());
    }
    
    // Find friends of friends (2-hop traversal)
    vector&lt;string&gt; findFriendsOfFriends(string personId) {
        unordered_set&lt;string&gt; result, directFriends;
        
        // Get direct friends
        for (Edge* edge : outgoing[personId]) {
            if (edge-&gt;type == "KNOWS") {
                directFriends.insert(edge-&gt;to);
            }
        }
        
        // Get friends of friends
        for (const string&amp; friendId : directFriends) {
            for (Edge* edge : outgoing[friendId]) {
                if (edge-&gt;type == "KNOWS" &amp;&amp; 
                    edge-&gt;to != personId &amp;&amp;
                    directFriends.find(edge-&gt;to) == directFriends.end()) {
                    result.insert(edge-&gt;to);
                }
            }
        }
        
        return vector&lt;string&gt;(result.begin(), result.end());
    }
    
    // Shortest path (degrees of separation)
    int degreeOfSeparation(string person1, string person2) {
        if (person1 == person2) return 0;
        
        queue&lt;pair&lt;string, int&gt;&gt; q;
        unordered_set&lt;string&gt; visited;
        
        q.push({person1, 0});
        visited.insert(person1);
        
        while (!q.empty()) {
            auto [current, distance] = q.front();
            q.pop();
            
            for (Edge* edge : outgoing[current]) {
                if (edge-&gt;type == "KNOWS") {
                    if (edge-&gt;to == person2) return distance + 1;
                    
                    if (visited.find(edge-&gt;to) == visited.end()) {
                        visited.insert(edge-&gt;to);
                        q.push({edge-&gt;to, distance + 1});
                    }
                }
            }
        }
        return -1; // Not connected
    }
    
    // Recommendation: Products bought by friends
    vector&lt;string&gt; recommendProducts(string personId) {
        unordered_map&lt;string, int&gt; productCount;
        unordered_set&lt;string&gt; alreadyBought;
        
        // Get products this person already bought
        for (Edge* edge : outgoing[personId]) {
            if (edge-&gt;type == "BOUGHT") {
                alreadyBought.insert(edge-&gt;to);
            }
        }
        
        // Get friends
        for (Edge* edge : outgoing[personId]) {
            if (edge-&gt;type == "KNOWS") {
                string friendId = edge-&gt;to;
                
                // Get products bought by friend
                for (Edge* friendEdge : outgoing[friendId]) {
                    if (friendEdge-&gt;type == "BOUGHT") {
                        string productId = friendEdge-&gt;to;
                        if (alreadyBought.find(productId) == alreadyBought.end()) {
                            productCount[productId]++;
                        }
                    }
                }
            }
        }
        
        // Sort by popularity
        vector&lt;pair&lt;int, string&gt;&gt; recommendations;
        for (auto&amp; [product, count] : productCount) {
            recommendations.push_back({count, product});
        }
        sort(recommendations.rbegin(), recommendations.rend());
        
        vector&lt;string&gt; result;
        for (auto&amp; [count, product] : recommendations) {
            result.push_back(product);
        }
        return result;
    }
};</pre>

    <p class="academic-text"><strong>Graph Database Use Cases:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Social networks:</strong> Friend recommendations, influence analysis, community detection</li>
        <li class="academic-text"><strong>Fraud detection:</strong> Find suspicious transaction patterns and networks</li>
        <li class="academic-text"><strong>Knowledge graphs:</strong> Google's knowledge graph, Wikipedia connections</li>
        <li class="academic-text"><strong>Recommendation engines:</strong> "People who bought X also bought Y"</li>
        <li class="academic-text"><strong>Network management:</strong> IT infrastructure, dependency tracking</li>
    </ul>

    <h2 class="section-title" id="ch13-4">13.4 AI Search and Machine Learning Computation Graphs</h2>

    <p class="academic-text">AI and machine learning heavily rely on graphs! From search algorithms that explore state spaces to neural networks represented as computation graphs, graphs are fundamental to modern AI.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🤖 AI Graph Applications</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>State space search:</strong> AI problems modeled as graphs of states</li>
            <li class="academic-text"><strong>Computation graphs:</strong> Neural networks as DAGs</li>
            <li class="academic-text"><strong>Game trees:</strong> Minimax for chess, tic-tac-toe</li>
            <li class="academic-text"><strong>Planning:</strong> Action sequences as graph paths</li>
        </ul>
    </div>

    <p class="academic-text"><strong>Neural Networks as Computation Graphs</strong></p>
    <p class="academic-text">Modern deep learning frameworks (TensorFlow, PyTorch) represent neural networks as directed acyclic graphs! Each node is an operation, edges carry data tensors.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Neural Network as DAG:</strong><br><br>
        <div class="mermaid">
        graph LR
            I1[Input 1] --> H1[Hidden 1]
            I2[Input 2] --> H1
            I1 --> H2[Hidden 2]
            I2 --> H2
            H1 --> O[Output]
            H2 --> O
            
            style I1 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style I2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style O fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Topological sort gives execution order!</p>
    </div>

    <p class="academic-text"><strong>Why Graphs for Neural Networks?</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Forward pass:</strong> Topological sort determines computation order</li>
        <li class="academic-text"><strong>Backward pass:</strong> Reverse topological order for backpropagation</li>
        <li class="academic-text"><strong>Automatic differentiation:</strong> Build computation graph, compute gradients automatically</li>
        <li class="academic-text"><strong>Optimization:</strong> Graph transformations optimize execution (fusion, pruning)</li>
        <li class="academic-text"><strong>Parallelization:</strong> Independent nodes can compute in parallel</li>
    </ul>

    <pre class="code-block">// Simple Computation Graph for Neural Network
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;memory&gt;
#include &lt;cmath&gt;
using namespace std;

class ComputationNode {
public:
    string name;
    double value;
    double gradient;
    vector&lt;shared_ptr&lt;ComputationNode&gt;&gt; inputs;
    
    ComputationNode(string n) : name(n), value(0), gradient(0) {}
    
    virtual double forward() = 0;
    virtual void backward() = 0;
};

class InputNode : public ComputationNode {
public:
    InputNode(string name, double val) : ComputationNode(name) {
        value = val;
    }
    
    double forward() override { return value; }
    void backward() override {} // Inputs don't backpropagate
};

class AddNode : public ComputationNode {
public:
    AddNode(string name, shared_ptr&lt;ComputationNode&gt; a, 
            shared_ptr&lt;ComputationNode&gt; b) : ComputationNode(name) {
        inputs = {a, b};
    }
    
    double forward() override {
        value = inputs[0]-&gt;value + inputs[1]-&gt;value;
        return value;
    }
    
    void backward() override {
        // d(a+b)/da = 1, d(a+b)/db = 1
        inputs[0]-&gt;gradient += gradient * 1.0;
        inputs[1]-&gt;gradient += gradient * 1.0;
    }
};

class MultiplyNode : public ComputationNode {
public:
    MultiplyNode(string name, shared_ptr&lt;ComputationNode&gt; a,
                 shared_ptr&lt;ComputationNode&gt; b) : ComputationNode(name) {
        inputs = {a, b};
    }
    
    double forward() override {
        value = inputs[0]-&gt;value * inputs[1]-&gt;value;
        return value;
    }
    
    void backward() override {
        // d(a*b)/da = b, d(a*b)/db = a
        inputs[0]-&gt;gradient += gradient * inputs[1]-&gt;value;
        inputs[1]-&gt;gradient += gradient * inputs[0]-&gt;value;
    }
};

// Example: Build computation graph for f(x,y) = (x + y) * x
void buildAndExecuteGraph() {
    auto x = make_shared&lt;InputNode&gt;("x", 3.0);
    auto y = make_shared&lt;InputNode&gt;("y", 2.0);
    auto sum = make_shared&lt;AddNode&gt;("x+y", x, y);
    auto result = make_shared&lt;MultiplyNode&gt;("(x+y)*x", sum, x);
    
    // Forward pass (topological order)
    x-&gt;forward();
    y-&gt;forward();
    sum-&gt;forward();
    result-&gt;forward();
    
    cout &lt;&lt; "f(3, 2) = " &lt;&lt; result-&gt;value &lt;&lt; endl; // 15
    
    // Backward pass (reverse topological order)
    result-&gt;gradient = 1.0; // df/df = 1
    result-&gt;backward();
    sum-&gt;backward();
    
    cout &lt;&lt; "df/dx = " &lt;&lt; x-&gt;gradient &lt;&lt; endl; // 8
    cout &lt;&lt; "df/dy = " &lt;&lt; y-&gt;gradient &lt;&lt; endl; // 3
}</pre>

    <p class="academic-text"><strong>AI Search Algorithms</strong></p>
    <p class="academic-text">AI search problems model states as graph nodes and actions as edges. A* search uses heuristics to efficiently find paths!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>A* Search State Space:</strong><br><br>
        <div class="mermaid">
        graph TD
            S[Start] -->|cost 1| A[State A]
            S -->|cost 4| B[State B]
            A -->|cost 2| C[State C]
            A -->|cost 3| D[State D]
            B -->|cost 1| D
            C -->|cost 1| G[Goal]
            D -->|cost 2| G
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style G fill:#ffebee,stroke:#f44336,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A* finds optimal path S → A → C → G using heuristic guidance</p>
    </div>

    <h2 class="section-title" id="ch13-5">13.5 Web: PageRank and Social Media Algorithms</h2>

    <p class="academic-text">The web is a massive directed graph with billions of nodes (pages) and edges (links). Google's PageRank revolutionized search by treating link structure as votes of importance!</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 PageRank Intuition</h3>
        <p class="academic-text">A page is important if:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Many pages link to it</strong> (high in-degree)</li>
            <li class="academic-text"><strong>Important pages link to it</strong> (recursive definition!)</li>
        </ul>
        <p class="academic-text">PageRank models a "random surfer" clicking links. A page's rank is the probability the surfer ends up there.</p>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Web Graph Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Page A] --> B[Page B]
            A --> C[Page C]
            B --> C
            C --> A
            D[Page D] --> C
            
            style C fill:#ff6b6b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Page C has highest PageRank - many pages link to it, including important ones!</p>
    </div>

    <pre class="code-block">// Complete PageRank Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;

class PageRank {
private:
    int numPages;
    vector&lt;vector&lt;int&gt;&gt; graph;  // graph[i] = pages that i links to
    vector&lt;int&gt; outDegree;
    
public:
    PageRank(int pages) : numPages(pages) {
        graph.resize(pages);
        outDegree.resize(pages, 0);
    }
    
    void addLink(int from, int to) {
        graph[from].push_back(to);
        outDegree[from]++;
    }
    
    vector&lt;double&gt; calculate(int iterations = 20, 
                              double dampingFactor = 0.85) {
        vector&lt;double&gt; rank(numPages, 1.0 / numPages);
        vector&lt;double&gt; newRank(numPages);
        
        for (int iter = 0; iter &lt; iterations; iter++) {
            // Initialize with teleportation probability
            fill(newRank.begin(), newRank.end(), 
                 (1.0 - dampingFactor) / numPages);
            
            // Distribute rank from each page
            for (int page = 0; page &lt; numPages; page++) {
                if (outDegree[page] &gt; 0) {
                    double contribution = dampingFactor * rank[page] / 
                                         outDegree[page];
                    for (int linkedPage : graph[page]) {
                        newRank[linkedPage] += contribution;
                    }
                } else {
                    // Dangling node - distribute to all pages
                    double contribution = dampingFactor * rank[page] / 
                                         numPages;
                    for (int i = 0; i &lt; numPages; i++) {
                        newRank[i] += contribution;
                    }
                }
            }
            
            // Check convergence
            double diff = 0;
            for (int i = 0; i &lt; numPages; i++) {
                diff += abs(newRank[i] - rank[i]);
            }
            
            rank = newRank;
            
            if (diff &lt; 1e-6) {
                cout &lt;&lt; "Converged after " &lt;&lt; (iter + 1) 
                     &lt;&lt; " iterations" &lt;&lt; endl;
                break;
            }
        }
        
        return rank;
    }
    
    void printRanks() {
        auto ranks = calculate();
        cout &lt;&lt; "PageRank scores:" &lt;&lt; endl;
        for (int i = 0; i &lt; numPages; i++) {
            cout &lt;&lt; "Page " &lt;&lt; i &lt;&lt; ": " &lt;&lt; ranks[i] &lt;&lt; endl;
        }
    }
};</pre>

    <p class="academic-text"><strong>Social Media Graph Algorithms</strong></p>
    <p class="academic-text">Social networks are graphs where users are nodes and relationships are edges. Graph algorithms power every feature you use!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Social Network Features & Algorithms:</strong><br><br>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333;">
                    <th style="text-align: left; padding: 8px;">Feature</th>
                    <th style="text-align: left; padding: 8px;">Graph Algorithm</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding: 8px;">Friend suggestions</td>
                    <td style="padding: 8px;">Friends of friends (2-hop BFS)</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Influencer detection</td>
                    <td style="padding: 8px;">PageRank, degree centrality</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Community detection</td>
                    <td style="padding: 8px;">Strongly connected components</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Content viral spread</td>
                    <td style="padding: 8px;">BFS from source node</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Degrees of separation</td>
                    <td style="padding: 8px;">Shortest path (BFS)</td>
                </tr>
                <tr>
                    <td style="padding: 8px;">Feed ranking</td>
                    <td style="padding: 8px;">Personalized PageRank</td>
                </tr>
            </tbody>
        </table>
    </div>

    <p class="academic-text"><strong>Real-World Impact:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Facebook:</strong> Friend suggestions use graph algorithms on 3+ billion users</li>
        <li class="academic-text"><strong>Twitter:</strong> Trending topics spread through the social graph via BFS</li>
        <li class="academic-text"><strong>LinkedIn:</strong> "People you may know" finds 2nd and 3rd degree connections</li>
        <li class="academic-text"><strong>Instagram:</strong> Explore page uses graph-based recommendations</li>
        <li class="academic-text"><strong>TikTok:</strong> Content recommendation via graph neural networks</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">💡 Key Insights</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Systems</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Compilers use AST & CFG</li>
                    <li class="academic-text">OS uses graphs for deadlock detection</li>
                    <li class="academic-text">Databases optimize with query trees</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">AI & Web</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Neural networks are computation DAGs</li>
                    <li class="academic-text">PageRank ranks web pages</li>
                    <li class="academic-text">Social media powered by graph algorithms</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 13 Complete!</h3>
        <p class="academic-text">You now understand how graphs power computer science:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Compilers</strong> - AST and CFG for code optimization</li>
            <li class="academic-text">✅ <strong>Operating systems</strong> - deadlock detection and scheduling</li>
            <li class="academic-text">✅ <strong>Databases</strong> - graph databases and query optimization</li>
            <li class="academic-text">✅ <strong>AI/ML</strong> - neural networks as computation graphs</li>
            <li class="academic-text">✅ <strong>Web</strong> - PageRank and social media algorithms</li>
        </ul>
        
        <p class="academic-text">Graphs are everywhere in computing - understanding them gives you insight into how modern systems work!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch14">
        
    <div class="chapter-number">Chapter 14</div>
    <h1 class="chapter-title">Pattern Recognition in Graphs</h1>
    
    <div class="definition-box">
        "Finding patterns in graphs reveals hidden structures - from tight-knit communities to influential clusters, these patterns unlock insights about complex networks."
    </div>

    <p class="academic-text">Pattern recognition in graphs represents one of the most powerful and practically important applications of graph theory, transforming vast networks of raw connections into meaningful insights about structure, behavior, and hidden relationships. While individual nodes and edges tell us about local connections, patterns reveal the global organization, community structure, and emergent properties that make complex networks truly fascinating and useful for understanding real-world systems.</p>
    
    <p class="academic-text">The ability to recognize patterns in graphs has revolutionized fields from social media analysis to drug discovery, from fraud detection to recommendation systems. These patterns - cliques, communities, clusters, and structural motifs - represent the fundamental building blocks of complex networks, revealing how systems self-organize, how information flows, and how influence spreads. Understanding these patterns gives you the tools to extract actionable intelligence from any networked system.</p>

    <p class="academic-text">Pattern recognition algorithms also represent some of the most computationally challenging problems in computer science, often requiring sophisticated approximation algorithms and heuristics to handle real-world networks with millions or billions of connections. The techniques we'll explore showcase how theoretical computer science meets practical data analysis to solve problems that would be impossible to tackle manually.</p>
    
    <p class="academic-text"><strong>Pattern recognition unlocks hidden insights across diverse domains:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Social media intelligence:</strong> Platforms like Facebook and Twitter use pattern recognition to identify tight-knit friend groups, detect echo chambers, and understand how information spreads through social networks</li>
        <li class="academic-text"><strong>Biological discovery:</strong> Researchers use graph patterns to discover protein complexes, identify gene regulatory modules, and understand cellular pathways that lead to new drug targets and treatments</li>
        <li class="academic-text"><strong>Business analytics:</strong> Companies use network patterns to segment customers, identify influential users, track viral marketing campaigns, and optimize product recommendations</li>
        <li class="academic-text"><strong>Security and fraud prevention:</strong> Financial institutions and security agencies use pattern recognition to detect money laundering rings, identify terrorist networks, and spot coordinated cyber attacks</li>
        <li class="academic-text"><strong>Scientific collaboration:</strong> Academic institutions analyze collaboration networks to understand research communities, identify emerging fields, and optimize funding allocation</li>
        <li class="academic-text"><strong>Urban planning:</strong> City planners use transportation and communication network patterns to optimize infrastructure, understand traffic flows, and improve public services</li>
    </ul>
    
    <p class="academic-text">These pattern recognition techniques transform raw network data into strategic intelligence, enabling data-driven decisions that would be impossible without understanding the underlying graph structure.</p>

    <h2 class="section-title" id="ch14-1">14.1 Cliques and Complete Subgraphs</h2>
    
    <p class="academic-text">A <strong>clique</strong> is a subset of vertices where every pair is connected - everyone knows everyone! Cliques represent the tightest possible groups in a network and are fundamental to understanding network cohesion.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">👥 Clique Definitions</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Clique:</strong> A complete subgraph where all vertices are pairwise adjacent</li>
            <li class="academic-text"><strong>Maximal clique:</strong> Cannot be extended by adding another vertex</li>
            <li class="academic-text"><strong>Maximum clique:</strong> Largest clique in the graph (by vertex count)</li>
            <li class="academic-text"><strong>Clique number ω(G):</strong> Size of the maximum clique</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Clique Example (Friend Groups):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            A --- D[Dave]
            B --- D
            C --- D
            D --- E[Eve]
            E --- F[Frank]
            
            style A fill:#ff6b6b,stroke:#333,stroke-width:3px
            style B fill:#ff6b6b,stroke:#333,stroke-width:3px
            style C fill:#ff6b6b,stroke:#333,stroke-width:3px
            style D fill:#ff6b6b,stroke:#333,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Red nodes form a 4-clique: {Alice, Bob, Carol, Dave} - everyone is friends with everyone!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why cliques matter:</strong> In social networks, cliques represent tight-knit friend groups. In biology, they represent protein complexes. In collaboration networks, they show research teams.
        </div>
    </div>

    <p class="academic-text"><strong>Finding Cliques: The Challenge</strong></p>
    <p class="academic-text">Finding the maximum clique is NP-complete - one of the hardest problems in computer science! However, we can find all maximal cliques efficiently using the Bron-Kerbosch algorithm.</p>
    
    <pre class="code-block">// Clique Detection using Bron-Kerbosch Algorithm
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_set&gt;
#include &lt;algorithm&gt;
using namespace std;

class CliqueFinder {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;vector&lt;int&gt;&gt; allCliques;
    
    void bronKerbosch(unordered_set&lt;int&gt; R,
                      unordered_set&lt;int&gt; P,
                      unordered_set&lt;int&gt; X) {
        if (P.empty() && X.empty()) {
            vector&lt;int&gt; clique(R.begin(), R.end());
            allCliques.push_back(clique);
            return;
        }
        
        unordered_set&lt;int&gt; candidates = P;
        for (int v : candidates) {
            unordered_set&lt;int&gt; neighbors;
            for (int u : adj[v]) neighbors.insert(u);
            
            unordered_set&lt;int&gt; newR = R;
            newR.insert(v);
            
            unordered_set&lt;int&gt; newP, newX;
            for (int u : P) {
                if (neighbors.count(u)) newP.insert(u);
            }
            for (int u : X) {
                if (neighbors.count(u)) newX.insert(u);
            }
            
            bronKerbosch(newR, newP, newX);
            P.erase(v);
            X.insert(v);
        }
    }
    
public:
    CliqueFinder(int vertices) : V(vertices) {
        adj.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    vector&lt;vector&lt;int&gt;&gt; findAllMaximalCliques() {
        allCliques.clear();
        unordered_set&lt;int&gt; R, P, X;
        for (int i = 0; i &lt; V; i++) P.insert(i);
        bronKerbosch(R, P, X);
        return allCliques;
    }
    
    vector&lt;int&gt; findMaximumClique() {
        auto cliques = findAllMaximalCliques();
        vector&lt;int&gt; maxClique;
        for (const auto&amp; clique : cliques) {
            if (clique.size() &gt; maxClique.size()) {
                maxClique = clique;
            }
        }
        return maxClique;
    }
};</pre>

    <p class="academic-text"><strong>Applications of Clique Detection:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Social networks:</strong> Find tight-knit friend groups</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> Discover protein complexes</li>
        <li class="academic-text"><strong>Collaboration networks:</strong> Identify research teams</li>
        <li class="academic-text"><strong>Fraud detection:</strong> Detect collusion rings</li>
    </ul>

    <h2 class="section-title" id="ch14-2">14.2 Community Detection Algorithms</h2>

    <p class="academic-text">While cliques are perfectly connected, <strong>communities</strong> are more loosely defined groups with more internal connections than external ones. Community detection reveals the modular structure of networks.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🏘️ Community Structure</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Community:</strong> Group of nodes with dense internal connections</li>
            <li class="academic-text"><strong>Modularity:</strong> Measure of community quality</li>
            <li class="academic-text"><strong>Overlapping communities:</strong> Nodes can belong to multiple groups</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Community Structure:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] --- B[B]
            A --- C[C]
            B --- C
            D[D] --- E[E]
            D --- F[F]
            E --- F
            C --- D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two communities with dense internal connections</p>
    </div>

    <pre class="code-block">// Louvain Method for Community Detection
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
using namespace std;

class CommunityDetector {
private:
    int V;
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;int&gt; community;
    double totalEdges;
    
    double calculateModularity() {
        double Q = 0.0;
        double m2 = 2.0 * totalEdges;
        
        for (int i = 0; i &lt; V; i++) {
            for (int j : adj[i]) {
                if (community[i] == community[j]) {
                    double kikj = adj[i].size() * adj[j].size();
                    Q += (1.0 - kikj / m2);
                }
            }
        }
        return Q / m2;
    }
    
public:
    CommunityDetector(int vertices) : V(vertices), totalEdges(0) {
        adj.resize(V);
        community.resize(V);
        for (int i = 0; i &lt; V; i++) community[i] = i;
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
        totalEdges++;
    }
    
    vector&lt;int&gt; detectCommunities() {
        bool improved = true;
        while (improved) {
            improved = false;
            for (int node = 0; node &lt; V; node++) {
                int bestCommunity = community[node];
                // Try moving to neighbor communities
                for (int neighbor : adj[node]) {
                    int newComm = community[neighbor];
                    if (newComm != community[node]) {
                        community[node] = newComm;
                        improved = true;
                        break;
                    }
                }
            }
        }
        return community;
    }
};</pre>

    <h2 class="section-title" id="ch14-3">14.3 Graph Clustering Techniques</h2>

    <p class="academic-text">Graph clustering groups similar nodes together based on various similarity metrics. Unlike community detection which focuses on connectivity patterns, clustering can use node attributes, structural roles, or hybrid approaches.</p>
    
    <p class="academic-text"><strong>Spectral Clustering</strong></p>
    <p class="academic-text">Spectral clustering uses eigenvalues and eigenvectors of the graph Laplacian matrix to find clusters.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Build adjacency matrix:</strong> Represent graph connections</li>
        <li class="academic-text"><strong>Compute Laplacian:</strong> L = D - A</li>
        <li class="academic-text"><strong>Find eigenvectors:</strong> Use k smallest eigenvalues</li>
        <li class="academic-text"><strong>Cluster in eigenspace:</strong> Apply k-means</li>
    </ul>

    <h2 class="section-title" id="ch14-4">14.4 Applications in Social Network Analysis</h2>

    <p class="academic-text">Pattern recognition in graphs powers modern social network analysis, from finding influencers to detecting fake news spread.</p>
    
    <p class="academic-text"><strong>Key Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Influencer detection:</strong> Find users with high centrality</li>
        <li class="academic-text"><strong>Community discovery:</strong> Identify interest groups</li>
        <li class="academic-text"><strong>Echo chamber detection:</strong> Find isolated communities</li>
        <li class="academic-text"><strong>Viral content tracking:</strong> Analyze spread patterns</li>
        <li class="academic-text"><strong>Bot detection:</strong> Identify suspicious cliques</li>
    </ul>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 14 Complete!</h3>
        <p class="academic-text">You now understand pattern recognition in graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Cliques</strong> - finding complete subgraphs</li>
            <li class="academic-text">✅ <strong>Community detection</strong> - discovering modular structure</li>
            <li class="academic-text">✅ <strong>Graph clustering</strong> - grouping similar nodes</li>
            <li class="academic-text">✅ <strong>Social network analysis</strong> - real-world applications</li>
        </ul>
        
        <p class="academic-text">These pattern recognition techniques unlock insights hidden in complex networks!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch15">
        
    <div class="chapter-number">Chapter 15</div>
    <h1 class="chapter-title">Graphs in Real Life & Human Decisions</h1>
    
    <div class="definition-box">
        "The algorithms you've learned aren't just for computers - they're mental models for navigating life's complex decisions and relationships."
    </div>

    <p class="academic-text">Graph theory transcends the boundaries of computer science to become a powerful framework for understanding and optimizing human life itself. The same mathematical principles that enable computers to find optimal paths, manage resources, and solve complex problems can be applied to navigate career decisions, build meaningful relationships, manage time effectively, and make strategic life choices. This isn't just metaphorical thinking - it's a practical methodology for bringing algorithmic clarity to life's inherent complexity.</p>
    
    <p class="academic-text">The power of graph thinking lies in its ability to transform overwhelming, interconnected problems into structured, analyzable systems. When you view your career as a graph of skills and opportunities, your social network as a web of relationships with different strengths and values, or your goals as a dependency graph requiring careful ordering, you gain the tools to make decisions with mathematical precision rather than pure intuition.</p>

    <p class="academic-text">This approach doesn't eliminate the human elements of decision-making - emotions, values, and personal preferences remain crucial. Instead, graph thinking provides a structured framework for organizing complex information, identifying optimal strategies, and understanding the long-term consequences of your choices. It's about bringing the clarity and systematic thinking of computer science to the art of living well.</p>
    
    <p class="academic-text"><strong>Graph algorithms provide practical frameworks for life's complex decisions:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Strategic career development:</strong> Model your career as a graph where skills are nodes and learning paths are edges, then use shortest path algorithms to find the most efficient route to your dream job</li>
        <li class="academic-text"><strong>Relationship optimization:</strong> Apply network analysis to understand your social connections, identify key relationships that bridge different communities, and invest time in connections that provide the most mutual value</li>
        <li class="academic-text"><strong>Goal achievement systems:</strong> Use topological sorting to order your objectives based on dependencies, ensuring you build foundational skills before attempting advanced goals</li>
        <li class="academic-text"><strong>Time and resource management:</strong> Apply graph coloring principles to schedule activities without conflicts, and use flow algorithms to optimize how you allocate limited time and energy</li>
        <li class="academic-text"><strong>Decision tree analysis:</strong> Map out complex decisions as trees, analyzing different paths and their potential outcomes to make choices with greater confidence and foresight</li>
        <li class="academic-text"><strong>Life optimization:</strong> Use minimum spanning tree concepts to identify the essential connections and activities that provide maximum life satisfaction with minimum complexity</li>
    </ul>
    
    <p class="academic-text">This chapter demonstrates how to apply the algorithmic thinking you've learned to create a more intentional, optimized, and fulfilling approach to life's challenges and opportunities.</p>

    <h2 class="section-title" id="ch15-1">15.1 Case Study: Career Pathfinding as Dijkstra's Algorithm</h2>
    
    <p class="academic-text">Your career is a graph! Skills are nodes, learning paths are edges, and time/effort are weights. Finding your optimal career path is literally Dijkstra's algorithm.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🎯 Career Graph Model</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Skills, positions, certifications</li>
            <li class="academic-text"><strong>Edges:</strong> Learning paths, job transitions</li>
            <li class="academic-text"><strong>Weights:</strong> Time, effort, cost to acquire</li>
            <li class="academic-text"><strong>Goal:</strong> Find shortest path from current state to dream job</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Career Path Example (Software Engineer to ML Engineer):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Junior Dev] -->|6 months| B[Mid-level Dev]
            A -->|1 year| C[Data Analyst]
            B -->|1 year| D[Senior Dev]
            C -->|8 months| E[Data Scientist]
            D -->|6 months| F[ML Engineer]
            E -->|4 months| F
            B -->|1.5 years| F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style F fill:#ffebee,stroke:#f44336,stroke-width:3px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Shortest path: Junior → Mid-level → Senior → ML Engineer (2.5 years)</p>
    </div>

    <p class="academic-text"><strong>Applying Dijkstra's to Your Career:</strong></p>
    <ol style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Map your current skills:</strong> What's your starting node?</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Define your goal:</strong> What's your destination node?</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Identify possible transitions:</strong> What edges exist? (courses, jobs, projects)</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Estimate costs:</strong> Time, money, effort for each edge</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Run Dijkstra's:</strong> Find the optimal path</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Execute:</strong> Follow the path, one edge at a time</li>
    </ol>

    <pre class="code-block">// Career Path Planner using Dijkstra's Algorithm
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;limits&gt;
using namespace std;

class CareerPathPlanner {
private:
    struct Edge {
        string to;
        int months;  // Time cost in months
        string action;  // What to do (course, job, etc.)
    };
    
    unordered_map&lt;string, vector&lt;Edge&gt;&gt; graph;
    
public:
    void addPath(string from, string to, int months, string action) {
        graph[from].push_back({to, months, action});
    }
    
    vector&lt;string&gt; findOptimalPath(string start, string goal) {
        unordered_map&lt;string, int&gt; distance;
        unordered_map&lt;string, string&gt; parent;
        unordered_map&lt;string, string&gt; action;
        
        for (auto&amp; [node, _] : graph) {
            distance[node] = numeric_limits&lt;int&gt;::max();
        }
        distance[start] = 0;
        
        priority_queue&lt;pair&lt;int, string&gt;, 
                       vector&lt;pair&lt;int, string&gt;&gt;,
                       greater&lt;pair&lt;int, string&gt;&gt;&gt; pq;
        pq.push({0, start});
        
        while (!pq.empty()) {
            auto [dist, current] = pq.top();
            pq.pop();
            
            if (dist &gt; distance[current]) continue;
            if (current == goal) break;
            
            for (auto&amp; edge : graph[current]) {
                int newDist = distance[current] + edge.months;
                if (newDist &lt; distance[edge.to]) {
                    distance[edge.to] = newDist;
                    parent[edge.to] = current;
                    action[edge.to] = edge.action;
                    pq.push({newDist, edge.to});
                }
            }
        }
        
        // Reconstruct path
        vector&lt;string&gt; path;
        string current = goal;
        while (current != start) {
            path.push_back(current);
            current = parent[current];
        }
        path.push_back(start);
        reverse(path.begin(), path.end());
        
        // Print plan
        cout &lt;&lt; "Optimal Career Path (" &lt;&lt; distance[goal] 
             &lt;&lt; " months):" &lt;&lt; endl;
        for (int i = 0; i &lt; path.size() - 1; i++) {
            cout &lt;&lt; path[i] &lt;&lt; " → " &lt;&lt; path[i+1] 
                 &lt;&lt; " (" &lt;&lt; action[path[i+1]] &lt;&lt; ")" &lt;&lt; endl;
        }
        
        return path;
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Multiple paths exist:</strong> There's rarely one "right" career path</li>
        <li class="academic-text"><strong>Weights matter:</strong> Consider time, money, and opportunity cost</li>
        <li class="academic-text"><strong>Graph changes:</strong> New opportunities appear, old paths close</li>
        <li class="academic-text"><strong>Local optima:</strong> Sometimes a longer path leads to better outcomes</li>
    </ul>

    <h2 class="section-title" id="ch15-2">15.2 Case Study: Social Network Pruning as MST</h2>

    <p class="academic-text">You can't maintain deep relationships with everyone. Minimum Spanning Tree algorithms help you identify which relationships to prioritize - keeping your network connected while minimizing emotional overhead.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">👥 Relationship Graph Model</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> People in your network</li>
            <li class="academic-text"><strong>Edges:</strong> Relationships</li>
            <li class="academic-text"><strong>Weights:</strong> Maintenance cost (time, energy, emotional labor)</li>
            <li class="academic-text"><strong>Goal:</strong> Stay connected to everyone while minimizing total effort</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Social Network MST:</strong><br><br>
        <div class="mermaid">
        graph LR
            You[You] ---|2| A[Close Friend A]
            You ---|3| B[Friend B]
            You ---|5| C[Acquaintance C]
            A ---|1| B
            B ---|2| C
            A ---|4| C
            
            style You fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">MST: Maintain You-A (2), A-B (1), B-C (2). Total effort: 5 units</p>
    </div>

    <p class="academic-text"><strong>Relationship Pruning Strategy:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Core relationships:</strong> Low-weight edges you maintain directly</li>
        <li class="academic-text"><strong>Transitive connections:</strong> Stay connected through mutual friends</li>
        <li class="academic-text"><strong>Prune high-cost edges:</strong> Let go of draining relationships</li>
        <li class="academic-text"><strong>Dunbar's number:</strong> ~150 meaningful relationships is the limit</li>
    </ul>

    <h2 class="section-title" id="ch15-3">15.3 Case Study: Goal Dependencies as Topological Sorting</h2>

    <p class="academic-text">Your goals have dependencies! You can't run a marathon before learning to jog. Topological sorting reveals the correct order to tackle your goals.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Goal Dependency Graph:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Learn basics] --> B[Build project]
            A --> C[Read documentation]
            B --> D[Get job]
            C --> B
            C --> E[Contribute to open source]
            E --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#ffebee,stroke:#f44336,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Valid order: Learn basics → Read docs → Build project/Contribute → Get job</p>
    </div>

    <p class="academic-text"><strong>Applying Topological Sort to Goals:</strong></p>
    <ol style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text" style="margin-bottom: 12px;"><strong>List all goals:</strong> What do you want to achieve?</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Identify dependencies:</strong> What must come before what?</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Build DAG:</strong> Goals as nodes, dependencies as edges</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Detect cycles:</strong> Circular dependencies = impossible goals</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Topological sort:</strong> Get valid execution order</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Execute in order:</strong> Work through goals sequentially</li>
    </ol>

    <h2 class="section-title" id="ch15-4">15.4 Case Study: Time Management as Graph Coloring</h2>

    <p class="academic-text">Scheduling your day is graph coloring! Activities are nodes, conflicts are edges, time slots are colors. Minimize colors (time slots) while avoiding conflicts.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Daily Schedule as Graph Coloring:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Work] --- B[Gym]
            A --- C[Cooking]
            B --- C
            D[Reading] --- E[Family time]
            C --- E
            
            style A fill:#ff6b6b,stroke:#333,stroke-width:2px
            style B fill:#4ecdc4,stroke:#333,stroke-width:2px
            style C fill:#ffe66d,stroke:#333,stroke-width:2px
            style D fill:#ff6b6b,stroke:#333,stroke-width:2px
            style E fill:#4ecdc4,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">3 time slots needed: Red (Work, Reading), Blue (Gym, Family), Yellow (Cooking)</p>
    </div>

    <p class="academic-text"><strong>Time Management Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Conflicts create edges:</strong> Can't do two things simultaneously</li>
        <li class="academic-text"><strong>Minimize colors:</strong> Fewer time slots = more efficient schedule</li>
        <li class="academic-text"><strong>Greedy works:</strong> Schedule high-priority tasks first</li>
        <li class="academic-text"><strong>Context switching:</strong> Too many colors = too much switching overhead</li>
    </ul>

    <h2 class="section-title" id="ch15-5">15.5 Mind Mapping and Decision Making</h2>

    <p class="academic-text">Mind maps are graphs! Use graph thinking to structure your thoughts, explore decisions, and find insights.</p>
    
    <p class="academic-text"><strong>Decision Trees as Graphs:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Nodes:</strong> Decisions or outcomes</li>
        <li class="academic-text"><strong>Edges:</strong> Choices or consequences</li>
        <li class="academic-text"><strong>Paths:</strong> Possible futures</li>
        <li class="academic-text"><strong>Weights:</strong> Probabilities or values</li>
    </ul>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 15 Complete!</h3>
        <p class="academic-text">You now see graphs everywhere in life:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Career planning</strong> - Dijkstra's for optimal paths</li>
            <li class="academic-text">✅ <strong>Relationships</strong> - MST for network pruning</li>
            <li class="academic-text">✅ <strong>Goal setting</strong> - Topological sort for dependencies</li>
            <li class="academic-text">✅ <strong>Time management</strong> - Graph coloring for scheduling</li>
            <li class="academic-text">✅ <strong>Decision making</strong> - Graph thinking for clarity</li>
        </ul>
        
        <p class="academic-text">Graph algorithms aren't just for computers - they're mental models for navigating life's complexity!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch16">
        
    <div class="chapter-number">Chapter 16</div>
    <h1 class="chapter-title">Building the Graph Mindset</h1>
    
    <div class="definition-box">
        "Once you see the world as graphs, you can't unsee it. Every system, every relationship, every problem becomes a network waiting to be understood and optimized."
    </div>

    <p class="academic-text">This final chapter represents the culmination of your journey through graph theory - not just as a collection of algorithms and data structures, but as a fundamental way of understanding and interacting with the world. The graph mindset is a meta-cognitive skill that transforms how you perceive complexity, analyze systems, and solve problems across every domain of life. Once you develop this mindset, you'll see graphs everywhere: in organizations, relationships, ideas, and challenges that others view as chaotic or incomprehensible.</p>
    
    <p class="academic-text">The graph mindset represents a paradigm shift from linear, reductionist thinking to network-based, systems thinking. Instead of breaking problems down into isolated components, you'll see the relationships, dependencies, and emergent properties that arise from interconnection. This perspective enables you to identify leverage points, predict system behavior, and design interventions that create positive change throughout entire networks.</p>

    <p class="academic-text">Developing the graph mindset isn't just about applying specific algorithms - it's about cultivating a new form of intelligence that sees patterns in complexity, understands the architecture of systems, and recognizes the universal principles that govern everything from social networks to biological systems to technological infrastructure. This mindset becomes a superpower for navigating an increasingly interconnected world.</p>
    
    <p class="academic-text"><strong>The graph mindset encompasses multiple interconnected cognitive abilities:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Systems perception:</strong> Automatically see any situation as a network of interconnected nodes and relationships, revealing hidden connections and dependencies that others miss</li>
        <li class="academic-text"><strong>Pattern recognition mastery:</strong> Instantly identify cycles, bottlenecks, critical paths, and structural vulnerabilities in any system, from organizations to personal relationships</li>
        <li class="academic-text"><strong>Structural analysis:</strong> Understand problems by their underlying architecture rather than surface content, enabling solutions that address root causes rather than symptoms</li>
        <li class="academic-text"><strong>Algorithmic intuition:</strong> Instinctively know which graph algorithms and principles apply to real-world situations, from career planning to conflict resolution</li>
        <li class="academic-text"><strong>Optimization orientation:</strong> Constantly ask "Is there a better path?" and systematically search for more efficient, effective, or elegant solutions</li>
        <li class="academic-text"><strong>Emergence awareness:</strong> Recognize how simple local interactions create complex global behaviors, enabling prediction and influence of system-wide outcomes</li>
    </ul>
    
    <p class="academic-text">This chapter provides a framework for cultivating this transformative mindset, giving you the tools to analyze any system as a graph and navigate complexity with mathematical precision and intuitive understanding.</p>

    <h2 class="section-title" id="ch16-1">16.1 Systems Thinking: Seeing Interconnected Graphs</h2>
    
    <p class="academic-text">Systems thinking is the art of seeing wholes instead of parts. Every complex system - organizations, ecosystems, economies, your own life - is a graph. Once you see the graph, you understand the system.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🌐 The Graph Lens</h3>
        <p class="academic-text"><strong>Traditional thinking:</strong> Linear cause and effect (A causes B)</p>
        <p class="academic-text"><strong>Graph thinking:</strong> Networks of influence (A affects B, C, and D, which loop back to A)</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Nodes:</strong> Components, entities, concepts</li>
            <li class="academic-text"><strong>Edges:</strong> Relationships, dependencies, influences</li>
            <li class="academic-text"><strong>Structure:</strong> The pattern reveals behavior</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Example: Company as a Graph</strong><br><br>
        <div class="mermaid">
        graph TD
            CEO[CEO] --> Eng[Engineering]
            CEO --> Sales[Sales]
            CEO --> Ops[Operations]
            Eng --> Product[Product]
            Sales --> Product
            Product --> Customers[Customers]
            Customers --> Revenue[Revenue]
            Revenue --> CEO
            Ops --> Eng
            Ops --> Sales
            
            style CEO fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style Customers fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Revenue fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Notice the feedback loop: Customers → Revenue → CEO → Teams → Product → Customers</p>
    </div>

    <p class="academic-text"><strong>Key Systems Thinking Principles:</strong></p>
    <ol style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Everything is connected:</strong> No node exists in isolation</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Feedback loops matter:</strong> Cycles create dynamics (growth or collapse)</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Structure drives behavior:</strong> Change the graph, change the outcomes</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Leverage points exist:</strong> Small changes to key nodes have huge impacts</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Emergence happens:</strong> Graph properties aren't visible in individual nodes</li>
    </ol>

    <div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 20px 0;">
        <p style="margin: 0; font-family: sans-serif; font-size: 12pt;"><strong>💡 Practice Exercise:</strong> Pick any system (your workplace, your city, the internet). Draw it as a graph. What patterns emerge? Where are the bottlenecks? What happens if you remove a key node?</p>
    </div>

    <h2 class="section-title" id="ch16-2">16.2 Recognizing Patterns: Cycles, Dependencies, Bottlenecks</h2>

    <p class="academic-text">Once you see the graph, you need to recognize patterns. Certain graph structures appear everywhere and have predictable behaviors. Master these patterns and you'll diagnose problems instantly.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔍 Universal Graph Patterns</h3>
    </div>

    <p class="academic-text"><strong>1. Cycles (Feedback Loops)</strong></p>
    <p class="academic-text">Cycles create dynamics - either virtuous (growth) or vicious (collapse).</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Virtuous Cycle (Positive Feedback):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Good Product] --> B[Happy Customers]
            B --> C[More Revenue]
            C --> D[Better Product]
            D --> A
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Positive cycle: Each iteration amplifies success</p>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Vicious Cycle (Negative Feedback):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Poor Sleep] --> B[Low Energy]
            B --> C[Poor Performance]
            C --> D[High Stress]
            D --> A
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#ffebee,stroke:#f44336,stroke-width:2px
            style D fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Negative cycle: Each iteration makes things worse</p>
    </div>

    <p class="academic-text"><strong>How to break bad cycles:</strong> Identify the weakest edge and cut it. Add a new edge that reverses the flow.</p>

    <p class="academic-text"><strong>2. Dependencies (DAG Structure)</strong></p>
    <p class="academic-text">When nodes depend on each other, order matters. Recognize DAGs to sequence actions correctly.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Critical path:</strong> Longest path determines minimum time</li>
        <li class="academic-text"><strong>Parallelization:</strong> Independent nodes can execute simultaneously</li>
        <li class="academic-text"><strong>Blockers:</strong> Nodes with high in-degree block progress</li>
    </ul>

    <p class="academic-text"><strong>3. Bottlenecks (High-Degree Nodes)</strong></p>
    <p class="academic-text">Nodes with many connections are bottlenecks. They're powerful but fragile.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bottleneck Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Team A] --> Manager[Manager]
            B[Team B] --> Manager
            C[Team C] --> Manager
            D[Team D] --> Manager
            Manager --> Decision[Decision]
            
            style Manager fill:#ff6b6b,stroke:#333,stroke-width:3px
            style Decision fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Manager is a bottleneck - all decisions flow through one node</p>
    </div>

    <p class="academic-text"><strong>Solutions:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Distribute load:</strong> Add parallel paths</li>
        <li class="academic-text"><strong>Delegate:</strong> Push decisions to edges</li>
        <li class="academic-text"><strong>Automate:</strong> Remove the node entirely</li>
    </ul>

    <p class="academic-text"><strong>4. Disconnected Components (Silos)</strong></p>
    <p class="academic-text">When subgraphs don't connect, information can't flow. Silos are efficiency killers.</p>
    
    <p class="academic-text"><strong>5. Hub-and-Spoke (Star Graph)</strong></p>
    <p class="academic-text">Central node connects everything. Efficient but creates single point of failure.</p>

    <h2 class="section-title" id="ch16-3">16.3 Framework for Analyzing Any System as a Graph</h2>

    <p class="academic-text">Here's your systematic framework for graph thinking. Use this to analyze any system, problem, or decision.</p>
    
    <div style="background-color: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #2e7d32;">📋 The Graph Analysis Framework</h3>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Step 1: Define the Graph</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>What are the nodes?</strong> (entities, components, people, concepts)</li>
            <li class="academic-text"><strong>What are the edges?</strong> (relationships, dependencies, flows)</li>
            <li class="academic-text"><strong>Are edges directed?</strong> (one-way or bidirectional?)</li>
            <li class="academic-text"><strong>Are edges weighted?</strong> (do relationships have costs/strengths?)</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Step 2: Map the Structure</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">Draw it out (literally or mentally)</li>
            <li class="academic-text">Identify key nodes (high degree, critical path)</li>
            <li class="academic-text">Find patterns (cycles, bottlenecks, silos)</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Step 3: Analyze Properties</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Connectivity:</strong> Is it connected? Any isolated components?</li>
            <li class="academic-text"><strong>Cycles:</strong> Any feedback loops? Virtuous or vicious?</li>
            <li class="academic-text"><strong>Paths:</strong> What's the critical path? Shortest path?</li>
            <li class="academic-text"><strong>Centrality:</strong> Which nodes are most important?</li>
            <li class="academic-text"><strong>Density:</strong> Sparse or densely connected?</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Step 4: Apply Algorithms</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Need optimal path?</strong> → Dijkstra's, A*</li>
            <li class="academic-text"><strong>Need to order tasks?</strong> → Topological sort</li>
            <li class="academic-text"><strong>Need to minimize connections?</strong> → MST</li>
            <li class="academic-text"><strong>Need to detect communities?</strong> → Community detection</li>
            <li class="academic-text"><strong>Need to schedule?</strong> → Graph coloring</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Step 5: Optimize</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">Add edges (create new connections)</li>
            <li class="academic-text">Remove edges (cut toxic relationships)</li>
            <li class="academic-text">Reweight edges (change priorities)</li>
            <li class="academic-text">Add/remove nodes (change components)</li>
            <li class="academic-text">Restructure (change the graph topology)</li>
        </ul>
    </div>

    <div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 20px 0;">
        <p style="margin: 0; font-family: sans-serif; font-size: 12pt;"><strong>💡 Real Example:</strong> Analyzing your learning path</p>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 8px;"><strong>Nodes:</strong> Skills you want to learn</li>
            <li style="margin-bottom: 8px;"><strong>Edges:</strong> Prerequisites (must learn X before Y)</li>
            <li style="margin-bottom: 8px;"><strong>Weights:</strong> Time to learn each skill</li>
            <li style="margin-bottom: 8px;"><strong>Algorithm:</strong> Topological sort + critical path</li>
            <li style="margin-bottom: 8px;"><strong>Result:</strong> Optimal learning sequence and timeline</li>
        </ul>
    </div>

    <h2 class="section-title" id="ch16-4">16.4 Final Takeaway: "Life is a Graph. Learn to Navigate It."</h2>

    <p class="academic-text">You've reached the end of this handbook, but this is just the beginning of your graph thinking journey. Let's bring it all together.</p>
    
    <div style="background-color: #e3f2fd; border: 3px solid #2196f3; border-radius: 12px; padding: 25px; margin: 30px 0;">
        <h3 style="margin-top: 0; color: #1976d2; text-align: center; font-size: 18pt;">🌟 The Graph Mindset Manifesto</h3>
        
        <ol style="margin: 20px 0; padding-left: 24px; font-family: sans-serif; font-size: 13pt; line-height: 1.8;">
            <li style="margin-bottom: 15px;"><strong>Everything is a graph.</strong> Your career, relationships, knowledge, time, decisions - all graphs waiting to be understood.</li>
            
            <li style="margin-bottom: 15px;"><strong>Structure reveals truth.</strong> Don't just look at nodes - look at how they connect. The pattern tells the story.</li>
            
            <li style="margin-bottom: 15px;"><strong>Algorithms are mental models.</strong> Dijkstra's isn't just for computers - it's how you should think about any pathfinding problem.</li>
            
            <li style="margin-bottom: 15px;"><strong>Optimize relentlessly.</strong> There's always a better path, a more efficient structure, a smarter connection.</li>
            
            <li style="margin-bottom: 15px;"><strong>Cycles compound.</strong> Virtuous cycles make you unstoppable. Vicious cycles destroy you. Choose your cycles wisely.</li>
            
            <li style="margin-bottom: 15px;"><strong>Bottlenecks limit everything.</strong> Find them, fix them, or route around them.</li>
            
            <li style="margin-bottom: 15px;"><strong>Connections matter more than nodes.</strong> It's not what you know or who you know - it's how everything connects.</li>
            
            <li style="margin-bottom: 15px;"><strong>Think in systems, not silos.</strong> Linear thinking fails in a networked world.</li>
            
            <li style="margin-bottom: 15px;"><strong>Leverage exists.</strong> Small changes to key nodes create massive ripple effects.</li>
            
            <li style="margin-bottom: 15px;"><strong>Life is a graph. Learn to navigate it.</strong> With graph thinking, you see patterns others miss and solve problems others can't articulate.</li>
        </ol>
    </div>

    <p class="academic-text"><strong>What You've Learned:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">✅ <strong>Fundamentals:</strong> Graphs, trees, properties, representations</li>
        <li class="academic-text">✅ <strong>Algorithms:</strong> Traversal, shortest paths, MST, topological sort, flow, coloring</li>
        <li class="academic-text">✅ <strong>Advanced concepts:</strong> Strongly connected components, bridges, articulation points</li>
        <li class="academic-text">✅ <strong>Applications:</strong> Computer science, pattern recognition, real-life decisions</li>
        <li class="academic-text">✅ <strong>Mindset:</strong> Systems thinking, pattern recognition, optimization frameworks</li>
    </ul>

    <p class="academic-text"><strong>Where to Go From Here:</strong></p>
    <ol style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Practice daily:</strong> Look for graphs in everything you encounter</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Solve problems:</strong> LeetCode, competitive programming, real projects</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Build systems:</strong> Design software, organizations, processes as graphs</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Teach others:</strong> The best way to master graph thinking is to explain it</li>
        <li class="academic-text" style="margin-bottom: 12px;"><strong>Go deeper:</strong> Study network science, complexity theory, systems dynamics</li>
    </ol>

    <div style="background-color: #f8f9fa; border: 2px solid #333; border-radius: 8px; padding: 25px; margin: 30px 0; text-align: center;">
        <p style="font-family: 'Georgia', serif; font-size: 16pt; font-style: italic; margin: 0; color: #333;">
            "The world is not a collection of isolated objects.<br>
            It's a network of relationships.<br>
            Master graphs, and you master the art of seeing connections."
        </p>
        <p style="margin: 20px 0 0 0; font-size: 12pt; color: #666;">— The Graph Mindset</p>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Congratulations! You've Completed the Graph Handbook!</h3>
        <p class="academic-text">You now possess a superpower that most people don't have: <strong>the ability to see and understand complex systems as graphs.</strong></p>
        
        <p class="academic-text">This isn't just knowledge - it's a new way of thinking that will serve you for life. Whether you're:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">🎯 Planning your career path</li>
            <li class="academic-text">💻 Building software systems</li>
            <li class="academic-text">🤝 Managing relationships</li>
            <li class="academic-text">📊 Analyzing data</li>
            <li class="academic-text">🧠 Making complex decisions</li>
            <li class="academic-text">🏢 Designing organizations</li>
        </ul>
        
        <p class="academic-text">...you now have the graph mindset to see patterns, find optimal paths, and navigate complexity with confidence.</p>
        
        <p class="academic-text" style="font-size: 14pt; font-weight: bold; text-align: center; margin-top: 30px; color: #1976d2;">
            Life is a graph. You've learned to navigate it. Now go build something amazing! 🚀
        </p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="ch17">
        
    <div class="chapter-number">Chapter 17</div>
    <h1 class="chapter-title">Graph Problems in Coding Interviews</h1>
    
    <div class="definition-box">
        "Master these 5 essential graph problems and you'll be ready to tackle any graph challenge in coding interviews."
    </div>

    <p class="academic-text">Graph problems are among the most common and challenging questions in technical interviews at top tech companies. This chapter bridges the gap between theoretical graph knowledge and practical coding skills by walking through 5 essential LeetCode problems that demonstrate key graph algorithms and patterns you'll encounter in interviews.</p>
    
    <p class="academic-text">These problems aren't just academic exercises - they represent real algorithmic challenges that software engineers face when building systems that involve networks, dependencies, pathfinding, and optimization. Mastering these patterns will give you the confidence and skills to tackle any graph problem in interviews and in your professional work.</p>

    <p class="academic-text">Each problem demonstrates a fundamental graph algorithm or technique, building from basic traversal to advanced optimization. We'll explore the problem-solving approach, implement clean solutions, and discuss the underlying graph theory concepts that make each solution work.</p>
    
    <p class="academic-text"><strong>The 5 essential graph patterns every developer should master:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Graph Traversal:</strong> Number of Islands - BFS/DFS fundamentals</li>
        <li class="academic-text"><strong>Topological Sorting:</strong> Course Schedule - Dependency resolution</li>
        <li class="academic-text"><strong>Shortest Path:</strong> Word Ladder - BFS for unweighted paths</li>
        <li class="academic-text"><strong>Union-Find:</strong> Number of Connected Components - Efficient connectivity</li>
        <li class="academic-text"><strong>Advanced Traversal:</strong> Clone Graph - Deep copying with cycles</li>
    </ul>

    <h2 class="section-title" id="ch17-1">17.1 Problem 1: Number of Islands (Graph Traversal)</h2>
    
    <p class="academic-text"><strong>LeetCode 200 - Number of Islands</strong></p>
    <p class="academic-text">Given a 2D binary grid representing a map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and formed by connecting adjacent lands horizontally or vertically.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🏝️ Problem Analysis</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Graph representation:</strong> 2D grid where each cell is a node</li>
            <li class="academic-text"><strong>Connections:</strong> Adjacent cells (up, down, left, right)</li>
            <li class="academic-text"><strong>Goal:</strong> Count connected components of '1's</li>
            <li class="academic-text"><strong>Algorithm:</strong> DFS or BFS to explore each island</li>
        </ul>
    </div>

    <pre class="code-block">// Solution using DFS
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty() || grid[0].empty()) return 0;
        
        int rows = grid.size();
        int cols = grid[0].size();
        int islands = 0;
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == '1') {
                    islands++;
                    dfs(grid, i, j);
                }
            }
        }
        
        return islands;
    }
    
private:
    void dfs(vector<vector<char>>& grid, int row, int col) {
        // Boundary check and water check
        if (row < 0 || row >= grid.size() || 
            col < 0 || col >= grid[0].size() || 
            grid[row][col] == '0') {
            return;
        }
        
        // Mark as visited by changing to '0'
        grid[row][col] = '0';
        
        // Explore all 4 directions
        dfs(grid, row + 1, col);  // down
        dfs(grid, row - 1, col);  // up
        dfs(grid, row, col + 1);  // right
        dfs(grid, row, col - 1);  // left
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Connected components:</strong> Each island is a connected component</li>
        <li class="academic-text"><strong>Marking visited:</strong> Change '1' to '0' to avoid revisiting</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(m×n) - visit each cell once</li>
        <li class="academic-text"><strong>Space complexity:</strong> O(m×n) worst case for recursion stack</li>
    </ul>

    <h2 class="section-title" id="ch17-2">17.2 Problem 2: Course Schedule (Topological Sorting)</h2>
    
    <p class="academic-text"><strong>LeetCode 207 - Course Schedule</strong></p>
    <p class="academic-text">There are numCourses courses labeled from 0 to numCourses-1. Given prerequisites array where prerequisites[i] = [ai, bi] indicates you must take course bi before course ai. Return true if you can finish all courses.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">📚 Problem Analysis</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Graph representation:</strong> Directed graph of course dependencies</li>
            <li class="academic-text"><strong>Cycle detection:</strong> If there's a cycle, impossible to complete</li>
            <li class="academic-text"><strong>Algorithm:</strong> Topological sort using Kahn's algorithm</li>
            <li class="academic-text"><strong>Success condition:</strong> Can process all courses</li>
        </ul>
    </div>

    <pre class="code-block">// Solution using Kahn's Algorithm (BFS-based topological sort)
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // Build adjacency list and in-degree array
        vector<vector<int>> graph(numCourses);
        vector<int> inDegree(numCourses, 0);
        
        for (auto& prereq : prerequisites) {
            int course = prereq[0];
            int prerequisite = prereq[1];
            graph[prerequisite].push_back(course);
            inDegree[course]++;
        }
        
        // Find all courses with no prerequisites
        queue<int> q;
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                q.push(i);
            }
        }
        
        int processedCourses = 0;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            processedCourses++;
            
            // Process all courses that depend on current
            for (int dependent : graph[current]) {
                inDegree[dependent]--;
                if (inDegree[dependent] == 0) {
                    q.push(dependent);
                }
            }
        }
        
        return processedCourses == numCourses;
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Cycle detection:</strong> If we can't process all courses, there's a cycle</li>
        <li class="academic-text"><strong>In-degree tracking:</strong> Count prerequisites for each course</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(V + E) where V = courses, E = prerequisites</li>
        <li class="academic-text"><strong>Space complexity:</strong> O(V + E) for graph and queue</li>
    </ul>

    <h2 class="section-title" id="ch17-3">17.3 Problem 3: Word Ladder (Shortest Path)</h2>
    
    <p class="academic-text"><strong>LeetCode 127 - Word Ladder</strong></p>
    <p class="academic-text">Given two words beginWord and endWord, and a dictionary wordList, return the length of shortest transformation sequence from beginWord to endWord, where each transformation changes exactly one letter.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔤 Problem Analysis</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Graph representation:</strong> Words as nodes, single-letter changes as edges</li>
            <li class="academic-text"><strong>Shortest path:</strong> BFS finds minimum transformations</li>
            <li class="academic-text"><strong>Edge condition:</strong> Two words differ by exactly one character</li>
            <li class="academic-text"><strong>Optimization:</strong> Use set for O(1) word lookup</li>
        </ul>
    </div>

    <pre class="code-block">// Solution using BFS for shortest path
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> wordSet(wordList.begin(), wordList.end());
        
        if (wordSet.find(endWord) == wordSet.end()) {
            return 0; // endWord not in dictionary
        }
        
        queue<string> q;
        q.push(beginWord);
        
        int level = 1;
        
        while (!q.empty()) {
            int size = q.size();
            
            for (int i = 0; i < size; i++) {
                string current = q.front();
                q.pop();
                
                if (current == endWord) {
                    return level;
                }
                
                // Try changing each character
                for (int j = 0; j < current.length(); j++) {
                    char original = current[j];
                    
                    for (char c = 'a'; c <= 'z'; c++) {
                        if (c == original) continue;
                        
                        current[j] = c;
                        
                        if (wordSet.find(current) != wordSet.end()) {
                            q.push(current);
                            wordSet.erase(current); // Mark as visited
                        }
                    }
                    
                    current[j] = original; // Restore
                }
            }
            
            level++;
        }
        
        return 0; // No path found
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>BFS for shortest path:</strong> Guarantees minimum transformations</li>
        <li class="academic-text"><strong>Level-order processing:</strong> Track transformation count</li>
        <li class="academic-text"><strong>Visited marking:</strong> Remove from set to avoid cycles</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(M²×N) where M = word length, N = word count</li>
    </ul>

    <h2 class="section-title" id="ch17-4">17.4 Problem 4: Number of Connected Components (Union-Find)</h2>
    
    <p class="academic-text"><strong>LeetCode 323 - Number of Connected Components in Undirected Graph</strong></p>
    <p class="academic-text">Given n nodes labeled from 0 to n-1 and a list of undirected edges, write a function to find the number of connected components in the undirected graph.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Problem Analysis</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Union-Find structure:</strong> Efficient connectivity queries</li>
            <li class="academic-text"><strong>Path compression:</strong> Optimize find operations</li>
            <li class="academic-text"><strong>Union by rank:</strong> Keep trees balanced</li>
            <li class="academic-text"><strong>Component counting:</strong> Track number of distinct roots</li>
        </ul>
    </div>

    <pre class="code-block">// Solution using Union-Find with path compression
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    int components;
    
public:
    UnionFind(int n) : parent(n), rank(n, 0), components(n) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    void unionSets(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            // Union by rank
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            components--;
        }
    }
    
    int getComponents() {
        return components;
    }
};

class Solution {
public:
    int countComponents(int n, vector<vector<int>>& edges) {
        UnionFind uf(n);
        
        for (auto& edge : edges) {
            uf.unionSets(edge[0], edge[1]);
        }
        
        return uf.getComponents();
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Union-Find efficiency:</strong> Nearly O(1) operations with optimizations</li>
        <li class="academic-text"><strong>Path compression:</strong> Flattens tree structure during find</li>
        <li class="academic-text"><strong>Union by rank:</strong> Keeps trees balanced for better performance</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(E×α(n)) where α is inverse Ackermann</li>
    </ul>

    <h2 class="section-title" id="ch17-5">17.5 Problem 5: Clone Graph (Advanced Traversal)</h2>
    
    <p class="academic-text"><strong>LeetCode 133 - Clone Graph</strong></p>
    <p class="academic-text">Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node contains a value and a list of its neighbors.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔄 Problem Analysis</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Deep copy challenge:</strong> Create new nodes while preserving structure</li>
            <li class="academic-text"><strong>Cycle handling:</strong> Avoid infinite loops in cyclic graphs</li>
            <li class="academic-text"><strong>Mapping strategy:</strong> Track original → clone relationships</li>
            <li class="academic-text"><strong>Two approaches:</strong> DFS or BFS traversal</li>
        </ul>
    </div>

    <pre class="code-block">// Node definition
class Node {
public:
    int val;
    vector<Node*> neighbors;
    Node() {
        val = 0;
        neighbors = vector<Node*>();
    }
    Node(int _val) {
        val = _val;
        neighbors = vector<Node*>();
    }
    Node(int _val, vector<Node*> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
};

// Solution using DFS
class Solution {
private:
    unordered_map<Node*, Node*> cloneMap;
    
public:
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;
        
        // If already cloned, return the clone
        if (cloneMap.find(node) != cloneMap.end()) {
            return cloneMap[node];
        }
        
        // Create clone of current node
        Node* clone = new Node(node->val);
        cloneMap[node] = clone;
        
        // Clone all neighbors
        for (Node* neighbor : node->neighbors) {
            clone->neighbors.push_back(cloneGraph(neighbor));
        }
        
        return clone;
    }
};</pre>

    <p class="academic-text"><strong>Key Insights:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Cycle prevention:</strong> Use map to track cloned nodes</li>
        <li class="academic-text"><strong>Recursive structure:</strong> Clone neighbors recursively</li>
        <li class="academic-text"><strong>Memory management:</strong> Create new nodes for deep copy</li>
        <li class="academic-text"><strong>Time complexity:</strong> O(V + E) - visit each node and edge once</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">🎯 Interview Success Patterns</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Problem-Solving Approach</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Identify pattern:</strong> Recognize the graph algorithm needed</li>
                    <li class="academic-text"><strong>Choose representation:</strong> Adjacency list vs matrix vs implicit</li>
                    <li class="academic-text"><strong>Handle edge cases:</strong> Empty graphs, cycles, disconnected components</li>
                    <li class="academic-text"><strong>Optimize:</strong> Consider time/space trade-offs</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Common Patterns</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Traversal:</strong> DFS/BFS for connectivity</li>
                    <li class="academic-text"><strong>Shortest path:</strong> BFS for unweighted, Dijkstra for weighted</li>
                    <li class="academic-text"><strong>Cycle detection:</strong> DFS with colors or topological sort</li>
                    <li class="academic-text"><strong>Connectivity:</strong> Union-Find for dynamic queries</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">🎉 Chapter 17 Complete!</h3>
        <p class="academic-text">You now have the essential graph problem-solving toolkit for coding interviews:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">✅ <strong>Graph traversal mastery</strong> - BFS/DFS for connectivity problems</li>
            <li class="academic-text">✅ <strong>Topological sorting</strong> - Dependency resolution and cycle detection</li>
            <li class="academic-text">✅ <strong>Shortest path algorithms</strong> - BFS for unweighted graphs</li>
            <li class="academic-text">✅ <strong>Union-Find techniques</strong> - Efficient connectivity queries</li>
            <li class="academic-text">✅ <strong>Advanced patterns</strong> - Deep copying and cycle handling</li>
        </ul>
        
        <p class="academic-text">These 5 problems represent the core patterns you'll encounter in graph interviews. Practice variations of these problems to build confidence and speed. Remember: graph problems often have multiple valid approaches - choose the one that best fits the constraints and your comfort level!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="appa">
        
    <div class="chapter-number">Appendix A</div>
    <h1 class="chapter-title">Graph Terminology Reference</h1>
    
    <div class="definition-box">
        "A comprehensive glossary of graph theory terms - your quick reference for all things graphs."
    </div>

    <h2 class="section-title" id="appa-1">A.1 Complete Glossary of Graph Theory Terms</h2>
    
    <p class="academic-text">This glossary provides definitions for all graph theory terms used throughout this handbook, organized alphabetically for quick reference.</p>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">A</h3>
        
        <p style="margin: 10px 0;"><strong>Acyclic Graph:</strong> A graph with no cycles. Trees are acyclic.</p>
        
        <p style="margin: 10px 0;"><strong>Adjacent Vertices:</strong> Two vertices connected by an edge. Also called neighbors.</p>
        
        <p style="margin: 10px 0;"><strong>Adjacency List:</strong> Graph representation using lists of neighbors for each vertex. Space: O(V + E).</p>
        
        <p style="margin: 10px 0;"><strong>Adjacency Matrix:</strong> Graph representation using a 2D matrix. Space: O(V²).</p>
        
        <p style="margin: 10px 0;"><strong>Articulation Point:</strong> A vertex whose removal increases the number of connected components. Also called cut vertex.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">B</h3>
        
        <p style="margin: 10px 0;"><strong>Bipartite Graph:</strong> A graph whose vertices can be divided into two disjoint sets where edges only connect vertices from different sets.</p>
        
        <p style="margin: 10px 0;"><strong>Bridge:</strong> An edge whose removal increases the number of connected components. Also called cut edge.</p>
        
        <p style="margin: 10px 0;"><strong>BFS (Breadth-First Search):</strong> Graph traversal algorithm that explores level by level. Time: O(V + E).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">C</h3>
        
        <p style="margin: 10px 0;"><strong>Chromatic Number χ(G):</strong> Minimum number of colors needed to color a graph.</p>
        
        <p style="margin: 10px 0;"><strong>Clique:</strong> A complete subgraph where every pair of vertices is connected.</p>
        
        <p style="margin: 10px 0;"><strong>Complete Graph K<sub>n</sub>:</strong> A graph where every pair of vertices is connected. Has n(n-1)/2 edges.</p>
        
        <p style="margin: 10px 0;"><strong>Connected Component:</strong> A maximal connected subgraph.</p>
        
        <p style="margin: 10px 0;"><strong>Connected Graph:</strong> A graph where there exists a path between every pair of vertices.</p>
        
        <p style="margin: 10px 0;"><strong>Cycle:</strong> A path that starts and ends at the same vertex with no repeated edges.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">D</h3>
        
        <p style="margin: 10px 0;"><strong>DAG (Directed Acyclic Graph):</strong> A directed graph with no cycles. Used for dependency ordering.</p>
        
        <p style="margin: 10px 0;"><strong>Degree:</strong> Number of edges incident to a vertex. In directed graphs: in-degree + out-degree.</p>
        
        <p style="margin: 10px 0;"><strong>DFS (Depth-First Search):</strong> Graph traversal algorithm that explores as deep as possible. Time: O(V + E).</p>
        
        <p style="margin: 10px 0;"><strong>Dijkstra's Algorithm:</strong> Finds shortest paths from a source to all vertices in weighted graphs with non-negative weights. Time: O((V + E) log V) with priority queue.</p>
        
        <p style="margin: 10px 0;"><strong>Directed Graph (Digraph):</strong> A graph where edges have direction (arrows).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">E</h3>
        
        <p style="margin: 10px 0;"><strong>Edge:</strong> A connection between two vertices. Can be directed or undirected, weighted or unweighted.</p>
        
        <p style="margin: 10px 0;"><strong>Eulerian Path:</strong> A path that visits every edge exactly once.</p>
        
        <p style="margin: 10px 0;"><strong>Eulerian Circuit:</strong> An Eulerian path that starts and ends at the same vertex.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">F</h3>
        
        <p style="margin: 10px 0;"><strong>Flow Network:</strong> A directed graph where each edge has a capacity. Used for max flow problems.</p>
        
        <p style="margin: 10px 0;"><strong>Forest:</strong> A disjoint union of trees (acyclic graph with multiple components).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">G</h3>
        
        <p style="margin: 10px 0;"><strong>Graph:</strong> A mathematical structure G = (V, E) consisting of vertices V and edges E.</p>
        
        <p style="margin: 10px 0;"><strong>Graph Coloring:</strong> Assigning colors to vertices such that no adjacent vertices share the same color.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">H</h3>
        
        <p style="margin: 10px 0;"><strong>Hamiltonian Path:</strong> A path that visits every vertex exactly once.</p>
        
        <p style="margin: 10px 0;"><strong>Hamiltonian Cycle:</strong> A Hamiltonian path that starts and ends at the same vertex.</p>
        
        <p style="margin: 10px 0;"><strong>Heap:</strong> A complete binary tree with heap property. Used in priority queues for graph algorithms.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">I</h3>
        
        <p style="margin: 10px 0;"><strong>In-degree:</strong> Number of edges coming into a vertex in a directed graph.</p>
        
        <p style="margin: 10px 0;"><strong>Independent Set:</strong> A set of vertices with no edges between them.</p>
        
        <p style="margin: 10px 0;"><strong>Isomorphic Graphs:</strong> Two graphs with the same structure (can be relabeled to be identical).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">K</h3>
        
        <p style="margin: 10px 0;"><strong>Kruskal's Algorithm:</strong> Finds MST by sorting edges and adding them greedily. Time: O(E log E).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">L</h3>
        
        <p style="margin: 10px 0;"><strong>Leaf Node:</strong> A vertex with degree 1 in a tree.</p>
        
        <p style="margin: 10px 0;"><strong>Loop:</strong> An edge that connects a vertex to itself.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">M</h3>
        
        <p style="margin: 10px 0;"><strong>Matching:</strong> A set of edges with no common vertices.</p>
        
        <p style="margin: 10px 0;"><strong>MST (Minimum Spanning Tree):</strong> A tree that connects all vertices with minimum total edge weight.</p>
        
        <p style="margin: 10px 0;"><strong>Multigraph:</strong> A graph that allows multiple edges between the same pair of vertices.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">N</h3>
        
        <p style="margin: 10px 0;"><strong>Neighbor:</strong> A vertex adjacent to another vertex.</p>
        
        <p style="margin: 10px 0;"><strong>Network Flow:</strong> The amount of flow passing through edges in a flow network.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">O</h3>
        
        <p style="margin: 10px 0;"><strong>Out-degree:</strong> Number of edges going out from a vertex in a directed graph.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">P</h3>
        
        <p style="margin: 10px 0;"><strong>Path:</strong> A sequence of vertices where each adjacent pair is connected by an edge.</p>
        
        <p style="margin: 10px 0;"><strong>Planar Graph:</strong> A graph that can be drawn on a plane without edge crossings.</p>
        
        <p style="margin: 10px 0;"><strong>Prim's Algorithm:</strong> Finds MST by growing tree from a starting vertex. Time: O((V + E) log V).</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">S</h3>
        
        <p style="margin: 10px 0;"><strong>SCC (Strongly Connected Component):</strong> A maximal subgraph where every vertex is reachable from every other vertex.</p>
        
        <p style="margin: 10px 0;"><strong>Simple Graph:</strong> A graph with no loops or multiple edges.</p>
        
        <p style="margin: 10px 0;"><strong>Spanning Tree:</strong> A subgraph that includes all vertices and is a tree.</p>
        
        <p style="margin: 10px 0;"><strong>Subgraph:</strong> A graph formed from a subset of vertices and edges of another graph.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">T</h3>
        
        <p style="margin: 10px 0;"><strong>Topological Sort:</strong> A linear ordering of vertices in a DAG where all edges point forward. Time: O(V + E).</p>
        
        <p style="margin: 10px 0;"><strong>Tree:</strong> A connected acyclic graph. Has exactly V - 1 edges.</p>
        
        <p style="margin: 10px 0;"><strong>Trie:</strong> A tree structure for storing strings, where each path represents a string.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">U</h3>
        
        <p style="margin: 10px 0;"><strong>Undirected Graph:</strong> A graph where edges have no direction (bidirectional).</p>
        
        <p style="margin: 10px 0;"><strong>Union-Find:</strong> Data structure for tracking disjoint sets. Used in Kruskal's algorithm.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">V</h3>
        
        <p style="margin: 10px 0;"><strong>Vertex (Node):</strong> A fundamental unit in a graph. Plural: vertices.</p>
        
        <h3 style="margin-top: 20px; color: #1976d2;">W</h3>
        
        <p style="margin: 10px 0;"><strong>Walk:</strong> A sequence of vertices and edges (edges can repeat).</p>
        
        <p style="margin: 10px 0;"><strong>Weighted Graph:</strong> A graph where edges have associated weights/costs.</p>
    </div>

    <div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 30px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">📚 Quick Reference Tips</h3>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 8px;"><strong>V:</strong> Number of vertices</li>
            <li style="margin-bottom: 8px;"><strong>E:</strong> Number of edges</li>
            <li style="margin-bottom: 8px;"><strong>O(V + E):</strong> Linear time in graph size</li>
            <li style="margin-bottom: 8px;"><strong>O(V²):</strong> Quadratic time (often adjacency matrix)</li>
            <li style="margin-bottom: 8px;"><strong>O(E log V):</strong> Common for MST and shortest path algorithms</li>
        </ul>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="appb">
        
    <div class="chapter-number">Appendix B</div>
    <h1 class="chapter-title">Algorithm Complexity Table</h1>
    
    <div class="definition-box">
        "Quick reference for time and space complexity of all graph algorithms - know your performance guarantees."
    </div>

    <h2 class="section-title" id="appb-1">B.1 Time and Space Complexity for All Algorithms</h2>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto;">
        <h3 style="margin-top: 0; color: #1976d2;">Traversal Algorithms</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Algorithm</th>
                    <th style="text-align: left; padding: 12px;">Time Complexity</th>
                    <th style="text-align: left; padding: 12px;">Space Complexity</th>
                    <th style="text-align: left; padding: 12px;">Use Case</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>BFS</strong></td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Shortest path (unweighted), level-order</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>DFS</strong></td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Cycle detection, topological sort</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto;">
        <h3 style="margin-top: 0; color: #1976d2;">Shortest Path Algorithms</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Algorithm</th>
                    <th style="text-align: left; padding: 12px;">Time Complexity</th>
                    <th style="text-align: left; padding: 12px;">Space Complexity</th>
                    <th style="text-align: left; padding: 12px;">Constraints</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Dijkstra's</strong></td>
                    <td style="padding: 12px;">O((V + E) log V)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Non-negative weights only</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Bellman-Ford</strong></td>
                    <td style="padding: 12px;">O(VE)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Handles negative weights</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Floyd-Warshall</strong></td>
                    <td style="padding: 12px;">O(V³)</td>
                    <td style="padding: 12px;">O(V²)</td>
                    <td style="padding: 12px;">All-pairs shortest paths</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>A*</strong></td>
                    <td style="padding: 12px;">O(E) best case</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Requires good heuristic</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto;">
        <h3 style="margin-top: 0; color: #1976d2;">Minimum Spanning Tree</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Algorithm</th>
                    <th style="text-align: left; padding: 12px;">Time Complexity</th>
                    <th style="text-align: left; padding: 12px;">Space Complexity</th>
                    <th style="text-align: left; padding: 12px;">Approach</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Kruskal's</strong></td>
                    <td style="padding: 12px;">O(E log E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Edge-based, uses Union-Find</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Prim's</strong></td>
                    <td style="padding: 12px;">O((V + E) log V)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Vertex-based, uses priority queue</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto;">
        <h3 style="margin-top: 0; color: #1976d2;">Network Flow</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Algorithm</th>
                    <th style="text-align: left; padding: 12px;">Time Complexity</th>
                    <th style="text-align: left; padding: 12px;">Space Complexity</th>
                    <th style="text-align: left; padding: 12px;">Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Ford-Fulkerson</strong></td>
                    <td style="padding: 12px;">O(E × max_flow)</td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">Depends on max flow value</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Edmonds-Karp</strong></td>
                    <td style="padding: 12px;">O(VE²)</td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">Uses BFS for augmenting paths</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Dinic's</strong></td>
                    <td style="padding: 12px;">O(V²E)</td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">Faster in practice</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0; overflow-x: auto;">
        <h3 style="margin-top: 0; color: #1976d2;">Other Important Algorithms</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Algorithm</th>
                    <th style="text-align: left; padding: 12px;">Time Complexity</th>
                    <th style="text-align: left; padding: 12px;">Space Complexity</th>
                    <th style="text-align: left; padding: 12px;">Purpose</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Topological Sort</strong></td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Order vertices in DAG</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Tarjan's SCC</strong></td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Find strongly connected components</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Kosaraju's SCC</strong></td>
                    <td style="padding: 12px;">O(V + E)</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Find strongly connected components</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Graph Coloring</strong></td>
                    <td style="padding: 12px;">O(V + E) greedy</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Approximate coloring</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Union-Find</strong></td>
                    <td style="padding: 12px;">O(α(n)) per op</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Disjoint set operations</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Bron-Kerbosch</strong></td>
                    <td style="padding: 12px;">O(3^(V/3))</td>
                    <td style="padding: 12px;">O(V)</td>
                    <td style="padding: 12px;">Find all maximal cliques</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2 class="section-title" id="appb-2">B.2 Algorithm Decision Matrix</h2>
    
    <p class="academic-text">Use this decision tree to choose the right algorithm for your problem:</p>

    <div style="background-color: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #2e7d32;">🎯 Algorithm Selection Guide</h3>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to find a path?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Unweighted graph?</strong> → BFS (O(V + E))</li>
            <li style="margin-bottom: 8px;"><strong>Weighted, non-negative?</strong> → Dijkstra's (O((V + E) log V))</li>
            <li style="margin-bottom: 8px;"><strong>Negative weights?</strong> → Bellman-Ford (O(VE))</li>
            <li style="margin-bottom: 8px;"><strong>All pairs?</strong> → Floyd-Warshall (O(V³))</li>
            <li style="margin-bottom: 8px;"><strong>Have heuristic?</strong> → A* (O(E) best case)</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to connect all vertices?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Minimum cost?</strong> → MST (Kruskal's or Prim's)</li>
            <li style="margin-bottom: 8px;"><strong>Sparse graph?</strong> → Kruskal's (O(E log E))</li>
            <li style="margin-bottom: 8px;"><strong>Dense graph?</strong> → Prim's (O((V + E) log V))</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to order tasks?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Has dependencies?</strong> → Topological Sort (O(V + E))</li>
            <li style="margin-bottom: 8px;"><strong>Detect cycle?</strong> → DFS (O(V + E))</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to find flow?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Maximum flow?</strong> → Ford-Fulkerson or Edmonds-Karp</li>
            <li style="margin-bottom: 8px;"><strong>Bipartite matching?</strong> → Max flow algorithms</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to color graph?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Scheduling problem?</strong> → Graph coloring (greedy)</li>
            <li style="margin-bottom: 8px;"><strong>Bipartite check?</strong> → 2-coloring with BFS</li>
        </ul>
        
        <p style="margin: 15px 0 10px 0; font-family: sans-serif; font-size: 13pt;"><strong>Need to find components?</strong></p>
        <ul style="margin: 8px 0 16px 24px;">
            <li style="margin-bottom: 8px;"><strong>Connected components?</strong> → DFS/BFS (O(V + E))</li>
            <li style="margin-bottom: 8px;"><strong>Strongly connected?</strong> → Tarjan's or Kosaraju's (O(V + E))</li>
            <li style="margin-bottom: 8px;"><strong>Bridges/articulation points?</strong> → Tarjan's algorithm</li>
        </ul>
    </div>

    <div style="background-color: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin: 20px 0;">
        <p style="margin: 0; font-family: sans-serif; font-size: 12pt;"><strong>💡 Pro Tip:</strong> When in doubt, start with BFS/DFS. They're O(V + E) and solve many problems. Optimize only if needed!</p>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="appc">
        
    <div class="chapter-number">Appendix C</div>
    <h1 class="chapter-title">Practice Problems & Solutions</h1>
    
    <div class="definition-box">
        "30 curated problems from easy to hard - master graph algorithms through deliberate practice."
    </div>

    <h2 class="section-title">C.1 30 Curated Problems</h2>
    
    <p class="academic-text">Practice these problems on LeetCode, Codeforces, or HackerRank to master graph algorithms.</p>

    <h2 class="section-title">C.3 Online Judge Platform Links</h2>
    
    <div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">🔗 Practice Platforms</h3>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 12px;"><strong>LeetCode:</strong> leetcode.com/problemset/all/?topicSlugs=graph</li>
            <li style="margin-bottom: 12px;"><strong>Codeforces:</strong> codeforces.com/problemset?tags=graphs</li>
            <li style="margin-bottom: 12px;"><strong>HackerRank:</strong> hackerrank.com/domains/algorithms</li>
        </ul>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="appd">
        
    <div class="chapter-number">Appendix D</div>
    <h1 class="chapter-title">Visual Cheatsheet</h1>
    
    <div class="definition-box">
        "One-page visual summaries - your quick reference for graph types, algorithms, and patterns."
    </div>

    <h2 class="section-title" id="appd-1">D.1 One-Page Summary of Graph Types</h2>
    
    <div style="background-color: #f8f9fa; border: 2px solid #333; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2; text-align: center;">Graph Types Quick Reference</h3>
        
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt; margin-top: 20px;">
            <thead>
                <tr style="border-bottom: 2px solid #333; background-color: #e3f2fd;">
                    <th style="text-align: left; padding: 12px;">Type</th>
                    <th style="text-align: left; padding: 12px;">Properties</th>
                    <th style="text-align: left; padding: 12px;">Use Cases</th>
                </tr>
            </thead>
            <tbody>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Undirected</strong></td>
                    <td style="padding: 12px;">Edges have no direction</td>
                    <td style="padding: 12px;">Social networks, roads</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Directed (Digraph)</strong></td>
                    <td style="padding: 12px;">Edges have direction</td>
                    <td style="padding: 12px;">Web pages, dependencies</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Weighted</strong></td>
                    <td style="padding: 12px;">Edges have costs/weights</td>
                    <td style="padding: 12px;">Maps, networks</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Tree</strong></td>
                    <td style="padding: 12px;">Connected, acyclic, V-1 edges</td>
                    <td style="padding: 12px;">Hierarchies, file systems</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>DAG</strong></td>
                    <td style="padding: 12px;">Directed, no cycles</td>
                    <td style="padding: 12px;">Task scheduling, builds</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Bipartite</strong></td>
                    <td style="padding: 12px;">Two sets, edges between sets</td>
                    <td style="padding: 12px;">Matching problems</td>
                </tr>
                <tr style="border-bottom: 1px solid #ddd;">
                    <td style="padding: 12px;"><strong>Complete K<sub>n</sub></strong></td>
                    <td style="padding: 12px;">All vertices connected</td>
                    <td style="padding: 12px;">Worst-case analysis</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2 class="section-title" id="appd-2">D.2 Algorithm Decision Tree Flowchart</h2>
    
    <div style="background-color: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #2e7d32; text-align: center;">Which Algorithm Should I Use?</h3>
        
        <div style="margin: 20px 0;">
            <p style="font-weight: bold; margin: 15px 0;">🎯 NEED TO TRAVERSE?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Level by level? → <strong>BFS</strong></li>
                <li style="margin-bottom: 8px;">Deep exploration? → <strong>DFS</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">🛣️ NEED SHORTEST PATH?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Unweighted? → <strong>BFS</strong></li>
                <li style="margin-bottom: 8px;">Weighted, non-negative? → <strong>Dijkstra's</strong></li>
                <li style="margin-bottom: 8px;">Negative weights? → <strong>Bellman-Ford</strong></li>
                <li style="margin-bottom: 8px;">All pairs? → <strong>Floyd-Warshall</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">🌳 NEED TO CONNECT ALL?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Minimum cost? → <strong>MST (Kruskal's/Prim's)</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">📋 NEED TO ORDER TASKS?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">With dependencies? → <strong>Topological Sort</strong></li>
                <li style="margin-bottom: 8px;">Check for cycle? → <strong>DFS cycle detection</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">🌊 NEED MAXIMUM FLOW?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Network flow? → <strong>Ford-Fulkerson/Edmonds-Karp</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">🎨 NEED TO COLOR?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Scheduling? → <strong>Greedy Coloring</strong></li>
                <li style="margin-bottom: 8px;">Check bipartite? → <strong>2-coloring with BFS</strong></li>
            </ul>
            
            <p style="font-weight: bold; margin: 15px 0;">🔍 NEED TO FIND COMPONENTS?</p>
            <ul style="margin: 8px 0 0 40px;">
                <li style="margin-bottom: 8px;">Connected? → <strong>DFS/BFS</strong></li>
                <li style="margin-bottom: 8px;">Strongly connected? → <strong>Tarjan's/Kosaraju's</strong></li>
                <li style="margin-bottom: 8px;">Bridges? → <strong>Tarjan's algorithm</strong></li>
            </ul>
        </div>
    </div>

    <h2 class="section-title" id="appd-3">D.3 Common Patterns and Solutions</h2>
    
    <div style="background-color: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #e65100;">📚 Pattern Recognition Guide</h3>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Grid/Matrix Problems</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> 2D array, need to explore cells</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> DFS/BFS with 4 or 8 directions</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Number of Islands, Flood Fill</p>
        </div>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Prerequisites/Dependencies</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> Task A must come before B</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> Topological Sort (Kahn's or DFS)</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Course Schedule, Build Order</p>
        </div>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Shortest Distance</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> Find minimum steps/cost</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> BFS (unweighted) or Dijkstra's (weighted)</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Word Ladder, Network Delay</p>
        </div>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Connected Components</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> Count groups/clusters</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> DFS/BFS or Union-Find</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Number of Islands, Friend Circles</p>
        </div>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Cycle Detection</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> Check if graph has cycle</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> DFS with visited/recursion stack</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Course Schedule, Detect Cycle</p>
        </div>
        
        <div style="margin: 15px 0; padding: 15px; background-color: white; border-radius: 8px;">
            <p style="margin: 0 0 10px 0; font-weight: bold;">Pattern: Minimum Spanning Tree</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Recognition:</strong> Connect all with minimum cost</p>
            <p style="margin: 0 0 8px 0; font-size: 11pt;"><strong>Solution:</strong> Kruskal's or Prim's algorithm</p>
            <p style="margin: 0; font-size: 10pt; color: #666;"><strong>Examples:</strong> Min Cost to Connect Points</p>
        </div>
    </div>

    <div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 30px 0;">
        <h3 style="margin-top: 0; color: #1976d2; text-align: center;">⚡ Quick Complexity Reference</h3>
        <table style="width: 100%; border-collapse: collapse; font-size: 11pt; margin-top: 15px;">
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>BFS/DFS:</strong></td>
                <td style="padding: 8px;">O(V + E)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Dijkstra's:</strong></td>
                <td style="padding: 8px;">O((V + E) log V)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Bellman-Ford:</strong></td>
                <td style="padding: 8px;">O(VE)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Floyd-Warshall:</strong></td>
                <td style="padding: 8px;">O(V³)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Kruskal's:</strong></td>
                <td style="padding: 8px;">O(E log E)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Prim's:</strong></td>
                <td style="padding: 8px;">O((V + E) log V)</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px;"><strong>Topological Sort:</strong></td>
                <td style="padding: 8px;">O(V + E)</td>
            </tr>
        </table>
    </div>

    </div>
            
    <div class="min-h-screen academic-content page-break" id="appe">
        
    <div class="chapter-number">Appendix E</div>
    <h1 class="chapter-title">Further Reading & Resources</h1>
    
    <div class="definition-box">
        "Continue your graph theory journey - books, tools, and research topics to explore next."
    </div>

    <h2 class="section-title">E.1 Recommended Books</h2>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">Essential Books</h3>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 12px;"><strong>Introduction to Algorithms (CLRS)</strong> - Comprehensive algorithms textbook</li>
            <li style="margin-bottom: 12px;"><strong>Algorithm Design Manual</strong> by Skiena - Practical approach</li>
            <li style="margin-bottom: 12px;"><strong>Graph Theory</strong> by Diestel - Mathematical foundations</li>
            <li style="margin-bottom: 12px;"><strong>Networks</strong> by Newman - Network science perspective</li>
        </ul>
    </div>

    <h2 class="section-title">E.2 Online Resources</h2>
    
    <div style="background-color: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">Visualization Tools</h3>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 12px;"><strong>VisuAlgo:</strong> visualgo.net - Interactive algorithm visualizations</li>
            <li style="margin-bottom: 12px;"><strong>Graph Online:</strong> graphonline.ru - Create and analyze graphs</li>
            <li style="margin-bottom: 12px;"><strong>CS Academy:</strong> csacademy.com/app/graph_editor - Graph editor</li>
        </ul>
    </div>

    <h2 class="section-title">E.3 Research Topics</h2>
    
    <div style="background-color: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <h3 style="margin-top: 0; color: #2e7d32;">Advanced Topics to Explore</h3>
        <ul style="margin: 8px 0 0 24px;">
            <li style="margin-bottom: 12px;"><strong>Graph Neural Networks:</strong> Deep learning on graphs</li>
            <li style="margin-bottom: 12px;"><strong>Network Science:</strong> Complex networks and dynamics</li>
            <li style="margin-bottom: 12px;"><strong>Spectral Graph Theory:</strong> Eigenvalues and graph properties</li>
            <li style="margin-bottom: 12px;"><strong>Random Graphs:</strong> Probabilistic graph models</li>
        </ul>
    </div>

    </div>
            
</body>
</html>