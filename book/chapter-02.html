<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 2: Graph Properties & Special Types</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 2</div>
    <h1 class="chapter-title">Graph Properties & Special Types</h1>
    
    <div class="definition-box">
        "Not all graphs are created equal - understanding their special properties unlocks the right algorithms and solutions."
    </div>

    <p class="academic-text">Now that you understand basic graphs, let's dive deeper into their special properties. Just like people have different personalities, graphs have characteristics that determine what you can do with them and which algorithms work best.</p>
    
    <p class="academic-text">In this chapter, we'll explore the key properties that graph theorists and computer scientists use to classify and analyze graphs:</p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Connectivity:</strong> Can you get from anywhere to anywhere?</li>
        <li class="academic-text"><strong>Cycles:</strong> Are there circular paths in your graph?</li>
        <li class="academic-text"><strong>Bipartite structure:</strong> Can you divide nodes into two groups?</li>
        <li class="academic-text"><strong>Density:</strong> How many connections exist vs. how many could exist?</li>
    </ul>
    
    <p class="academic-text">These properties aren't just academic curiosities - they directly impact which algorithms you can use and how efficiently they'll run. Let's explore each one!</p>

    <h2 class="section-title" id="ch2-1">2.1 Connectivity: The Fundamental Structure of Networks</h2>
    
    <p class="academic-text">Connectivity is perhaps the most fundamental and revealing property of any graph. It tells us whether our network forms a unified whole or consists of separate, isolated communities. This seemingly simple concept has profound implications for how information flows, how systems behave, and which algorithms we can effectively apply.</p>

    <p class="academic-text">In the real world, connectivity determines whether a social network can spread information to everyone, whether a transportation system can get you anywhere you want to go, or whether a computer network can route data between any two points. Understanding connectivity is essential for network design, failure analysis, and system optimization.</p>

    <p class="academic-text">The mathematical definition of connectivity is elegant in its simplicity, but its implications are far-reaching. A connected graph ensures that no vertex is truly isolated - there's always a way to reach any vertex from any other vertex, even if it requires going through intermediate connections.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîó Graph Connectivity Defined</h3>
        <p class="academic-text">A graph is <strong>connected</strong> if there exists a path between every pair of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path:</strong> A sequence of edges that allows you to travel from one vertex to another</li>
            <li class="academic-text"><strong>Reachability:</strong> If you can find a path from vertex A to vertex B, then B is reachable from A</li>
            <li class="academic-text"><strong>Universal reachability:</strong> In a connected graph, every vertex is reachable from every other vertex</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Why connectivity is crucial for algorithms and applications:</strong> Many of the most important graph algorithms assume connectivity, or must be adapted to handle disconnected graphs. Shortest path algorithms, for example, can only find paths between vertices that are actually connected. Network analysis tools must identify separate components to understand the true structure of complex systems. Even simple operations like counting vertices become more complex when you need to account for isolated components.</p>

    <p class="academic-text">In practical systems, connectivity often determines resilience and efficiency. A connected transportation network ensures you can travel anywhere; a disconnected one leaves some destinations unreachable. A connected social network allows information to potentially reach everyone; a disconnected one creates isolated communities that may never interact.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Connected Graph (Everyone Can Reach Everyone):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            B --- C[Carol]
            C --- D[Dave]
            A --- D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Alice can reach Dave through Bob or Carol - everyone is reachable!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Technical note:</strong> In a connected graph with n vertices, you need at least n-1 edges. This is because you need enough edges to "link" all vertices together without leaving anyone isolated.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Disconnected Graph (Isolated Groups):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            C[Carol] --- D[Dave]
            E[Eve]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Three separate components - Alice can't reach Carol, and Eve is completely isolated</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A graph is disconnected if it contains two or more connected components that are not connected to each other.
        </div>
    </div>

    <p class="academic-text"><strong>Real-World Examples:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Connected:</strong> Internet (you can reach any website), highway system, social networks</li>
        <li class="academic-text"><strong>Disconnected:</strong> Separate friend groups, isolated computer networks, different continents without bridges</li>
    </ul>

    <pre class="code-block">// Check if entire graph is connected using DFS traversal
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;
using namespace std;

class ConnectivityChecker {
private:
    unordered_map&lt;string, vector&lt;string&gt;&gt; graph;
    
    // Depth-First Search to visit all reachable nodes
    void dfs(const string&amp; node, unordered_set&lt;string&gt;&amp; visited) {
        visited.insert(node);
        // Recursively visit all unvisited neighbors
        for (const string&amp; neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                dfs(neighbor, visited);
            }
        }
    }
    
public:
    // Add undirected edge between two nodes
    void addEdge(const string&amp; u, const string&amp; v) {
        graph[u].push_back(v);
        graph[v].push_back(u); // Undirected graph
    }
    
    // Check if all nodes are reachable from any starting node
    bool isConnected() {
        if (graph.empty()) return true;
        unordered_set&lt;string&gt; visited;
        dfs(graph.begin()-&gt;first, visited); // Start DFS from any node
        return visited.size() == graph.size(); // All nodes visited?
    }
};</pre>

    <h2 class="section-title" id="ch2-2">2.2 Strongly Connected Components: The Direction Matters</h2>

    <p class="academic-text">In directed graphs, connectivity gets more interesting! A <strong>strongly connected component (SCC)</strong> is a group of nodes where you can get from any node to any other node following the arrow directions.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Strongly Connected Components Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --> B[Bob]
            B --> C[Carol]
            C --> A
            
            D[Dave] --> E[Eve]
            E --> F[Frank]
            F --> D
            
            B --> D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two SCCs: {Alice, Bob, Carol} and {Dave, Eve, Frank}. You can go from Alice‚ÜíBob‚ÜíCarol‚ÜíAlice, but not back from Dave to Bob!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A strongly connected component is a maximal set of vertices such that for every pair of vertices u and v, there is a directed path from u to v and from v to u.
        </div>
    </div>

    <p class="academic-text"><strong>Why SCCs Matter:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Web analysis:</strong> Groups of websites that link to each other</li>
        <li class="academic-text"><strong>Social networks:</strong> Tight-knit communities where everyone follows everyone</li>
        <li class="academic-text"><strong>Software dependencies:</strong> Circular dependencies that need to be resolved together</li>
    </ul>

    <h2 class="section-title" id="ch2-3">2.3 Directed Acyclic Graphs (DAGs): The Foundation of Ordered Systems</h2>

    <p class="academic-text">A <strong>Directed Acyclic Graph (DAG)</strong> represents one of the most important and useful structures in computer science and mathematics. It's a directed graph with no cycles - meaning you can never follow the arrows and return to where you started. This seemingly simple constraint creates a powerful mathematical structure that naturally represents hierarchies, dependencies, and ordered processes.</p>

    <p class="academic-text">DAGs are everywhere in computer science because they model systems where order matters and circular dependencies would be problematic or impossible. Think about course prerequisites - you can't take Advanced Calculus before Basic Calculus, and you certainly can't have a situation where Advanced Calculus is a prerequisite for Basic Calculus! This natural ordering property makes DAGs perfect for representing dependency relationships, scheduling problems, and hierarchical structures.</p>

    <p class="academic-text">The absence of cycles in a DAG guarantees that we can always find a valid ordering of vertices called a "topological ordering" - an arrangement where all edges point "forward" in the sequence. This property is fundamental to many algorithms and applications, from project scheduling to compiler design to version control systems.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DAG Example (Course Prerequisites):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Math 101] --> B[Math 201]
            A --> C[Physics 101]
            B --> D[Math 301]
            C --> E[Physics 201]
            D --> F[Advanced Math]
            E --> F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Clear progression from basic to advanced courses - no circular prerequisites!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A DAG is a directed graph with no directed cycles. It has a topological ordering where vertices can be arranged so all edges point "forward."
        </div>
    </div>

    <p class="academic-text"><strong>DAG Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Task scheduling:</strong> Project tasks with dependencies</li>
        <li class="academic-text"><strong>Build systems:</strong> Compile order for software modules</li>
        <li class="academic-text"><strong>Family trees:</strong> Ancestry relationships</li>
        <li class="academic-text"><strong>Decision trees:</strong> Step-by-step decision making</li>
    </ul>

    <pre class="code-block">// Simple DAG implementation for task scheduling
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
using namespace std;

class TaskScheduler {
private:
    unordered_map<string, vector<string>> dependencies; // task -> list of tasks it depends on
    unordered_map<string, vector<string>> dependents;   // task -> list of tasks that depend on it
    unordered_map<string, int> inDegree;               // task -> number of dependencies
    
public:
    void addTask(const string& task) {
        if (dependencies.find(task) == dependencies.end()) {
            dependencies[task] = vector<string>();
            dependents[task] = vector<string>();
            inDegree[task] = 0;
        }
    }
    
    // Add dependency: taskB depends on taskA (taskA must be done before taskB)
    void addDependency(const string& taskA, const string& taskB) {
        addTask(taskA);
        addTask(taskB);
        
        dependencies[taskB].push_back(taskA);
        dependents[taskA].push_back(taskB);
        inDegree[taskB]++;
    }
    
    // Get the order in which tasks should be completed (topological sort)
    vector<string> getTaskOrder() {
        vector<string> result;
        queue<string> readyTasks;
        unordered_map<string, int> currentInDegree = inDegree;
        
        // Find tasks with no dependencies
        for (const auto& [task, degree] : currentInDegree) {
            if (degree == 0) {
                readyTasks.push(task);
            }
        }
        
        while (!readyTasks.empty()) {
            string currentTask = readyTasks.front();
            readyTasks.pop();
            result.push_back(currentTask);
            
            // Remove this task and update dependencies
            for (const string& dependent : dependents[currentTask]) {
                currentInDegree[dependent]--;
                if (currentInDegree[dependent] == 0) {
                    readyTasks.push(dependent);
                }
            }
        }
        
        // Check if we have a cycle (couldn't complete all tasks)
        if (result.size() != dependencies.size()) {
            cout << "Error: Circular dependency detected!" << endl;
            return vector<string>();
        }
        
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch2-4">2.4 Bipartite Graphs and Graph Density: Special Structures</h2>

    <p class="academic-text"><strong>Bipartite Graphs: Modeling Two-Sided Relationships</strong></p>
    <p class="academic-text">A <strong>bipartite graph</strong> represents a special and incredibly useful type of network structure where vertices can be divided into two distinct groups, and relationships only exist between groups - never within a group. Think of it as modeling situations where you have two different types of entities that interact with each other, but entities of the same type don't directly connect.</p>

    <p class="academic-text">Bipartite graphs are everywhere in real-world systems. Consider students and courses - students enroll in courses, but students don't directly "connect" to other students in this relationship, and courses don't connect to other courses. Or think about customers and products in an e-commerce system, actors and movies in a film database, or researchers and papers in an academic network. These natural two-sided relationships are perfectly captured by bipartite graphs.</p>

    <p class="academic-text">The power of recognizing bipartite structure lies in the specialized algorithms and analysis techniques that become available. Bipartite graphs have unique properties - they can always be colored with just two colors, they have special matching algorithms, and they enable powerful recommendation systems. Many seemingly complex network problems become much more tractable when you recognize the underlying bipartite structure.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bipartite Graph (Students and Courses):</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph Students
                A[Alice]
                B[Bob]
                C[Carol]
            end
            
            subgraph Courses
                D[Math]
                E[Physics]
                F[Chemistry]
            end
            
            A --- D
            A --- E
            B --- D
            B --- F
            C --- E
            C --- F
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Students only connect to courses, courses only connect to students - no student-to-student edges!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A bipartite graph G = (V, E) has vertex set V that can be partitioned into two disjoint sets V‚ÇÅ and V‚ÇÇ such that every edge connects a vertex in V‚ÇÅ to a vertex in V‚ÇÇ.
        </div>
    </div>

    <p class="academic-text"><strong>Graph Density: Measuring Network Interconnectedness</strong></p>
    <p class="academic-text">Graph density is a fundamental metric that quantifies how interconnected a network is by measuring what fraction of all possible connections actually exist. It's like asking: "Out of all the friendships that could theoretically exist in this social network, how many actually do exist?" This simple ratio reveals profound insights about network structure, behavior, and the algorithms that will work best on it.</p>

    <p class="academic-text">Density profoundly affects how networks behave and which algorithms are most efficient. Dense networks - where most vertices are connected to most other vertices - behave very differently from sparse networks where each vertex has relatively few connections. Social networks tend to be sparse (you're not friends with most people), while certain biological networks can be quite dense (many genes interact with many other genes).</p>

    <p class="academic-text">Understanding density is crucial for choosing the right data structures and algorithms. Dense graphs often benefit from adjacency matrix representations and algorithms optimized for high connectivity, while sparse graphs are better served by adjacency lists and algorithms that take advantage of the limited number of edges. The density of your graph can determine whether an algorithm runs in seconds or hours.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Density Examples:</strong><br><br>
        <div class="mermaid">
        graph LR
            subgraph "Sparse Graph (Low Density)"
                A1[A] --- B1[B]
                C1[C] --- D1[D]
            end
            
            subgraph "Dense Graph (High Density)"
                A2[A] --- B2[B]
                A2 --- C2[C]
                A2 --- D2[D]
                B2 --- C2
                B2 --- D2
                C2 --- D2
            end
            
            style A1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style B1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style C1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style D1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            
            style A2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D2 fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Sparse: 2 edges out of 6 possible (33% density) vs Dense: 6 edges out of 6 possible (100% density)</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> For an undirected graph with n vertices, density = 2|E| / (n(n-1)), where |E| is the number of edges. Range: 0 (no edges) to 1 (complete graph).
        </div>
    </div>

    <pre class="code-block">// Graph analysis tools
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;
using namespace std;

class GraphAnalyzer {
private:
    unordered_map<string, vector<string>> graph;
    
public:
    void addEdge(const string& u, const string& v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Calculate graph density
    double getDensity() {
        int n = graph.size();
        if (n <= 1) return 0.0;
        
        int edges = 0;
        for (const auto& [node, neighbors] : graph) {
            edges += neighbors.size();
        }
        edges /= 2; // Each edge counted twice in undirected graph
        
        int maxPossibleEdges = n * (n - 1) / 2;
        return (double)edges / maxPossibleEdges;
    }
    
    // Check if graph is bipartite using 2-coloring
    bool isBipartite() {
        if (graph.empty()) return true;
        
        unordered_map<string, int> color; // 0 = uncolored, 1 = red, 2 = blue
        
        for (const auto& [startNode, neighbors] : graph) {
            if (color[startNode] == 0) {
                // Start BFS/DFS from this component
                vector<string> queue = {startNode};
                color[startNode] = 1;
                
                for (size_t i = 0; i < queue.size(); i++) {
                    string current = queue[i];
                    int currentColor = color[current];
                    int neighborColor = (currentColor == 1) ? 2 : 1;
                    
                    for (const string& neighbor : graph[current]) {
                        if (color[neighbor] == 0) {
                            color[neighbor] = neighborColor;
                            queue.push_back(neighbor);
                        } else if (color[neighbor] == currentColor) {
                            return false; // Same color as neighbor - not bipartite!
                        }
                    }
                }
            }
        }
        return true;
    }
    
    void printAnalysis() {
        cout << "Graph Analysis:" << endl;
        cout << "Nodes: " << graph.size() << endl;
        cout << "Density: " << (getDensity() * 100) << "%" << endl;
        cout << "Bipartite: " << (isBipartite() ? "Yes" : "No") << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üéØ Quick Reference: Graph Properties</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Connectivity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Connected:</strong> Path between any two nodes</li>
                    <li class="academic-text"><strong>SCC:</strong> Directed cycles in directed graphs</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Structure</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>DAG:</strong> No cycles, has ordering</li>
                    <li class="academic-text"><strong>Bipartite:</strong> Two groups, edges between groups</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 2 Complete!</h3>
        <p class="academic-text">You now understand the key properties that make graphs special:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Connectivity</strong> - whether you can reach everywhere</li>
            <li class="academic-text">‚úÖ <strong>Strong connectivity</strong> - directed graph communities</li>
            <li class="academic-text">‚úÖ <strong>DAGs</strong> - ordered structures without cycles</li>
            <li class="academic-text">‚úÖ <strong>Bipartite graphs</strong> - two-sided relationships</li>
            <li class="academic-text">‚úÖ <strong>Graph density</strong> - how connected your graph is</li>
        </ul>
        
        <p class="academic-text">These properties help you choose the right algorithms and understand what's possible with your graph. Next up: <strong>Trees</strong> - the most important special case of graphs!</p>
    </div>
</body>
</html>
