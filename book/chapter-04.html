<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 4: Tries and Prefix Structures</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 4</div>
    <h1 class="chapter-title">Tries and Prefix Structures</h1>
    
    <div class="definition-box">
        "Tries are the secret behind autocomplete, spell checkers, and fast string searches. They're trees specialized for text!"
    </div>

    <p class="academic-text">Ever wonder how your smartphone can predict entire words after you type just a few letters? Or how Google can suggest millions of search queries in milliseconds as you type? The secret behind these seemingly magical text prediction systems is an elegant data structure called a <strong>trie</strong> (pronounced "try" - from "reTRIEval"). Tries represent one of the most specialized and powerful applications of tree structures, designed specifically to solve the complex challenges of text processing, string matching, and prefix-based operations.</p>
    
    <p class="academic-text">Tries revolutionize text processing by exploiting a fundamental property of human language: words often share common prefixes. Instead of storing each word independently, tries create a shared tree structure where common beginnings are stored only once. This elegant approach not only saves enormous amounts of memory but also enables lightning-fast prefix operations that would be impossible with traditional data structures. The result is a system that can handle millions of words while providing instant responses to text queries.</p>

    <p class="academic-text">The power of tries extends far beyond simple word storage. They enable sophisticated algorithms for autocomplete, spell checking, pattern matching, and even network routing. By organizing text data hierarchically based on character sequences, tries transform complex string problems into simple tree traversal operations. This makes them indispensable for any application that needs to process, search, or analyze text efficiently.</p>
    
    <p class="academic-text"><strong>Tries power the text technologies you use every day:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> Google's instant search suggestions analyze billions of queries using trie structures to predict what you're looking for before you finish typing</li>
        <li class="academic-text"><strong>Code editors:</strong> IDEs like VS Code use tries to provide instant autocomplete for variable names, function calls, and API methods across massive codebases</li>
        <li class="academic-text"><strong>Spell checkers:</strong> Word processors and browsers use tries containing entire dictionaries to instantly identify misspellings and suggest corrections</li>
        <li class="academic-text"><strong>Mobile keyboards:</strong> Smartphone keyboards use tries to enable predictive text, swipe typing, and multilingual input across thousands of languages</li>
        <li class="academic-text"><strong>Network routing:</strong> Internet routers use tries to match IP addresses and efficiently route data packets across the global internet infrastructure</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> DNA sequence analysis uses tries to identify genetic patterns and mutations in massive genomic databases</li>
    </ul>

    <h2 class="section-title" id="ch4-1">4.1 Trie Data Structure and Operations</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ”¤ Trie Definition</h3>
        <p class="academic-text">A <strong>trie</strong> (prefix tree) is a tree where each path from root represents a string, and each node represents a character.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Path = Word:</strong> Each root-to-node path spells out a prefix or complete word</li>
            <li class="academic-text"><strong>Shared Prefixes:</strong> Words with common beginnings share the same path</li>
            <li class="academic-text"><strong>Marked Endings:</strong> Special markers indicate where complete words end</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>The brilliance of trie design:</strong> Tries achieve remarkable efficiency by recognizing that human language is inherently hierarchical. Words like "CAR", "CARD", "CARE", and "CAREFUL" don't need to be stored as separate entities - they can share the common "CAR" prefix in the tree structure. This sharing principle scales beautifully: a trie containing a million English words might share thousands of common prefixes, dramatically reducing memory usage while simultaneously speeding up search operations.</p>

    <p class="academic-text">The mathematical elegance of tries lies in how they transform string operations from linear searches into tree traversals. Finding a word becomes a simple path-following operation, where each character guides you to the next level of the tree. This approach guarantees that search time depends only on the length of the word being searched, not on how many words are stored in the trie - a remarkable property that enables tries to scale to enormous datasets.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Trie Example (Words: CAT, CAR, CARD, CARE, CAREFUL):</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D[D*]
            R --> E[E*]
            E --> F[F]
            F --> U[U]
            U --> L[L*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style A fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style T fill:#ffebee,stroke:#f44336,stroke-width:3px
            style R fill:#ffebee,stroke:#f44336,stroke-width:3px
            style D fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style E fill:#f3e5f5,stroke:#9c27b0,stroke-width:3px
            style F fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style U fill:#e1f5fe,stroke:#00bcd4,stroke-width:2px
            style L fill:#f1f8e9,stroke:#8bc34a,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">* marks end of word. Path ROOTâ†’Câ†’Aâ†’T spells "CAT"</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A trie is a tree data structure where each node represents a character and each path from root to a marked node represents a stored string.
        </div>
    </div>

    <p class="academic-text"><strong>Why Tries Are Amazing:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Shared prefixes:</strong> "CAR", "CARD", "CARE" share the path Câ†’Aâ†’R</li>
        <li class="academic-text"><strong>Fast lookup:</strong> Find any word in O(word length) time</li>
        <li class="academic-text"><strong>Prefix magic:</strong> Find all words starting with "CA" instantly</li>
        <li class="academic-text"><strong>Memory efficient:</strong> Common prefixes stored only once</li>
    </ul>

    <pre class="code-block">// Simple Trie implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

// Trie node - each node represents one character
struct TrieNode {
    vector<TrieNode*> children;  // 26 children for a-z
    bool isEndOfWord;            // True if this node ends a valid word
    char character;              // Character this node represents
    
    TrieNode(char c = '\0') : character(c), isEndOfWord(false) {
        children.resize(26, nullptr); // Initialize all children to null
    }
};

class SimpleTrie {
private:
    TrieNode* root;  // Root node (empty character)
    
    // Convert character to array index (a=0, b=1, ..., z=25)
    int charToIndex(char c) {
        return c - 'a';
    }
    
public:
    SimpleTrie() {
        root = new TrieNode();
    }
    
    // Insert a word into the trie
    void insert(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            
            if (current->children[index] == nullptr) {
                current->children[index] = new TrieNode(c);
            }
            current = current->children[index];
        }
        current->isEndOfWord = true;
    }
    
    // Search for a word
    bool search(string word) {
        TrieNode* current = root;
        
        for (char c : word) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return current->isEndOfWord;
    }
    
    // Check if any word starts with this prefix
    bool startsWith(string prefix) {
        TrieNode* current = root;
        
        for (char c : prefix) {
            int index = charToIndex(c);
            if (current->children[index] == nullptr) {
                return false;
            }
            current = current->children[index];
        }
        return true; // We found the complete prefix path
    }
    
    // Build a sample trie with common words
    static SimpleTrie* buildSampleTrie() {
        SimpleTrie* trie = new SimpleTrie();
        vector<string> words = {"cat", "car", "card", "care", "careful", "dog", "dodge"};
        
        for (string word : words) {
            trie->insert(word);
        }
        return trie;
    }
};</pre>

    <h2 class="section-title" id="ch4-2">4.2 String Searching and Autocomplete Systems</h2>

    <p class="academic-text"><strong>Autocomplete: The Art of Prediction</strong></p>
    <p class="academic-text">Autocomplete represents one of the most impressive applications of tries, transforming the simple act of typing into an intelligent conversation between human and machine. When you type "ca" and instantly see suggestions like "cat", "car", "care", you're witnessing a sophisticated algorithm that traverses a trie structure to find all possible completions of your partial input. This seemingly simple feature requires complex engineering to handle millions of words, rank suggestions by relevance, and respond in milliseconds.</p>

    <p class="academic-text">The magic of autocomplete lies in how tries make prefix matching trivial. Instead of scanning through entire dictionaries to find words that start with "ca", the system simply follows the path Câ†’A in the trie and then explores all branches below that point. Every path from that node to a word ending represents a valid completion. This approach scales beautifully - whether you're searching through a hundred words or a hundred million, the time to find all completions depends only on the length of your prefix and the number of matching results.</p>

    <p class="academic-text">Modern autocomplete systems extend this basic concept with sophisticated ranking algorithms, personalization, and context awareness. They might prioritize frequently used words, consider your typing history, or even predict entire phrases based on patterns in your communication. But at the core, they all rely on the fundamental efficiency of trie-based prefix matching.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Autocomplete Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> C[C]
            Root --> D[D]
            C --> A[A]
            A --> T[T*]
            A --> R[R*]
            R --> D1[D*]
            R --> E[E*]
            D --> O[O]
            O --> G[G*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#ffeb3b,stroke:#333,stroke-width:4px
            style A fill:#ffeb3b,stroke:#333,stroke-width:4px
            style T fill:#ff9800,stroke:#333,stroke-width:2px
            style R fill:#ff9800,stroke:#333,stroke-width:2px
            style D1 fill:#ff9800,stroke:#333,stroke-width:2px
            style E fill:#ff9800,stroke:#333,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style O fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style G fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">User types "CA" â†’ Highlighted path shows all words starting with "CA": CAT, CAR, CARD, CARE</p>
    </div>

    <p class="academic-text"><strong>How Autocomplete Works:</strong></p>
    <ol style="margin: 8px 0 16px 24px;">
        <li class="academic-text">User types a prefix (like "ca")</li>
        <li class="academic-text">Find the node representing that prefix in the trie</li>
        <li class="academic-text">Collect all complete words in the subtree below that node</li>
        <li class="academic-text">Return the suggestions to the user</li>
    </ol>

    <pre class="code-block">// Autocomplete system using trie
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

class AutoComplete {
private:
    SimpleTrie* trie;
    
    void collectWords(TrieNode* node, string word, vector<string>& results) {
        if (!node) return;
        if (node->isEndOfWord) results.push_back(word);
        for (int i = 0; i < 26; i++) {
            if (node->children[i]) {
                collectWords(node->children[i], word + char('a' + i), results);
            }
        }
    }
    
public:
    AutoComplete() {
        trie = SimpleTrie::buildSampleTrie();
    }
    
    // Get autocomplete suggestions for a prefix
    vector<string> getSuggestions(string prefix) {
        vector<string> suggestions;
        
        TrieNode* prefixNode = findPrefixNode(prefix);
        if (prefixNode == nullptr) {
            return suggestions; // No words with this prefix
        }
        
        collectWords(prefixNode, prefix, suggestions);
        return suggestions;
    }
    
    // Add a new word to the dictionary
    void addWord(string word) {
        trie->insert(word);
    }
    
    // Demo function
    static void demo() {
        AutoComplete ac;
        
        cout << "Autocomplete Demo:" << endl;
        vector<string> prefixes = {"ca", "car", "d"};
        
        for (string prefix : prefixes) {
            cout << "Typing '" << prefix << "' suggests: ";
            vector<string> suggestions = ac.getSuggestions(prefix);
            
            for (string suggestion : suggestions) {
                cout << suggestion << " ";
            }
            cout << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch4-3">4.3 Applications: Spell Checkers, Dictionaries, IP Routing</h2>

    <p class="academic-text">The versatility of tries extends far beyond autocomplete, powering a remarkable range of applications that touch nearly every aspect of modern computing. From the spell checker that catches your typos to the routers that deliver this webpage to your device, tries provide the algorithmic foundation for systems that process, analyze, and route text-based information at massive scale.</p>

    <p class="academic-text"><strong>1. Spell Checkers: Intelligent Error Detection and Correction</strong></p>
    <p class="academic-text">Modern spell checkers represent sophisticated applications of trie technology that go far beyond simple dictionary lookups. When you misspell "receive" as "recieve", the spell checker doesn't just identify the error - it uses advanced algorithms to generate plausible corrections by systematically exploring variations of your input. The system might try inserting, deleting, or substituting characters to find words in its trie-based dictionary that are "close" to your misspelling.</p>

    <p class="academic-text">The power of trie-based spell checking lies in its ability to efficiently explore the space of possible corrections. Instead of generating every possible variation of a misspelled word and checking each one individually, sophisticated spell checkers can traverse the trie while simultaneously considering multiple types of errors. This enables them to find corrections quickly even for severely mangled words, while ranking suggestions based on factors like edit distance, word frequency, and contextual appropriateness.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Spell Checker Strategy:</strong><br><br>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dictionary trie:</strong> Contains all correct words</li>
            <li class="academic-text"><strong>Check word:</strong> Search in trie - if not found, it's misspelled</li>
            <li class="academic-text"><strong>Find suggestions:</strong> Try small changes (add/remove/change letters)</li>
            <li class="academic-text"><strong>Rank suggestions:</strong> Prefer words with similar prefixes</li>
        </ul>
    </div>

    <p class="academic-text"><strong>2. IP Address Routing: The Internet's Navigation System</strong></p>
    <p class="academic-text">One of the most critical and fascinating applications of tries operates invisibly behind every webpage you visit, every email you send, and every video you stream. Internet routers use specialized tries called "routing tables" to make split-second decisions about where to forward your data packets across the global network. When you request a webpage, your data must traverse multiple routers, each using trie-based algorithms to determine the optimal next hop toward the destination.</p>

    <p class="academic-text">IP routing tries work by treating IP addresses as strings of binary digits, creating a tree where each level represents one bit of the address. This binary trie structure enables routers to perform longest prefix matching - finding the most specific route available for any given destination. The beauty of this system lies in its scalability: even as the internet grows to billions of devices, routers can make forwarding decisions in constant time by following a path through their routing trie.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>IP Routing Trie Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            Root[ROOT] --> Zero[0]
            Root --> One[1]
            Zero --> Z0[0]
            Zero --> Z1[1]
            One --> O0[0]
            One --> O1[1]
            Z0 --> Route1[Route A*]
            Z1 --> Route2[Route B*]
            O0 --> Route3[Route C*]
            O1 --> Route4[Route D*]
            
            style Root fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style Zero fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style One fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style Z0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Z1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O0 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style O1 fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style Route1 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route2 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route3 fill:#ffebee,stroke:#f44336,stroke-width:2px
            style Route4 fill:#ffebee,stroke:#f44336,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">IP 192.168.1.1 â†’ Binary 11000000... â†’ Follow path 1â†’1â†’0â†’0... to find route</p>
    </div>

    <pre class="code-block">// Simple spell checker using trie
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
using namespace std;

class SpellChecker {
private:
    SimpleTrie* dictionary;
    
    // Generate words with one character changed
    set<string> generateEdits(string word) {
        set<string> edits;
        
        // Try changing each character
        for (int i = 0; i < word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                if (c != word[i]) {
                    string edited = word;
                    edited[i] = c;
                    edits.insert(edited);
                }
            }
        }
        
        // Try removing each character
        for (int i = 0; i < word.length(); i++) {
            string edited = word.substr(0, i) + word.substr(i + 1);
            edits.insert(edited);
        }
        
        // Try adding a character at each position
        for (int i = 0; i <= word.length(); i++) {
            for (char c = 'a'; c <= 'z'; c++) {
                string edited = word.substr(0, i) + c + word.substr(i);
                edits.insert(edited);
            }
        }
        
        return edits;
    }
    
public:
    SpellChecker() {
        dictionary = SimpleTrie::buildSampleTrie();
        // Add more common words
        dictionary->insert("hello");
        dictionary->insert("world");
        dictionary->insert("computer");
        dictionary->insert("science");
    }
    
    // Check if word is spelled correctly
    bool isCorrect(string word) {
        return dictionary->search(word);
    }
    
    // Get spelling suggestions
    vector<string> getSuggestions(string misspelledWord) {
        vector<string> suggestions;
        
        if (isCorrect(misspelledWord)) {
            return suggestions; // Word is already correct
        }
        
        set<string> possibleEdits = generateEdits(misspelledWord);
        
        for (string edit : possibleEdits) {
            if (dictionary->search(edit)) {
                suggestions.push_back(edit);
            }
        }
        
        return suggestions;
    }
    
    // Demo function
    static void demo() {
        SpellChecker checker;
        
        cout << "Spell Checker Demo:" << endl;
        vector<string> testWords = {"cat", "cta", "carr", "carefull"};
        
        for (string word : testWords) {
            if (checker.isCorrect(word)) {
                cout << "'" << word << "' is spelled correctly!" << endl;
            } else {
                cout << "'" << word << "' is misspelled. Suggestions: ";
                vector<string> suggestions = checker.getSuggestions(word);
                for (string suggestion : suggestions) {
                    cout << suggestion << " ";
                }
                cout << endl;
            }
        }
    }
};</pre>

    <p class="academic-text"><strong>Other Amazing Trie Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Search Engines:</strong> Google uses tries for query suggestions</li>
        <li class="academic-text"><strong>Code Editors:</strong> Autocomplete for variable names and functions</li>
        <li class="academic-text"><strong>Phone Contacts:</strong> T9 predictive text on old phones</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> DNA sequence matching</li>
        <li class="academic-text"><strong>Compression:</strong> Finding repeated patterns in text</li>
        <li class="academic-text"><strong>Games:</strong> Word games like Scrabble and Boggle</li>
    </ul>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">ðŸ”¤ Trie Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Search:</strong> O(word length)</li>
                    <li class="academic-text"><strong>Prefix check:</strong> O(prefix length)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text">Shared prefixes save memory</li>
                    <li class="academic-text">Fast prefix operations</li>
                    <li class="academic-text">Natural autocomplete structure</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">ðŸŽ‰ Chapter 4 Complete!</h3>
        <p class="academic-text">You now understand tries - specialized trees for text processing:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">âœ… <strong>Trie structure</strong> - character nodes forming word paths</li>
            <li class="academic-text">âœ… <strong>Core operations</strong> - insert, search, prefix checking</li>
            <li class="academic-text">âœ… <strong>Autocomplete systems</strong> - how suggestions work</li>
            <li class="academic-text">âœ… <strong>Real applications</strong> - spell checkers, routing, search engines</li>
        </ul>
        
        <p class="academic-text">Tries show how specialized data structures solve specific problems elegantly. Next: <strong>Heaps</strong> - trees optimized for priority and ordering!</p>
    </div>
</body>
</html>
