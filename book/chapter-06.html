<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Traversal Algorithms</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 6</div>
    <h1 class="chapter-title">Traversal Algorithms</h1>

    <div class="definition-box">
        "Graph traversal is like exploring a maze - you need systematic strategies to visit every room without getting
        lost."
    </div>

    <p class="academic-text">Welcome to the algorithmic heart of graph theory! Having mastered the fundamental
        structures - graphs, trees, tries, and heaps - you're now ready to explore the algorithms that bring these
        structures to life. Graph traversal algorithms represent the foundation upon which virtually every graph
        algorithm is built, from the simplest connectivity checks to the most sophisticated network analysis and
        artificial intelligence systems.</p>

    <p class="academic-text">Traversal algorithms solve the fundamental challenge of systematic exploration: how do you
        visit every node in a graph exactly once, in a predictable order, without getting lost or missing anything? This
        seemingly simple problem underlies countless applications - web crawlers exploring the internet, social media
        algorithms analyzing friend networks, GPS systems finding routes, and AI systems searching through solution
        spaces. The strategies you learn here will appear again and again throughout computer science.</p>

    <p class="academic-text">The beauty of graph traversal lies in how two simple, contrasting strategies -
        breadth-first and depth-first search - can solve an enormous range of problems. These aren't just academic
        exercises; they're the algorithmic building blocks that power search engines, social networks, navigation
        systems, and countless other technologies you use daily. Understanding these traversal patterns will give you
        the foundation to tackle complex algorithmic challenges across every domain of computer science.</p>

    <p class="academic-text"><strong>The two fundamental exploration strategies that power modern computing:</strong>
    </p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Breadth-First Search (BFS):</strong> Explores systematically by distance, like
            ripples spreading from a stone dropped in water - perfect for finding shortest paths and analyzing network
            structure</li>
        <li class="academic-text"><strong>Depth-First Search (DFS):</strong> Explores by going as deep as possible
            before backtracking, like a maze solver following each path to its end - ideal for detecting cycles and
            analyzing connectivity</li>
    </ul>

    <h2 class="section-title" id="ch6-1">6.1 Breadth-First Search (BFS)</h2>

    <p class="academic-text">BFS explores a graph level by level, like ripples spreading out from a stone dropped in
        water. It visits all nodes at distance 1, then all nodes at distance 2, and so on.</p>

    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üåä BFS Strategy</h3>
        <p class="academic-text"><strong>Breadth-First Search</strong> systematically explores nodes in order of their
            distance from the starting node.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Level-by-level:</strong> Visit all nodes at distance k before any at
                distance k+1</li>
            <li class="academic-text"><strong>Queue-based:</strong> Uses a FIFO queue to maintain exploration order</li>
            <li class="academic-text"><strong>Shortest paths:</strong> Finds shortest unweighted paths naturally</li>
        </ul>
    </div>

    <div
        style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>BFS Exploration Example (Starting from A):</strong><br><br>
        <div class="mermaid">
            graph LR
            A[A:0] --- B[B:1]
            A --- C[C:1]
            B --- D[D:2]
            B --- E[E:2]
            C --- F[F:2]

            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show
            distance from A. BFS visits: A(0) ‚Üí B,C(1) ‚Üí D,E,F(2)</p>
    </div>

    <pre class="code-block">// Breadth-First Search - explores level by level using queue
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_set&gt;
using namespace std;

class BFS {
private:
    vector&lt;vector&lt;int&gt;&gt; graph;  // Adjacency list representation
    
public:
    BFS(int n) : graph(n) {}
    
    // Add undirected edge between two nodes
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u); // Make it undirected
    }
    
    // BFS traversal - visits nodes level by level - O(V + E)
    vector&lt;int&gt; bfsTraversal(int start) {
        vector&lt;int&gt; result;                        // Store traversal order
        vector&lt;bool&gt; visited(graph.size(), false); // Track visited nodes
        queue&lt;int&gt; q;                              // FIFO queue for BFS
        
        // Start with the initial node
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();  // Get front of queue
            q.pop();
            result.push_back(current);
            
            // Add all unvisited neighbors to queue
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;  // Mark as visited
                    q.push(neighbor);          // Add to queue
                }
            }
        }
        return result;
    }
    
    // Find shortest path using BFS
    vector<int> shortestPath(int start, int target) {
        vector<int> parent(graph.size(), -1);
        vector<bool> visited(graph.size(), false);
        queue<int> q;
        
        q.push(start);
        visited[start] = true;
        
        while (!q.empty()) {
            int current = q.front();
            q.pop();
            
            if (current == target) break;
            
            for (int neighbor : graph[current]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                    q.push(neighbor);
                }
            }
        }
        
        // Reconstruct path
        vector<int> path;
        for (int node = target; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        return path;
    }
};</pre>

    <h2 class="section-title" id="ch6-2">6.2 Depth-First Search (DFS)</h2>

    <p class="academic-text">DFS explores a graph by going as deep as possible along each branch before backtracking.
        It's like exploring a maze by always taking the first unexplored path you see.</p>

    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üï≥Ô∏è DFS Strategy</h3>
        <p class="academic-text"><strong>Depth-First Search</strong> explores as far as possible along each branch
            before backtracking.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Deep exploration:</strong> Follow paths to their end before trying
                alternatives</li>
            <li class="academic-text"><strong>Stack-based:</strong> Uses recursion or explicit stack (LIFO)</li>
            <li class="academic-text"><strong>Memory efficient:</strong> Only stores current path, not all discovered
                nodes</li>
        </ul>
    </div>

    <div
        style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>DFS vs BFS Comparison:</strong><br><br>
        <div class="mermaid">
            graph TD
            A[A] --- B[B]
            A --- C[C]
            B --- D[D]
            B --- E[E]
            C --- F[F]

            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">BFS order: A ‚Üí B,C
            ‚Üí D,E,F | DFS order: A ‚Üí B ‚Üí D ‚Üí E ‚Üí C ‚Üí F</p>
    </div>

    <pre class="code-block">// DFS Implementation
class DFS {
private:
    vector<vector<int>> graph;
    
    void dfsRecursive(int node, vector<bool>& visited, vector<int>& result) {
        visited[node] = true;
        result.push_back(node);
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                dfsRecursive(neighbor, visited, result);
            }
        }
    }
    
public:
    DFS(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    // Recursive DFS
    vector<int> dfsTraversal(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        dfsRecursive(start, visited, result);
        return result;
    }
    
    // Iterative DFS using stack
    vector<int> dfsIterative(int start) {
        vector<int> result;
        vector<bool> visited(graph.size(), false);
        stack<int> s;
        
        s.push(start);
        
        while (!s.empty()) {
            int current = s.top();
            s.pop();
            
            if (!visited[current]) {
                visited[current] = true;
                result.push_back(current);
                
                // Add neighbors to stack (reverse order for consistent traversal)
                for (auto it = graph[current].rbegin(); it != graph[current].rend(); ++it) {
                    if (!visited[*it]) {
                        s.push(*it);
                    }
                }
            }
        }
        return result;
    }
};</pre>

    <h2 class="section-title" id="ch6-3">6.3 Cycle Detection Using DFS</h2>

    <p class="academic-text">One of DFS's superpowers is detecting cycles in graphs. This is crucial for many
        applications like detecting deadlocks, finding dependencies, and validating DAGs.</p>

    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üîÑ Cycle Detection</h3>
        <p class="academic-text">DFS can detect cycles by tracking the recursion stack and looking for back edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Back edge:</strong> An edge to an ancestor in the DFS tree</li>
            <li class="academic-text"><strong>Three colors:</strong> White (unvisited), Gray (processing), Black
                (finished)</li>
            <li class="academic-text"><strong>Cycle found:</strong> When we encounter a gray node</li>
        </ul>
    </div>

    <pre class="code-block">// Cycle Detection
class CycleDetector {
private:
    vector<vector<int>> graph;
    enum Color { WHITE, GRAY, BLACK };
    
    bool hasCycleDFS(int node, vector<Color>& colors) {
        colors[node] = GRAY;
        
        for (int neighbor : graph[node]) {
            if (colors[neighbor] == GRAY) {
                return true; // Back edge found - cycle detected!
            }
            if (colors[neighbor] == WHITE && hasCycleDFS(neighbor, colors)) {
                return true;
            }
        }
        
        colors[node] = BLACK;
        return false;
    }
    
public:
    CycleDetector(int n) : graph(n) {}
    
    void addEdge(int u, int v) {
        graph[u].push_back(v); // directed edge
    }
    
    bool hasCycle() {
        vector<Color> colors(graph.size(), WHITE);
        
        for (int i = 0; i < graph.size(); i++) {
            if (colors[i] == WHITE) {
                if (hasCycleDFS(i, colors)) {
                    return true;
                }
            }
        }
        return false;
    }
};</pre>

    <h2 class="section-title" id="ch6-4">6.4 Applications in Social Networks and Web Crawling</h2>

    <p class="academic-text">BFS and DFS power many real-world applications. Let's see how they work in systems you use
        every day.</p>

    <p class="academic-text"><strong>Social Network Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Friend suggestions:</strong> BFS finds mutual friends at distance 2</li>
        <li class="academic-text"><strong>Influence analysis:</strong> DFS explores how information spreads</li>
        <li class="academic-text"><strong>Community detection:</strong> Connected components using DFS</li>
    </ul>

    <p class="academic-text"><strong>Web Crawling Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Search engines:</strong> BFS for broad web exploration</li>
        <li class="academic-text"><strong>Site mapping:</strong> DFS for deep site structure analysis</li>
        <li class="academic-text"><strong>Link validation:</strong> Cycle detection for broken link loops</li>
    </ul>

    <pre class="code-block">// Social Network Friend Suggestions
class SocialNetwork {
private:
    vector<vector<int>> friendships;
    
public:
    SocialNetwork(int users) : friendships(users) {}
    
    void addFriendship(int user1, int user2) {
        friendships[user1].push_back(user2);
        friendships[user2].push_back(user1);
    }
    
    // Find mutual friends (distance 2 connections)
    vector<int> suggestFriends(int user) {
        set<int> suggestions;
        set<int> directFriends(friendships[user].begin(), friendships[user].end());
        
        // BFS to distance 2
        for (int friend_id : friendships[user]) {
            for (int friend_of_friend : friendships[friend_id]) {
                // Suggest if not already friend and not self
                if (friend_of_friend != user && 
                    directFriends.find(friend_of_friend) == directFriends.end()) {
                    suggestions.insert(friend_of_friend);
                }
            }
        }
        
        return vector<int>(suggestions.begin(), suggestions.end());
    }
    
    // Find connected components (friend groups)
    vector<vector<int>> findCommunities() {
        vector<vector<int>> communities;
        vector<bool> visited(friendships.size(), false);
        
        for (int i = 0; i < friendships.size(); i++) {
            if (!visited[i]) {
                vector<int> community;
                dfsComponent(i, visited, community);
                communities.push_back(community);
            }
        }
        return communities;
    }
    
private:
    void dfsComponent(int user, vector<bool>& visited, vector<int>& component) {
        visited[user] = true;
        component.push_back(user);
        
        for (int friend_id : friendships[user]) {
            if (!visited[friend_id]) {
                dfsComponent(friend_id, visited, component);
            }
        }
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üöÄ Traversal Algorithm Summary</h3>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">BFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Shortest paths, level-order</li>
                    <li class="academic-text"><strong>Memory:</strong> Higher (stores all discovered)</li>
                </ul>
            </div>

            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">DFS Characteristics</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(V + E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for recursion</li>
                    <li class="academic-text"><strong>Best for:</strong> Cycles, components, paths</li>
                    <li class="academic-text"><strong>Memory:</strong> Lower (only current path)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 6 Complete!</h3>
        <p class="academic-text">You've mastered the fundamental graph traversal algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>BFS</strong> - level-by-level exploration for shortest paths</li>
            <li class="academic-text">‚úÖ <strong>DFS</strong> - deep exploration for cycles and components</li>
            <li class="academic-text">‚úÖ <strong>Cycle detection</strong> - using DFS with three-color approach</li>
            <li class="academic-text">‚úÖ <strong>Real applications</strong> - social networks and web crawling</li>
        </ul>

        <p class="academic-text">These traversal algorithms are the foundation for almost every graph algorithm you'll
            learn next. Understanding BFS and DFS deeply will make shortest path algorithms, minimum spanning trees, and
            network flow much easier to grasp!</p>
    </div>
</body>

</html>