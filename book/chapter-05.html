<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 5: Heaps and Priority Structures</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 5</div>
    <h1 class="chapter-title">Heaps and Priority Structures</h1>
    
    <div class="definition-box">
        "Heaps are the secret sauce behind priority queues, efficient sorting, and many graph algorithms like Dijkstra's shortest path!"
    </div>

    <p class="academic-text">Imagine you're managing a hospital emergency room where life-and-death decisions happen every second. You can't treat patients in the order they arrive - you must prioritize based on the severity of their condition. A heart attack patient takes precedence over a broken finger, regardless of who arrived first. This is exactly the problem that heaps solve with mathematical precision: maintaining dynamic priority order while enabling efficient insertion, removal, and access to the most important element.</p>
    
    <p class="academic-text">Heaps represent one of the most ingenious applications of tree structure, solving the fundamental challenge of priority management that appears throughout computer science. Unlike general trees that organize data hierarchically, or tries that optimize for string operations, heaps are laser-focused on one critical task: ensuring that the most important element is always instantly accessible at the root, while maintaining this property efficiently as elements are added and removed.</p>

    <p class="academic-text">The brilliance of heaps lies in their elegant balance between simplicity and power. By imposing a simple ordering constraint - parents must be greater than (or less than) their children - heaps create a structure that guarantees O(log n) insertion and removal while providing O(1) access to the priority element. This combination of properties makes heaps indispensable for algorithms that need to repeatedly process elements in priority order.</p>
    
    <p class="academic-text"><strong>Heaps are the invisible engines powering critical systems around you:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Operating systems:</strong> Every modern OS uses heap-based priority queues to schedule processes, ensuring critical system tasks get CPU time before less important applications</li>
        <li class="academic-text"><strong>Network infrastructure:</strong> Internet routers use heaps to prioritize packet transmission, ensuring video calls and emergency communications get priority over file downloads</li>
        <li class="academic-text"><strong>Graph algorithms:</strong> Dijkstra's shortest path algorithm relies on heaps to efficiently find optimal routes in GPS navigation and network routing protocols</li>
        <li class="academic-text"><strong>Event-driven systems:</strong> Simulation engines and game systems use heaps to process events in chronological order, maintaining causality in complex systems</li>
        <li class="academic-text"><strong>Data compression:</strong> Huffman coding algorithms use heaps to build optimal compression trees, reducing file sizes for everything from images to videos</li>
        <li class="academic-text"><strong>Database systems:</strong> Query optimizers use heaps to efficiently sort and merge large datasets, enabling fast database operations on millions of records</li>
    </ul>

    <h2 class="section-title" id="ch5-1">5.1 Heap Properties: Min-Heap and Max-Heap</h2>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üèÑ Heap Definition</h3>
        <p class="academic-text">A <strong>heap</strong> is a complete binary tree with the heap property: every parent node has a specific ordering relationship with its children.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Complete binary tree:</strong> All levels filled except possibly the last (filled left to right)</li>
            <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
            <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        </ul>
    </div>
    
    <p class="academic-text"><strong>Two types of heaps:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Min-heap:</strong> Parent ‚â§ children (smallest at top)</li>
        <li class="academic-text"><strong>Max-heap:</strong> Parent ‚â• children (largest at top)</li>
    </ul>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Min-Heap Example (Smallest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[1] --> B[3]
            A --> C[2]
            B --> D[7]
            B --> E[8]
            C --> F[5]
            C --> G[4]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ‚â§ Children: 1‚â§3,2 | 3‚â§7,8 | 2‚â§5,4</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A min-heap is a complete binary tree where every parent node has a value ‚â§ its children.
        </div>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Max-Heap Example (Largest at Top):</strong><br><br>
        <div class="mermaid">
        graph TD
            A[10] --> B[8]
            A --> C[9]
            B --> D[4]
            B --> E[7]
            C --> F[5]
            C --> G[6]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style D fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style E fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style F fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style G fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Parent ‚â• Children: 10‚â•8,9 | 8‚â•4,7 | 9‚â•5,6</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Classical Definition:</strong> A max-heap is a complete binary tree where every parent node has a value ‚â• its children.
        </div>
    </div>

    <p class="academic-text"><strong>Key Heap Properties:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Complete tree:</strong> All levels filled except possibly the last (filled left to right)</li>
        <li class="academic-text"><strong>Heap property:</strong> Parent-child ordering maintained throughout</li>
        <li class="academic-text"><strong>Root access:</strong> Min/max element always at the root</li>
        <li class="academic-text"><strong>Array representation:</strong> Can be stored efficiently in an array</li>
    </ul>

    <pre class="code-block">// Simple heap implementation using array
#include <iostream>
#include <vector>
using namespace std;

class MinHeap {
private:
    vector<int> heap;
    
    // Get parent, left child, right child indices
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    // Swap two elements
    void swap(int i, int j) {
        int temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
    
public:
    // Check if heap is empty
    bool isEmpty() {
        return heap.empty();
    }
    
    // Get the minimum element (root)
    int getMin() {
        if (isEmpty()) return -1;
        return heap[0];
    }
    
    // Get heap size
    int size() {
        return heap.size();
    }
    
    // Print heap as array
    void printHeap() {
        cout << "Heap: ";
        for (int val : heap) {
            cout << val << " ";
        }
        cout << endl;
    }
    
    // Build a sample min-heap
    static MinHeap* buildSampleHeap() {
        MinHeap* h = new MinHeap();
        vector<int> values = {3, 7, 1, 8, 2, 5, 4};
        
        for (int val : values) {
            h->insert(val);
        }
        return h;
    }
};</pre>

    <h2 class="section-title" id="ch5-2">5.2 Heap Operations: Insert, Extract, Heapify</h2>

    <p class="academic-text"><strong>Insert: Adding New Elements</strong></p>
    <p class="academic-text">To insert into a heap: add at the end, then "bubble up" until heap property is restored.</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Insert Process (Adding 1 to Min-Heap):</strong><br><br>
        <div class="mermaid">
        graph TD
            subgraph "Step 1: Add at end"
                A1[3] --> B1[7]
                A1 --> C1[5]
                B1 --> D1[8]
                B1 --> E1[1]
                
                style E1 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 2: Bubble up"
                A2[3] --> B2[1]
                A2 --> C2[5]
                B2 --> D2[8]
                B2 --> E2[7]
                
                style B2 fill:#ffeb3b,stroke:#333,stroke-width:3px
            end
            
            subgraph "Step 3: Final result"
                A3[1] --> B3[3]
                A3 --> C3[5]
                B3 --> D3[8]
                B3 --> E3[7]
                
                style A3 fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            end
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">1 bubbles up: 1<7 (swap) ‚Üí 1<3 (swap) ‚Üí Done!</p>
    </div>

    <p class="academic-text"><strong>Extract: Removing the Root</strong></p>
    <p class="academic-text">To extract from a heap: remove root, move last element to root, then "bubble down".</p>

    <pre class="code-block">// Heap operations implementation
class MinHeap {
    // ... previous code ...
    
    // Bubble up to maintain heap property after insert
    void bubbleUp(int index) {
        while (index > 0 && heap[parent(index)] > heap[index]) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    // Bubble down to maintain heap property after extract
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        // Find the smallest among parent and children
        if (left < heap.size() && heap[left] < heap[minIndex]) {
            minIndex = left;
        }
        if (right < heap.size() && heap[right] < heap[minIndex]) {
            minIndex = right;
        }
        
        // If parent is not the smallest, swap and continue
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Insert a new element
    void insert(int value) {
        heap.push_back(value);
        bubbleUp(heap.size() - 1);
    }
    
    // Extract the minimum element
    int extractMin() {
        if (isEmpty()) return -1;
        
        int min = heap[0];
        
        // Move last element to root and remove last
        heap[0] = heap[heap.size() - 1];
        heap.pop_back();
        
        // Restore heap property
        if (!isEmpty()) {
            bubbleDown(0);
        }
        
        return min;
    }
    
    // Build heap from array (heapify)
    void buildHeap(vector<int> array) {
        heap = array;
        
        // Start from last non-leaf node and bubble down
        for (int i = (heap.size() / 2) - 1; i >= 0; i--) {
            bubbleDown(i);
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-3">5.3 Priority Queues and Applications</h2>

    <p class="academic-text"><strong>Priority Queue: The Heap's Superpower</strong></p>
    <p class="academic-text">A priority queue lets you always get the most important item first. Heaps make this super efficient!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Hospital Emergency Room Example:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Critical: 1] --> B[Urgent: 3]
            A --> C[Urgent: 2]
            B --> D[Standard: 7]
            B --> E[Standard: 5]
            C --> F[Standard: 4]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:3px
            style B fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style E fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style F fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Lower numbers = higher priority. Critical patient (1) treated first!</p>
    </div>

    <p class="academic-text"><strong>Real-World Priority Queue Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Operating Systems:</strong> Process scheduling by priority</li>
        <li class="academic-text"><strong>Network Routing:</strong> Packet prioritization</li>
        <li class="academic-text"><strong>Game AI:</strong> Action selection by importance</li>
        <li class="academic-text"><strong>Graph Algorithms:</strong> Dijkstra's shortest path</li>
        <li class="academic-text"><strong>Event Simulation:</strong> Process events by time</li>
    </ul>

    <pre class="code-block">// Priority Queue using heap
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Task with priority
struct Task {
    string description;
    int priority;
    
    Task(string desc, int prio) : description(desc), priority(prio) {}
};

class PriorityQueue {
private:
    vector<Task> tasks;
    
    int parent(int i) { return (i - 1) / 2; }
    int leftChild(int i) { return 2 * i + 1; }
    int rightChild(int i) { return 2 * i + 2; }
    
    void swap(int i, int j) {
        Task temp = tasks[i];
        tasks[i] = tasks[j];
        tasks[j] = temp;
    }
    
    void bubbleUp(int index) {
        while (index > 0 && tasks[parent(index)].priority > tasks[index].priority) {
            swap(index, parent(index));
            index = parent(index);
        }
    }
    
    void bubbleDown(int index) {
        int minIndex = index;
        int left = leftChild(index);
        int right = rightChild(index);
        
        if (left < tasks.size() && tasks[left].priority < tasks[minIndex].priority) {
            minIndex = left;
        }
        if (right < tasks.size() && tasks[right].priority < tasks[minIndex].priority) {
            minIndex = right;
        }
        
        if (index != minIndex) {
            swap(index, minIndex);
            bubbleDown(minIndex);
        }
    }
    
public:
    // Add task with priority
    void addTask(string description, int priority) {
        tasks.push_back(Task(description, priority));
        bubbleUp(tasks.size() - 1);
    }
    
    // Get highest priority task
    Task getNextTask() {
        if (tasks.empty()) return Task("No tasks", -1);
        
        Task nextTask = tasks[0];
        
        tasks[0] = tasks[tasks.size() - 1];
        tasks.pop_back();
        
        if (!tasks.empty()) {
            bubbleDown(0);
        }
        
        return nextTask;
    }
    
    bool isEmpty() {
        return tasks.empty();
    }
    
    // Demo function
    static void demo() {
        PriorityQueue pq;
        
        pq.addTask("Fix critical bug", 1);
        pq.addTask("Write documentation", 5);
        pq.addTask("Review code", 3);
        pq.addTask("Deploy to production", 2);
        pq.addTask("Update tests", 4);
        
        cout << "Tasks in priority order:" << endl;
        while (!pq.isEmpty()) {
            Task task = pq.getNextTask();
            cout << "Priority " << task.priority << ": " << task.description << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch5-4">5.4 Heap Sort and Graph Algorithm Preparation</h2>

    <p class="academic-text"><strong>Heap Sort: Sorting with Heaps</strong></p>
    <p class="academic-text">Heap sort uses a heap to sort efficiently: build a max-heap, then repeatedly extract the maximum!</p>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Heap Sort Process:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Unsorted Array] --> B[Build Max-Heap]
            B --> C[Extract Max]
            C --> D[Place at End]
            D --> E[Heapify Remaining]
            E --> F{More Elements?}
            F -->|Yes| C
            F -->|No| G[Sorted Array]
            
            style A fill:#ffebee,stroke:#f44336,stroke-width:2px
            style G fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style C fill:#fff3e0,stroke:#ff9800,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">O(n log n) time complexity - efficient and in-place!</p>
    </div>

    <p class="academic-text"><strong>Heaps in Graph Algorithms</strong></p>
    <p class="academic-text">Heaps are crucial for many graph algorithms you'll learn next:</p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> Find shortest paths using min-heap</li>
        <li class="academic-text"><strong>Prim's Algorithm:</strong> Find minimum spanning tree</li>
        <li class="academic-text"><strong>A* Search:</strong> Pathfinding with priority queue</li>
        <li class="academic-text"><strong>Huffman Coding:</strong> Data compression using heaps</li>
    </ul>

    <pre class="code-block">// Heap Sort implementation
#include <iostream>
#include <vector>
using namespace std;

class HeapSort {
private:
    static void heapify(vector<int>& arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        // Find largest among root and children
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // If largest is not root, swap and continue heapifying
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapify(arr, n, largest);
        }
    }
    
public:
    static void sort(vector<int>& arr) {
        int n = arr.size();
        
        // Step 1: Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Step 2: Extract elements one by one
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            swap(arr[0], arr[i]);
            
            // Heapify the reduced heap
            heapify(arr, i, 0);
        }
    }
    
    // Demo function
    static void demo() {
        vector<int> arr = {64, 34, 25, 12, 22, 11, 90};
        
        cout << "Original array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
        
        sort(arr);
        
        cout << "Sorted array: ";
        for (int val : arr) cout << val << " ";
        cout << endl;
    }
};

// Graph algorithm preparation - Dijkstra's preview
class GraphAlgorithmPrep {
public:
    // Simple structure for graph edges with weights
    struct Edge {
        int to;
        int weight;
        
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    // Distance-node pair for priority queue
    struct DistanceNode {
        int distance;
        int node;
        
        DistanceNode(int d, int n) : distance(d), node(n) {}
        
        // For min-heap comparison
        bool operator>(const DistanceNode& other) const {
            return distance > other.distance;
        }
    };
    
    static void dijkstraPreview() {
        cout << "Coming up in Part II:" << endl;
        cout << "- Dijkstra's algorithm will use min-heap for shortest paths" << endl;
        cout << "- Prim's algorithm will use min-heap for minimum spanning trees" << endl;
        cout << "- Priority queues will be essential for efficient graph traversal" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">üèîÔ∏è Heap Performance Summary</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Time Complexity</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Insert:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Extract:</strong> O(log n)</li>
                    <li class="academic-text"><strong>Peek:</strong> O(1)</li>
                    <li class="academic-text"><strong>Build heap:</strong> O(n)</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Space & Benefits</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Space:</strong> O(n)</li>
                    <li class="academic-text"><strong>Array-based:</strong> Cache-friendly</li>
                    <li class="academic-text"><strong>In-place:</strong> No extra pointers</li>
                    <li class="academic-text"><strong>Stable:</strong> Predictable performance</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Part I Complete!</h3>
        <p class="academic-text">Congratulations! You've mastered the foundations of graph thinking:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Chapter 1:</strong> Basic graphs and representations</li>
            <li class="academic-text">‚úÖ <strong>Chapter 2:</strong> Graph properties and special types</li>
            <li class="academic-text">‚úÖ <strong>Chapter 3:</strong> Trees and hierarchical structures</li>
            <li class="academic-text">‚úÖ <strong>Chapter 4:</strong> Tries and string processing</li>
            <li class="academic-text">‚úÖ <strong>Chapter 5:</strong> Heaps and priority structures</li>
        </ul>
        
        <p class="academic-text"><strong>You're now ready for Part II: Core Algorithms!</strong> You have all the data structures needed to understand graph traversal, shortest paths, and spanning trees. The real adventure begins!</p>
    </div>
</body>
</html>
