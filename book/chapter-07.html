<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 7: Shortest Path Algorithms</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 7</div>
    <h1 class="chapter-title">Shortest Path Algorithms</h1>
    
    <div class="definition-box">
        "Finding the shortest path is one of the most fundamental problems in computer science - from GPS navigation to network routing to game AI."
    </div>

    <p class="academic-text">Every time you navigate with GPS, send a message across the internet, or watch an AI character find its way through a game world, you're witnessing the power of shortest path algorithms in action. These algorithms represent some of the most practically important and mathematically elegant solutions in computer science, solving the fundamental optimization problem: given multiple possible routes between two points, which one is truly optimal?</p>
    
    <p class="academic-text">Shortest path algorithms transcend simple navigation to become the foundation for optimization across countless domains. They power the routing protocols that deliver your emails across global networks, the recommendation algorithms that suggest connections on social media, the resource allocation systems that optimize supply chains, and the AI pathfinding that makes video game characters appear intelligent. Understanding these algorithms gives you insight into how modern systems solve complex optimization problems efficiently.</p>

    <p class="academic-text">The mathematical beauty of shortest path algorithms lies in how they transform complex optimization problems into systematic graph exploration. By carefully maintaining and updating distance estimates while exploring the graph, these algorithms guarantee optimal solutions while remaining computationally efficient. Each algorithm represents a different approach to the same fundamental challenge, optimized for different constraints and use cases.</p>
    
    <p class="academic-text"><strong>The four pillars of shortest path computation, each solving different optimization challenges:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Dijkstra's Algorithm:</strong> The gold standard for single-source shortest paths in graphs with non-negative weights - powers GPS navigation and network routing protocols</li>
        <li class="academic-text"><strong>Bellman-Ford Algorithm:</strong> Handles negative edge weights and detects negative cycles - essential for currency arbitrage detection and network analysis with costs</li>
        <li class="academic-text"><strong>A* Algorithm:</strong> Combines Dijkstra's optimality with heuristic guidance for dramatically faster pathfinding - the backbone of game AI and robotics navigation</li>
        <li class="academic-text"><strong>Floyd-Warshall Algorithm:</strong> Computes shortest paths between all pairs of vertices - crucial for network analysis and transportation planning</li>
    </ul>

    <h2 class="section-title" id="ch7-1">7.1 Dijkstra's Algorithm</h2>
    
    <p class="academic-text">Dijkstra's algorithm is the gold standard for finding shortest paths in weighted graphs with non-negative edge weights. It's the algorithm behind GPS navigation systems and network routing protocols.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üõ£Ô∏è Dijkstra's Strategy</h3>
        <p class="academic-text"><strong>Dijkstra's Algorithm</strong> finds shortest paths by always exploring the closest unvisited node first.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Greedy approach:</strong> Always pick the node with minimum distance</li>
            <li class="academic-text"><strong>Priority queue:</strong> Uses min-heap to efficiently get next closest node</li>
            <li class="academic-text"><strong>Relaxation:</strong> Updates distances when shorter paths are found</li>
            <li class="academic-text"><strong>Optimal substructure:</strong> Shortest path contains shortest subpaths</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Dijkstra's Algorithm Example (Finding shortest path from A):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A:0] -->|4| B[B:4]
            A -->|2| C[C:2]
            B -->|3| D[D:7]
            C -->|1| D[D:3]
            C -->|5| E[E:7]
            D -->|2| E[E:5]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style D fill:#ffeb3b,stroke:#333,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Numbers show shortest distances from A. Path A‚ÜíC‚ÜíD gives distance 3, better than A‚ÜíB‚ÜíD (distance 7)</p>
    </div>

    <pre class="code-block">// Dijkstra's Algorithm Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;limits&gt;
using namespace std;

class DijkstraGraph {
private:
    // Edge structure for weighted directed graph
    struct Edge {
        int to;      // Destination node
        int weight;  // Edge weight/cost
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector&lt;vector&lt;Edge&gt;&gt; graph;  // Adjacency list with weights
    
public:
    DijkstraGraph(int n) : graph(n) {}
    
    // Add directed weighted edge
    void addEdge(int from, int to, int weight) {
        graph[from].push_back(Edge(to, weight));
    }
    
    // Dijkstra's algorithm - finds shortest paths from start to all nodes - O((V+E)logV)
    pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt; dijkstra(int start) {
        int n = graph.size();
        vector&lt;int&gt; dist(n, INT_MAX);    // Distance from start to each node
        vector&lt;int&gt; parent(n, -1);       // Parent for path reconstruction
        
        // Min-heap priority queue: (distance, node) - processes closest nodes first
        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;
        
        dist[start] = 0;
        pq.push({0, start});
        
        while (!pq.empty()) {
            int currentDist = pq.top().first;
            int currentNode = pq.top().second;
            pq.pop();
            
            // Skip if we've already found a better path
            if (currentDist > dist[currentNode]) continue;
            
            // Explore all neighbors
            for (const Edge& edge : graph[currentNode]) {
                int newDist = dist[currentNode] + edge.weight;
                
                // Relaxation: update if we found a shorter path
                if (newDist < dist[edge.to]) {
                    dist[edge.to] = newDist;
                    parent[edge.to] = currentNode;
                    pq.push({newDist, edge.to});
                }
            }
        }
        
        return {dist, parent};
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int start, int end, const vector<int>& parent) {
        vector<int> path;
        for (int node = end; node != -1; node = parent[node]) {
            path.push_back(node);
        }
        reverse(path.begin(), path.end());
        
        // Check if path exists
        if (path[0] != start) return {};
        return path;
    }
    
    // Demo function
    static void demo() {
        DijkstraGraph g(5);
        g.addEdge(0, 1, 4);  // A -> B: 4
        g.addEdge(0, 2, 2);  // A -> C: 2
        g.addEdge(1, 3, 3);  // B -> D: 3
        g.addEdge(2, 3, 1);  // C -> D: 1
        g.addEdge(2, 4, 5);  // C -> E: 5
        g.addEdge(3, 4, 2);  // D -> E: 2
        
        auto [distances, parents] = g.dijkstra(0);
        
        cout << "Shortest distances from A:" << endl;
        vector<char> labels = {'A', 'B', 'C', 'D', 'E'};
        for (int i = 0; i < 5; i++) {
            cout << "To " << labels[i] << ": " << distances[i] << endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-2">7.2 Bellman-Ford Algorithm</h2>
    
    <p class="academic-text">While Dijkstra's algorithm is fast, it can't handle negative edge weights. Bellman-Ford algorithm is slower but more versatile - it can detect negative cycles and handle negative weights.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">‚öñÔ∏è Bellman-Ford Strategy</h3>
        <p class="academic-text"><strong>Bellman-Ford Algorithm</strong> finds shortest paths by relaxing all edges repeatedly.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Edge relaxation:</strong> Try to improve distances using each edge</li>
            <li class="academic-text"><strong>V-1 iterations:</strong> Guarantees finding shortest paths in V-1 steps</li>
            <li class="academic-text"><strong>Negative cycle detection:</strong> Extra iteration detects negative cycles</li>
            <li class="academic-text"><strong>Handles negative weights:</strong> Works where Dijkstra fails</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Bellman-Ford vs Dijkstra Comparison:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] -->|2| B[B]
            A -->|-1| C[C]
            C -->|3| B
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#ffeb3b,stroke:#333,stroke-width:2px
            style C fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Negative edge A‚ÜíC: -1. Dijkstra fails, but Bellman-Ford finds A‚ÜíC‚ÜíB = 2 < A‚ÜíB = 2</p>
    </div>

    <pre class="code-block">// Bellman-Ford Algorithm Implementation
class BellmanFordGraph {
private:
    struct Edge {
        int from, to, weight;
        Edge(int f, int t, int w) : from(f), to(t), weight(w) {}
    };
    
    vector<Edge> edges;
    int numVertices;
    
public:
    BellmanFordGraph(int n) : numVertices(n) {}
    
    void addEdge(int from, int to, int weight) {
        edges.push_back(Edge(from, to, weight));
    }
    
    // Bellman-Ford shortest path algorithm
    pair<vector<int>, bool> bellmanFord(int start) {
        vector<int> dist(numVertices, INT_MAX);
        dist[start] = 0;
        
        // Relax all edges V-1 times
        for (int i = 0; i < numVertices - 1; i++) {
            for (const Edge& edge : edges) {
                if (dist[edge.from] != INT_MAX && 
                    dist[edge.from] + edge.weight < dist[edge.to]) {
                    dist[edge.to] = dist[edge.from] + edge.weight;
                }
            }
        }
        
        // Check for negative cycles
        bool hasNegativeCycle = false;
        for (const Edge& edge : edges) {
            if (dist[edge.from] != INT_MAX && 
                dist[edge.from] + edge.weight < dist[edge.to]) {
                hasNegativeCycle = true;
                break;
            }
        }
        
        return {dist, hasNegativeCycle};
    }
    
    // Demo function
    static void demo() {
        BellmanFordGraph g(4);
        g.addEdge(0, 1, 4);   // A -> B: 4
        g.addEdge(0, 2, -2);  // A -> C: -2 (negative!)
        g.addEdge(2, 1, 3);   // C -> B: 3
        g.addEdge(1, 3, 2);   // B -> D: 2
        g.addEdge(2, 3, 4);   // C -> D: 4
        
        auto [distances, hasNegCycle] = g.bellmanFord(0);
        
        if (hasNegCycle) {
            cout << "Negative cycle detected!" << endl;
        } else {
            cout << "Shortest distances from A (with negative edges):" << endl;
            vector<char> labels = {'A', 'B', 'C', 'D'};
            for (int i = 0; i < 4; i++) {
                cout << "To " << labels[i] << ": " << distances[i] << endl;
            }
        }
    }
};</pre>

    <h2 class="section-title" id="ch7-3">7.3 A* Algorithm with Heuristics</h2>
    
    <p class="academic-text">A* (A-star) is Dijkstra's algorithm enhanced with heuristics. It's the go-to algorithm for pathfinding in games, robotics, and any scenario where you know the target location.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üéØ A* Strategy</h3>
        <p class="academic-text"><strong>A* Algorithm</strong> combines actual distance with estimated distance to goal.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>f(n) = g(n) + h(n):</strong> Total cost = actual cost + heuristic estimate</li>
            <li class="academic-text"><strong>Admissible heuristic:</strong> Never overestimates the actual cost</li>
            <li class="academic-text"><strong>Guided search:</strong> Explores toward the goal more efficiently</li>
            <li class="academic-text"><strong>Optimal:</strong> Finds shortest path if heuristic is admissible</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>A* Pathfinding Example (Grid with obstacles):</strong><br><br>
        <div class="mermaid">
        graph TD
            S[Start] --> A[A]
            S --> B[B]
            A --> C[C]
            B --> D[D]
            C --> G[Goal]
            D --> G
            
            style S fill:#e8f5e8,stroke:#4caf50,stroke-width:3px
            style G fill:#ffeb3b,stroke:#333,stroke-width:3px
            style A fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">A* uses heuristic (like Manhattan distance) to guide search toward goal</p>
    </div>

    <pre class="code-block">// A* Algorithm Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;unordered_map&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;
using namespace std;

class AStarGraph {
private:
    struct Node {
        int id;
        double x, y;  // Coordinates for heuristic
        Node(int i, double px, double py) : id(i), x(px), y(py) {}
    };
    
    struct AStarNode {
        int id;
        double g, h, f;  // g: actual cost, h: heuristic, f: total
        int parent;
        
        AStarNode(int i, double gc, double hc, int p) 
            : id(i), g(gc), h(hc), f(gc + hc), parent(p) {}
        
        bool operator>(const AStarNode& other) const {
            return f > other.f;
        }
    };
    
    vector<Node> nodes;
    vector<vector<pair<int, double>>> graph;
    
    // Manhattan distance heuristic
    double heuristic(int from, int to) {
        return abs(nodes[from].x - nodes[to].x) + abs(nodes[from].y - nodes[to].y);
    }
    
public:
    AStarGraph(int n) : graph(n) {}
    
    void addNode(int id, double x, double y) {
        nodes.push_back(Node(id, x, y));
    }
    
    void addEdge(int from, int to, double weight) {
        graph[from].push_back({to, weight});
    }
    
    // A* pathfinding algorithm
    vector<int> aStar(int start, int goal) {
        priority_queue<AStarNode, vector<AStarNode>, greater<AStarNode>> openSet;
        unordered_set<int> closedSet;
        unordered_map<int, double> gScore;
        unordered_map<int, int> parent;
        
        gScore[start] = 0;
        openSet.push(AStarNode(start, 0, heuristic(start, goal), -1));
        
        while (!openSet.empty()) {
            AStarNode current = openSet.top();
            openSet.pop();
            
            if (current.id == goal) {
                // Reconstruct path
                vector<int> path;
                for (int node = goal; node != -1; node = parent[node]) {
                    path.push_back(node);
                }
                reverse(path.begin(), path.end());
                return path;
            }
            
            closedSet.insert(current.id);
            
            for (auto& [neighbor, weight] : graph[current.id]) {
                if (closedSet.count(neighbor)) continue;
                
                double tentativeG = gScore[current.id] + weight;
                
                if (gScore.find(neighbor) == gScore.end() || tentativeG < gScore[neighbor]) {
                    gScore[neighbor] = tentativeG;
                    parent[neighbor] = current.id;
                    openSet.push(AStarNode(neighbor, tentativeG, heuristic(neighbor, goal), current.id));
                }
            }
        }
        
        return {}; // No path found
    }
    
    // Demo function for grid pathfinding
    static void demo() {
        AStarGraph g(6);
        
        // Add nodes with coordinates
        g.addNode(0, 0, 0);  // Start
        g.addNode(1, 1, 0);
        g.addNode(2, 0, 1);
        g.addNode(3, 1, 1);
        g.addNode(4, 2, 1);
        g.addNode(5, 2, 2);  // Goal
        
        // Add edges (grid connections)
        g.addEdge(0, 1, 1);  // Horizontal/vertical moves cost 1
        g.addEdge(0, 2, 1);
        g.addEdge(1, 3, 1);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 4, 1);
        g.addEdge(4, 5, 1);
        
        vector<int> path = g.aStar(0, 5);
        
        cout << "A* path from start to goal: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <h2 class="section-title" id="ch7-4">7.4 Floyd-Warshall All-Pairs Shortest Path</h2>
    
    <p class="academic-text">Sometimes you need shortest paths between ALL pairs of vertices, not just from one source. Floyd-Warshall algorithm efficiently computes the shortest path matrix for the entire graph.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üåê Floyd-Warshall Strategy</h3>
        <p class="academic-text"><strong>Floyd-Warshall Algorithm</strong> finds shortest paths between all pairs of vertices.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Dynamic programming:</strong> Builds solution by considering intermediate vertices</li>
            <li class="academic-text"><strong>All-pairs:</strong> Computes shortest paths between every pair of vertices</li>
            <li class="academic-text"><strong>Handles negatives:</strong> Works with negative weights (but not negative cycles)</li>
            <li class="academic-text"><strong>Simple implementation:</strong> Three nested loops, easy to understand</li>
        </ul>
    </div>

    <pre class="code-block">// Floyd-Warshall Algorithm Implementation
class FloydWarshallGraph {
private:
    vector<vector<int>> dist;
    vector<vector<int>> next;
    int n;
    
public:
    FloydWarshallGraph(int vertices) : n(vertices) {
        dist.assign(n, vector<int>(n, INT_MAX));
        next.assign(n, vector<int>(n, -1));
        
        // Initialize diagonal to 0
        for (int i = 0; i < n; i++) {
            dist[i][i] = 0;
        }
    }
    
    void addEdge(int from, int to, int weight) {
        dist[from][to] = weight;
        next[from][to] = to;
    }
    
    // Floyd-Warshall all-pairs shortest path
    void floydWarshall() {
        // Try each vertex as intermediate
        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                            next[i][j] = next[i][k];
                        }
                    }
                }
            }
        }
    }
    
    // Get shortest distance between two vertices
    int getDistance(int from, int to) {
        return dist[from][to];
    }
    
    // Reconstruct shortest path
    vector<int> getPath(int from, int to) {
        if (next[from][to] == -1) return {};
        
        vector<int> path;
        path.push_back(from);
        
        while (from != to) {
            from = next[from][to];
            path.push_back(from);
        }
        
        return path;
    }
    
    // Print distance matrix
    void printDistanceMatrix() {
        cout << "All-pairs shortest distances:" << endl;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][j] == INT_MAX) {
                    cout << "‚àû ";
                } else {
                    cout << dist[i][j] << " ";
                }
            }
            cout << endl;
        }
    }
    
    // Demo function
    static void demo() {
        FloydWarshallGraph g(4);
        
        g.addEdge(0, 1, 3);
        g.addEdge(0, 3, 7);
        g.addEdge(1, 0, 8);
        g.addEdge(1, 2, 2);
        g.addEdge(2, 0, 5);
        g.addEdge(2, 3, 1);
        g.addEdge(3, 0, 2);
        
        g.floydWarshall();
        g.printDistanceMatrix();
        
        // Example path
        vector<int> path = g.getPath(1, 3);
        cout << "Path from 1 to 3: ";
        for (int node : path) {
            cout << node << " ";
        }
        cout << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">‚ö° Shortest Path Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Single-Source Algorithms</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Dijkstra:</strong> O((V+E) log V), no negative weights</li>
                    <li class="academic-text"><strong>Bellman-Ford:</strong> O(VE), handles negative weights</li>
                    <li class="academic-text"><strong>A*:</strong> O(b^d), guided by heuristics</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">All-Pairs Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Floyd-Warshall:</strong> O(V¬≥), all pairs</li>
                    <li class="academic-text"><strong>Dense graphs:</strong> More efficient than V √ó Dijkstra</li>
                    <li class="academic-text"><strong>Simple code:</strong> Easy to implement and understand</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">Algorithm Selection Guide</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>GPS Navigation:</strong> A* with Euclidean distance heuristic</li>
                <li class="academic-text"><strong>Network Routing:</strong> Dijkstra for positive weights, Bellman-Ford for policy routing</li>
                <li class="academic-text"><strong>Game AI:</strong> A* for pathfinding with obstacles</li>
                <li class="academic-text"><strong>Social Networks:</strong> Floyd-Warshall for analyzing all relationships</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 7 Complete!</h3>
        <p class="academic-text">You've mastered the essential shortest path algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Dijkstra's Algorithm</strong> - the gold standard for non-negative weights</li>
            <li class="academic-text">‚úÖ <strong>Bellman-Ford Algorithm</strong> - handles negative weights and cycle detection</li>
            <li class="academic-text">‚úÖ <strong>A* Algorithm</strong> - heuristic-guided pathfinding for games and robotics</li>
            <li class="academic-text">‚úÖ <strong>Floyd-Warshall Algorithm</strong> - all-pairs shortest paths analysis</li>
        </ul>
        
        <p class="academic-text">These algorithms power everything from GPS navigation to internet routing to game AI. You now understand the core techniques that make modern connected systems possible. Next up: spanning tree algorithms that find the most efficient ways to connect networks!</p>
    </div>
</body>
</html>
