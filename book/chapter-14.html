<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 14: Pattern Recognition in Graphs</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 14</div>
    <h1 class="chapter-title">Pattern Recognition in Graphs</h1>
    
    <div class="definition-box">
        "Finding patterns in graphs reveals hidden structures - from tight-knit communities to influential clusters, these patterns unlock insights about complex networks."
    </div>

    <p class="academic-text">Pattern recognition in graphs represents one of the most powerful and practically important applications of graph theory, transforming vast networks of raw connections into meaningful insights about structure, behavior, and hidden relationships. While individual nodes and edges tell us about local connections, patterns reveal the global organization, community structure, and emergent properties that make complex networks truly fascinating and useful for understanding real-world systems.</p>
    
    <p class="academic-text">The ability to recognize patterns in graphs has revolutionized fields from social media analysis to drug discovery, from fraud detection to recommendation systems. These patterns - cliques, communities, clusters, and structural motifs - represent the fundamental building blocks of complex networks, revealing how systems self-organize, how information flows, and how influence spreads. Understanding these patterns gives you the tools to extract actionable intelligence from any networked system.</p>

    <p class="academic-text">Pattern recognition algorithms also represent some of the most computationally challenging problems in computer science, often requiring sophisticated approximation algorithms and heuristics to handle real-world networks with millions or billions of connections. The techniques we'll explore showcase how theoretical computer science meets practical data analysis to solve problems that would be impossible to tackle manually.</p>
    
    <p class="academic-text"><strong>Pattern recognition unlocks hidden insights across diverse domains:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Social media intelligence:</strong> Platforms like Facebook and Twitter use pattern recognition to identify tight-knit friend groups, detect echo chambers, and understand how information spreads through social networks</li>
        <li class="academic-text"><strong>Biological discovery:</strong> Researchers use graph patterns to discover protein complexes, identify gene regulatory modules, and understand cellular pathways that lead to new drug targets and treatments</li>
        <li class="academic-text"><strong>Business analytics:</strong> Companies use network patterns to segment customers, identify influential users, track viral marketing campaigns, and optimize product recommendations</li>
        <li class="academic-text"><strong>Security and fraud prevention:</strong> Financial institutions and security agencies use pattern recognition to detect money laundering rings, identify terrorist networks, and spot coordinated cyber attacks</li>
        <li class="academic-text"><strong>Scientific collaboration:</strong> Academic institutions analyze collaboration networks to understand research communities, identify emerging fields, and optimize funding allocation</li>
        <li class="academic-text"><strong>Urban planning:</strong> City planners use transportation and communication network patterns to optimize infrastructure, understand traffic flows, and improve public services</li>
    </ul>
    
    <p class="academic-text">These pattern recognition techniques transform raw network data into strategic intelligence, enabling data-driven decisions that would be impossible without understanding the underlying graph structure.</p>

    <h2 class="section-title" id="ch14-1">14.1 Cliques and Complete Subgraphs</h2>
    
    <p class="academic-text">A <strong>clique</strong> is a subset of vertices where every pair is connected - everyone knows everyone! Cliques represent the tightest possible groups in a network and are fundamental to understanding network cohesion.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üë• Clique Definitions</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Clique:</strong> A complete subgraph where all vertices are pairwise adjacent</li>
            <li class="academic-text"><strong>Maximal clique:</strong> Cannot be extended by adding another vertex</li>
            <li class="academic-text"><strong>Maximum clique:</strong> Largest clique in the graph (by vertex count)</li>
            <li class="academic-text"><strong>Clique number œâ(G):</strong> Size of the maximum clique</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Clique Example (Friend Groups):</strong><br><br>
        <div class="mermaid">
        graph LR
            A[Alice] --- B[Bob]
            A --- C[Carol]
            B --- C
            A --- D[Dave]
            B --- D
            C --- D
            D --- E[Eve]
            E --- F[Frank]
            
            style A fill:#ff6b6b,stroke:#333,stroke-width:3px
            style B fill:#ff6b6b,stroke:#333,stroke-width:3px
            style C fill:#ff6b6b,stroke:#333,stroke-width:3px
            style D fill:#ff6b6b,stroke:#333,stroke-width:3px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Red nodes form a 4-clique: {Alice, Bob, Carol, Dave} - everyone is friends with everyone!</p>
        
        <div class="definition-box" style="margin-top: 15px;">
            <strong>Why cliques matter:</strong> In social networks, cliques represent tight-knit friend groups. In biology, they represent protein complexes. In collaboration networks, they show research teams.
        </div>
    </div>

    <p class="academic-text"><strong>Finding Cliques: The Challenge</strong></p>
    <p class="academic-text">Finding the maximum clique is NP-complete - one of the hardest problems in computer science! However, we can find all maximal cliques efficiently using the Bron-Kerbosch algorithm.</p>
    
    <pre class="code-block">// Clique Detection using Bron-Kerbosch Algorithm
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>
using namespace std;

class CliqueFinder {
private:
    int V;
    vector<vector<int>> adj;
    vector<vector<int>> allCliques;
    
    void bronKerbosch(unordered_set<int> R,
                      unordered_set<int> P,
                      unordered_set<int> X) {
        if (P.empty() && X.empty()) {
            vector<int> clique(R.begin(), R.end());
            allCliques.push_back(clique);
            return;
        }
        
        unordered_set<int> candidates = P;
        for (int v : candidates) {
            unordered_set<int> neighbors;
            for (int u : adj[v]) neighbors.insert(u);
            
            unordered_set<int> newR = R;
            newR.insert(v);
            
            unordered_set<int> newP, newX;
            for (int u : P) {
                if (neighbors.count(u)) newP.insert(u);
            }
            for (int u : X) {
                if (neighbors.count(u)) newX.insert(u);
            }
            
            bronKerbosch(newR, newP, newX);
            P.erase(v);
            X.insert(v);
        }
    }
    
public:
    CliqueFinder(int vertices) : V(vertices) {
        adj.resize(V);
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    vector<vector<int>> findAllMaximalCliques() {
        allCliques.clear();
        unordered_set<int> R, P, X;
        for (int i = 0; i < V; i++) P.insert(i);
        bronKerbosch(R, P, X);
        return allCliques;
    }
    
    vector<int> findMaximumClique() {
        auto cliques = findAllMaximalCliques();
        vector<int> maxClique;
        for (const auto& clique : cliques) {
            if (clique.size() > maxClique.size()) {
                maxClique = clique;
            }
        }
        return maxClique;
    }
};</pre>

    <p class="academic-text"><strong>Applications of Clique Detection:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Social networks:</strong> Find tight-knit friend groups</li>
        <li class="academic-text"><strong>Bioinformatics:</strong> Discover protein complexes</li>
        <li class="academic-text"><strong>Collaboration networks:</strong> Identify research teams</li>
        <li class="academic-text"><strong>Fraud detection:</strong> Detect collusion rings</li>
    </ul>

    <h2 class="section-title" id="ch14-2">14.2 Community Detection Algorithms</h2>

    <p class="academic-text">While cliques are perfectly connected, <strong>communities</strong> are more loosely defined groups with more internal connections than external ones. Community detection reveals the modular structure of networks.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">üèòÔ∏è Community Structure</h3>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Community:</strong> Group of nodes with dense internal connections</li>
            <li class="academic-text"><strong>Modularity:</strong> Measure of community quality</li>
            <li class="academic-text"><strong>Overlapping communities:</strong> Nodes can belong to multiple groups</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Community Structure:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] --- B[B]
            A --- C[C]
            B --- C
            D[D] --- E[E]
            D --- F[F]
            E --- F
            C --- D
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style E fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
            style F fill:#e3f2fd,stroke:#2196f3,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Two communities with dense internal connections</p>
    </div>

    <pre class="code-block">// Louvain Method for Community Detection
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

class CommunityDetector {
private:
    int V;
    vector<vector<int>> adj;
    vector<int> community;
    double totalEdges;
    
    double calculateModularity() {
        double Q = 0.0;
        double m2 = 2.0 * totalEdges;
        
        for (int i = 0; i < V; i++) {
            for (int j : adj[i]) {
                if (community[i] == community[j]) {
                    double kikj = adj[i].size() * adj[j].size();
                    Q += (1.0 - kikj / m2);
                }
            }
        }
        return Q / m2;
    }
    
public:
    CommunityDetector(int vertices) : V(vertices), totalEdges(0) {
        adj.resize(V);
        community.resize(V);
        for (int i = 0; i < V; i++) community[i] = i;
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
        totalEdges++;
    }
    
    vector<int> detectCommunities() {
        bool improved = true;
        while (improved) {
            improved = false;
            for (int node = 0; node < V; node++) {
                int bestCommunity = community[node];
                // Try moving to neighbor communities
                for (int neighbor : adj[node]) {
                    int newComm = community[neighbor];
                    if (newComm != community[node]) {
                        community[node] = newComm;
                        improved = true;
                        break;
                    }
                }
            }
        }
        return community;
    }
};</pre>

    <h2 class="section-title" id="ch14-3">14.3 Graph Clustering Techniques</h2>

    <p class="academic-text">Graph clustering groups similar nodes together based on various similarity metrics. Unlike community detection which focuses on connectivity patterns, clustering can use node attributes, structural roles, or hybrid approaches.</p>
    
    <p class="academic-text"><strong>Spectral Clustering</strong></p>
    <p class="academic-text">Spectral clustering uses eigenvalues and eigenvectors of the graph Laplacian matrix to find clusters.</p>
    
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Build adjacency matrix:</strong> Represent graph connections</li>
        <li class="academic-text"><strong>Compute Laplacian:</strong> L = D - A</li>
        <li class="academic-text"><strong>Find eigenvectors:</strong> Use k smallest eigenvalues</li>
        <li class="academic-text"><strong>Cluster in eigenspace:</strong> Apply k-means</li>
    </ul>

    <h2 class="section-title" id="ch14-4">14.4 Applications in Social Network Analysis</h2>

    <p class="academic-text">Pattern recognition in graphs powers modern social network analysis, from finding influencers to detecting fake news spread.</p>
    
    <p class="academic-text"><strong>Key Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Influencer detection:</strong> Find users with high centrality</li>
        <li class="academic-text"><strong>Community discovery:</strong> Identify interest groups</li>
        <li class="academic-text"><strong>Echo chamber detection:</strong> Find isolated communities</li>
        <li class="academic-text"><strong>Viral content tracking:</strong> Analyze spread patterns</li>
        <li class="academic-text"><strong>Bot detection:</strong> Identify suspicious cliques</li>
    </ul>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">üéâ Chapter 14 Complete!</h3>
        <p class="academic-text">You now understand pattern recognition in graphs:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">‚úÖ <strong>Cliques</strong> - finding complete subgraphs</li>
            <li class="academic-text">‚úÖ <strong>Community detection</strong> - discovering modular structure</li>
            <li class="academic-text">‚úÖ <strong>Graph clustering</strong> - grouping similar nodes</li>
            <li class="academic-text">‚úÖ <strong>Social network analysis</strong> - real-world applications</li>
        </ul>
        
        <p class="academic-text">These pattern recognition techniques unlock insights hidden in complex networks!</p>
    </div>
</body>
</html>
