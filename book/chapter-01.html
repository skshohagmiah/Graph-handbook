<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 1: What Are Graphs, Really?</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 1</div>
    <h1 class="chapter-title">What Are Graphs, Really?</h1>
    
    <div class="definition-box">
        "A graph is not just a mathematical abstraction—it's a lens for understanding the connected world around us."
    </div>

    <p class="academic-text">Every day, you interact with graphs without even knowing it. When Facebook suggests friends, Google Maps finds routes, or Netflix recommends movies, you're experiencing graph algorithms in action. This chapter introduces the fundamental concepts that power these systems.</p>

    <h2 class="section-title" id="ch1-1">1.1 Definition: Nodes, Edges, and Degrees</h2>
    
    <p class="academic-text">A <strong>graph</strong> G = (V, E) is a mathematical structure consisting of:</p>
    
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Vertices (V)</strong>: A finite set of nodes representing entities</li>
        <li class="academic-text"><strong>Edges (E)</strong>: A set of connections between vertices</li>
    </ul>

    <div class="definition-box">
        <strong>Formal Definition:</strong> A graph G = (V, E) where V = {v₁, v₂, ..., vₙ} is the vertex set and E ⊆ V × V is the edge set.
    </div>

    <p class="academic-text"><strong>Degree of a Vertex:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Degree deg(v)</strong>: Number of edges incident to vertex v</li>
        <li class="academic-text"><strong>In directed graphs:</strong>
            <ul style="margin: 8px 0; padding-left: 20px;">
                <li class="academic-text"><strong>In-degree (deg⁻(v))</strong>: Number of incoming edges</li>
                <li class="academic-text"><strong>Out-degree (deg⁺(v))</strong>: Number of outgoing edges</li>
            </ul>
        </li>
    </ul>

    <pre class="code-block">// Basic graph representation using adjacency list
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

class Graph {
private:
    std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; adjList;
    
public:
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u); // For undirected graph
    }
    
    int getDegree(int vertex) {
        return adjList[vertex].size();
    }
    
    void printGraph() {
        for (const auto&amp; [vertex, neighbors] : adjList) {
            std::cout &lt;&lt; vertex &lt;&lt; ": ";
            for (int neighbor : neighbors) {
                std::cout &lt;&lt; neighbor &lt;&lt; " ";
            }
            std::cout &lt;&lt; "(degree: " &lt;&lt; getDegree(vertex) &lt;&lt; ")" &lt;&lt; std::endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-2">1.2 Graph Types: Directed, Undirected, Weighted, Unweighted</h2>

    <p class="academic-text"><strong>Undirected Graphs:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">Edges have no direction: if (u,v) ∈ E, then (v,u) ∈ E</li>
        <li class="academic-text">Examples: Social networks, road networks, molecular structures</li>
        <li class="academic-text">Represented as unordered pairs: {u, v}</li>
    </ul>

    <p class="academic-text"><strong>Directed Graphs (Digraphs):</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">Edges have direction: (u,v) ≠ (v,u)</li>
        <li class="academic-text">Examples: Web links, citation networks, dependency graphs</li>
        <li class="academic-text">Represented as ordered pairs: (u, v)</li>
    </ul>

    <p class="academic-text"><strong>Weighted vs Unweighted:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Unweighted:</strong> All edges have equal importance</li>
        <li class="academic-text"><strong>Weighted:</strong> Each edge has an associated weight w(u,v)</li>
        <li class="academic-text">Weights represent: distance, cost, capacity, strength, etc.</li>
    </ul>

    <pre class="code-block">// Weighted graph implementation
class WeightedGraph {
private:
    std::unordered_map&lt;int, std::vector&lt;std::pair&lt;int, double&gt;&gt;&gt; adjList;
    
public:
    void addEdge(int u, int v, double weight) {
        adjList[u].push_back({v, weight});
        // For directed graph, don't add reverse edge
    }
    
    void printWeightedGraph() {
        for (const auto&amp; [vertex, edges] : adjList) {
            std::cout &lt;&lt; vertex &lt;&lt; ": ";
            for (const auto&amp; [neighbor, weight] : edges) {
                std::cout &lt;&lt; "(" &lt;&lt; neighbor &lt;&lt; ", " &lt;&lt; weight &lt;&lt; ") ";
            }
            std::cout &lt;&lt; std::endl;
        }
    }
};</pre>

    <h2 class="section-title" id="ch1-3">1.3 Cyclic vs Acyclic Structures</h2>

    <p class="academic-text">Understanding cycles is crucial for graph algorithms and applications.</p>

    <p class="academic-text"><strong>Cycles:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Cycle:</strong> A path that starts and ends at the same vertex</li>
        <li class="academic-text"><strong>Simple cycle:</strong> No repeated vertices except start/end</li>
        <li class="academic-text"><strong>Self-loop:</strong> An edge from a vertex to itself</li>
    </ul>

    <p class="academic-text"><strong>Acyclic Graphs:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>DAG (Directed Acyclic Graph):</strong> Directed graph with no cycles</li>
        <li class="academic-text"><strong>Tree:</strong> Connected acyclic undirected graph</li>
        <li class="academic-text"><strong>Forest:</strong> Collection of trees (acyclic graph)</li>
    </ul>

    <div class="definition-box">
        <strong>Important Property:</strong> A tree with n vertices has exactly n-1 edges. Adding any edge creates a cycle; removing any edge disconnects the graph.
    </div>

    <p class="academic-text"><strong>Applications:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>DAGs:</strong> Task scheduling, dependency resolution, compilation</li>
        <li class="academic-text"><strong>Trees:</strong> File systems, decision trees, parsing</li>
        <li class="academic-text"><strong>Cyclic graphs:</strong> Social networks, transportation, circuits</li>
    </ul>

    <h2 class="section-title" id="ch1-4">1.4 Graph Representations: Adjacency List, Matrix, Edge List</h2>

    <p class="academic-text">Choosing the right representation affects algorithm efficiency and memory usage.</p>

    <p class="academic-text"><strong>1. Adjacency Matrix:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">2D array A where A[i][j] = 1 if edge (i,j) exists</li>
        <li class="academic-text"><strong>Space:</strong> O(V²) - inefficient for sparse graphs</li>
        <li class="academic-text"><strong>Edge lookup:</strong> O(1)</li>
        <li class="academic-text"><strong>Best for:</strong> Dense graphs, frequent edge queries</li>
    </ul>

    <pre class="code-block">// Adjacency Matrix representation
class AdjacencyMatrix {
private:
    std::vector&lt;std::vector&lt;int&gt;&gt; matrix;
    int numVertices;
    
public:
    AdjacencyMatrix(int n) : numVertices(n) {
        matrix.resize(n, std::vector&lt;int&gt;(n, 0));
    }
    
    void addEdge(int u, int v) {
        matrix[u][v] = 1;
        matrix[v][u] = 1; // For undirected graph
    }
    
    bool hasEdge(int u, int v) {
        return matrix[u][v] == 1;
    }
    
    void printMatrix() {
        for (int i = 0; i &lt; numVertices; i++) {
            for (int j = 0; j &lt; numVertices; j++) {
                std::cout &lt;&lt; matrix[i][j] &lt;&lt; " ";
            }
            std::cout &lt;&lt; std::endl;
        }
    }
};</pre>

    <p class="academic-text"><strong>2. Adjacency List:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">Array of lists, each containing neighbors of a vertex</li>
        <li class="academic-text"><strong>Space:</strong> O(V + E) - efficient for sparse graphs</li>
        <li class="academic-text"><strong>Edge lookup:</strong> O(deg(v))</li>
        <li class="academic-text"><strong>Best for:</strong> Sparse graphs, graph traversals</li>
    </ul>

    <p class="academic-text"><strong>3. Edge List:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text">Simple list of all edges: [(u₁,v₁), (u₂,v₂), ...]</li>
        <li class="academic-text"><strong>Space:</strong> O(E)</li>
        <li class="academic-text"><strong>Best for:</strong> Algorithms that process all edges</li>
    </ul>

    <table style="width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 11pt;">
        <thead>
            <tr style="border-bottom: 1px solid #000;">
                <th style="text-align: left; padding: 8px; font-weight: normal;">Operation</th>
                <th style="text-align: left; padding: 8px; font-weight: normal;">Adj. Matrix</th>
                <th style="text-align: left; padding: 8px; font-weight: normal;">Adj. List</th>
                <th style="text-align: left; padding: 8px; font-weight: normal;">Edge List</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="padding: 8px;"><strong>Space</strong></td>
                <td style="padding: 8px;">O(V²)</td>
                <td style="padding: 8px;">O(V + E)</td>
                <td style="padding: 8px;">O(E)</td>
            </tr>
            <tr>
                <td style="padding: 8px;"><strong>Add Edge</strong></td>
                <td style="padding: 8px;">O(1)</td>
                <td style="padding: 8px;">O(1)</td>
                <td style="padding: 8px;">O(1)</td>
            </tr>
            <tr>
                <td style="padding: 8px;"><strong>Check Edge</strong></td>
                <td style="padding: 8px;">O(1)</td>
                <td style="padding: 8px;">O(deg(v))</td>
                <td style="padding: 8px;">O(E)</td>
            </tr>
            <tr>
                <td style="padding: 8px;"><strong>Find Neighbors</strong></td>
                <td style="padding: 8px;">O(V)</td>
                <td style="padding: 8px;">O(deg(v))</td>
                <td style="padding: 8px;">O(E)</td>
            </tr>
        </tbody>
    </table>

    <h2 class="section-title" id="ch1-5">1.5 Real-World Examples</h2>

    <p class="academic-text">Understanding how graphs model real systems is key to applying algorithms effectively.</p>

    <p class="academic-text"><strong>Social Networks:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Users, <strong>Edges:</strong> Friendships/Follows</li>
        <li class="academic-text"><strong>Applications:</strong> Friend recommendations, influence analysis, community detection</li>
        <li class="academic-text"><strong>Properties:</strong> Small-world, scale-free, high clustering</li>
    </ul>

    <p class="academic-text"><strong>Transportation Networks:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Locations, <strong>Edges:</strong> Routes with distances/times</li>
        <li class="academic-text"><strong>Applications:</strong> Shortest path, route optimization, traffic flow</li>
        <li class="academic-text"><strong>Algorithms:</strong> Dijkstra's, A*, Floyd-Warshall</li>
    </ul>

    <p class="academic-text"><strong>Computer Networks:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Routers/Computers, <strong>Edges:</strong> Connections</li>
        <li class="academic-text"><strong>Applications:</strong> Routing protocols, network reliability, bandwidth optimization</li>
    </ul>

    <p class="academic-text"><strong>Dependency Graphs:</strong></p>
    <ul style="margin: 8px 0 16px 24px;">
        <li class="academic-text"><strong>Vertices:</strong> Tasks/Modules, <strong>Edges:</strong> Dependencies</li>
        <li class="academic-text"><strong>Applications:</strong> Build systems, course prerequisites, project scheduling</li>
        <li class="academic-text"><strong>Structure:</strong> Must be acyclic (DAG)</li>
    </ul>

    <pre class="code-block">// Real-world example: Course prerequisite system
class CourseGraph {
private:
    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; prerequisites;
    
public:
    void addPrerequisite(const std::string&amp; course, const std::string&amp; prereq) {
        prerequisites[course].push_back(prereq);
    }
    
    bool canTakeCourse(const std::string&amp; course, 
                      const std::set&lt;std::string&gt;&amp; completed) {
        for (const std::string&amp; prereq : prerequisites[course]) {
            if (completed.find(prereq) == completed.end()) {
                return false;
            }
        }
        return true;
    }
    
    std::vector&lt;std::string&gt; getAvailableCourses(
        const std::set&lt;std::string&gt;&amp; completed) {
        std::vector&lt;std::string&gt; available;
        for (const auto&amp; [course, prereqs] : prerequisites) {
            if (completed.find(course) == completed.end() &amp;&amp; 
                canTakeCourse(course, completed)) {
                available.push_back(course);
            }
        }
        return available;
    }
};</pre>

    <div class="definition-box">
        <strong>Exercise:</strong> Model Your Environment
        <ol style="margin: 12px 0; padding-left: 20px;">
            <li>Choose a system you interact with daily (social media, transportation, etc.)</li>
            <li>Identify the vertices and edges</li>
            <li>Determine if it's directed/undirected, weighted/unweighted</li>
            <li>Consider what algorithms might be useful for this system</li>
            <li>Think about the best representation for this graph</li>
        </ol>
    </div>

    <p class="academic-text">Understanding these fundamental concepts provides the foundation for all graph algorithms. In the next chapter, we'll explore trees - special graphs that form the backbone of many data structures and algorithms in computer science.</p>
</body>
</html>
