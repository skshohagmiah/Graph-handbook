<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8: Minimum Spanning Trees</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="max-w-4xl mx-auto px-8 py-16 font-sans">
    <div class="chapter-number">Chapter 8</div>
    <h1 class="chapter-title">Minimum Spanning Trees</h1>
    
    <div class="definition-box">
        "Minimum spanning trees find the cheapest way to connect all nodes in a network - essential for designing efficient infrastructure."
    </div>

    <p class="academic-text">Imagine you're tasked with designing a telecommunications network to connect every city in a country with fiber optic cables, but you have a limited budget and need to minimize the total cost. Or perhaps you're planning an electrical grid that must reach every neighborhood while using the least amount of wire. These real-world optimization challenges represent minimum spanning tree problems - some of the most elegant and practically important problems in computer science.</p>
    
    <p class="academic-text">Minimum Spanning Trees represent the perfect intersection of mathematical theory and practical application. A spanning tree connects all vertices in a graph using exactly n-1 edges (the minimum needed to maintain connectivity), while a minimum spanning tree does this with the smallest possible total weight. This optimization problem appears everywhere from infrastructure design to data analysis, demonstrating how graph theory solves real-world challenges with mathematical precision.</p>

    <p class="academic-text">The beauty of MST algorithms lies in their guarantee of optimality through surprisingly simple strategies. These algorithms prove that greedy approaches - making locally optimal choices at each step - can lead to globally optimal solutions. This insight has profound implications beyond spanning trees, influencing algorithm design across computer science and operations research.</p>
    
    <p class="academic-text"><strong>MSTs power critical systems and applications across industries:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Infrastructure networks:</strong> Designing optimal layouts for telecommunications, power grids, water systems, and transportation networks that minimize cost while ensuring connectivity</li>
        <li class="academic-text"><strong>Circuit design:</strong> Minimizing wire length and signal delay in computer chips and electronic devices, where every millimeter of wire affects performance and cost</li>
        <li class="academic-text"><strong>Data clustering:</strong> Finding natural groupings in machine learning and data analysis by connecting similar data points with minimum total distance</li>
        <li class="academic-text"><strong>Approximation algorithms:</strong> Serving as the foundation for solving more complex optimization problems like the traveling salesman problem and facility location</li>
        <li class="academic-text"><strong>Network reliability:</strong> Identifying critical connections in networks and designing backup systems that maintain connectivity with minimal redundancy</li>
    </ul>

    <h2 class="section-title" id="ch8-1">8.1 Kruskal's Algorithm</h2>
    
    <p class="academic-text">Kruskal's algorithm builds the MST by considering edges in order of increasing weight, adding each edge if it doesn't create a cycle. It's a greedy algorithm that always makes the locally optimal choice.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ”— Kruskal's Strategy</h3>
        <p class="academic-text"><strong>Kruskal's Algorithm</strong> builds MST by adding edges in order of increasing weight.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Sort edges:</strong> Order all edges by weight from smallest to largest</li>
            <li class="academic-text"><strong>Greedy selection:</strong> Add the smallest edge that doesn't create a cycle</li>
            <li class="academic-text"><strong>Cycle detection:</strong> Use Union-Find to efficiently detect cycles</li>
            <li class="academic-text"><strong>Stop condition:</strong> Stop when we have V-1 edges (tree property)</li>
        </ul>
    </div>
    
    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Kruskal's Algorithm Example:</strong><br><br>
        <div class="mermaid">
        graph LR
            A[A] ---|1| B[B]
            A ---|4| C[C]
            B ---|2| C[C]
            B ---|5| D[D]
            C ---|3| D[D]
            
            style A fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style B fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style C fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
            style D fill:#e8f5e8,stroke:#4caf50,stroke-width:2px
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Edge selection order: AB(1) â†’ BC(2) â†’ CD(3). Skip AC(4) and BD(5) as they create cycles.</p>
    </div>

    <pre class="code-block">// Kruskal's Algorithm Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class KruskalMST {
private:
    // Edge structure for Kruskal's algorithm
    struct Edge {
        int u, v, weight;  // Two endpoints and weight
        Edge(int u, int v, int w) : u(u), v(v), weight(w) {}
        
        // Comparison operator for sorting edges by weight
        bool operator<(const Edge& other) const {
            return weight < other.weight;
        }
    };
    
    vector&lt;Edge&gt; edges;    // All edges in the graph
    int numVertices;       // Number of vertices
    
public:
    KruskalMST(int n) : numVertices(n) {}
    
    // Add undirected weighted edge to graph
    void addEdge(int u, int v, int weight) {
        edges.push_back(Edge(u, v, weight));
    }
    
    // Find MST using Kruskal's algorithm
    vector&lt;Edge&gt; findMST() {
        vector&lt;Edge&gt; mst;
        
        // Sort edges by weight
        sort(edges.begin(), edges.end());
        
        // Initialize Union-Find
        UnionFind uf(numVertices);
        
        for (const Edge& edge : edges) {
            // If adding this edge doesn't create a cycle
            if (uf.find(edge.u) != uf.find(edge.v)) {
                mst.push_back(edge);
                uf.unite(edge.u, edge.v);
                
                // MST complete when we have V-1 edges
                if (mst.size() == numVertices - 1) break;
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<Edge> mst = findMST();
        int totalWeight = 0;
        for (const Edge& edge : mst) {
            totalWeight += edge.weight;
        }
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        KruskalMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<Edge> mst = graph.findMST();
        
        cout << "Kruskal's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (const Edge& edge : mst) {
            cout << labels[edge.u] << "-" << labels[edge.v] 
                 << " (weight: " << edge.weight << ")" << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-2">8.2 Prim's Algorithm</h2>
    
    <p class="academic-text">Prim's algorithm builds the MST by starting from a vertex and growing the tree one edge at a time, always adding the minimum weight edge that connects the tree to a new vertex.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸŒ± Prim's Strategy</h3>
        <p class="academic-text"><strong>Prim's Algorithm</strong> grows MST from a starting vertex by adding minimum edges.</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Start with vertex:</strong> Begin with any vertex in the MST</li>
            <li class="academic-text"><strong>Grow incrementally:</strong> Add minimum edge connecting MST to new vertex</li>
            <li class="academic-text"><strong>Priority queue:</strong> Use min-heap to efficiently find minimum edge</li>
            <li class="academic-text"><strong>Cut property:</strong> Minimum edge crossing cut is safe to add</li>
        </ul>
    </div>

    <div style="background-color: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin: 20px 0;">
        <strong>Prim's vs Kruskal's Comparison:</strong><br><br>
        <div class="mermaid">
        graph TD
            A[Start: Pick any vertex] --> B[Prim's: Grow tree from vertex]
            A --> C[Kruskal's: Consider all edges globally]
            B --> D[Uses: Priority Queue]
            C --> E[Uses: Union-Find]
            D --> F[Good for: Dense graphs]
            E --> G[Good for: Sparse graphs]
        </div>
        <p style="margin: 10px 0 0 0; font-family: sans-serif; font-size: 12px; text-align: center;">Both algorithms find the same MST but use different strategies</p>
    </div>

    <pre class="code-block">// Prim's Algorithm Implementation
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;

class PrimMST {
private:
    struct Edge {
        int to, weight;
        Edge(int t, int w) : to(t), weight(w) {}
    };
    
    vector<vector<Edge>> graph;
    int numVertices;
    
public:
    PrimMST(int n) : numVertices(n), graph(n) {}
    
    void addEdge(int u, int v, int weight) {
        graph[u].push_back(Edge(v, weight));
        graph[v].push_back(Edge(u, weight)); // undirected
    }
    
    // Find MST using Prim's algorithm
    vector<pair<int, int>> findMST() {
        vector<pair<int, int>> mst;
        vector<bool> inMST(numVertices, false);
        vector<int> key(numVertices, INT_MAX);
        vector<int> parent(numVertices, -1);
        
        // Priority queue: (weight, vertex)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        // Start from vertex 0
        key[0] = 0;
        pq.push({0, 0});
        
        while (!pq.empty()) {
            int u = pq.top().second;
            pq.pop();
            
            if (inMST[u]) continue;
            
            inMST[u] = true;
            
            // Add edge to MST (except for starting vertex)
            if (parent[u] != -1) {
                mst.push_back({parent[u], u});
            }
            
            // Update keys of adjacent vertices
            for (const Edge& edge : graph[u]) {
                int v = edge.to;
                int weight = edge.weight;
                
                if (!inMST[v] && weight < key[v]) {
                    key[v] = weight;
                    parent[v] = u;
                    pq.push({weight, v});
                }
            }
        }
        
        return mst;
    }
    
    // Calculate total MST weight
    int getMSTWeight() {
        vector<pair<int, int>> mst = findMST();
        int totalWeight = 0;
        
        for (auto [u, v] : mst) {
            // Find edge weight between u and v
            for (const Edge& edge : graph[u]) {
                if (edge.to == v) {
                    totalWeight += edge.weight;
                    break;
                }
            }
        }
        
        return totalWeight;
    }
    
    // Demo function
    static void demo() {
        PrimMST graph(4);
        
        graph.addEdge(0, 1, 1);  // A-B: 1
        graph.addEdge(0, 2, 4);  // A-C: 4
        graph.addEdge(1, 2, 2);  // B-C: 2
        graph.addEdge(1, 3, 5);  // B-D: 5
        graph.addEdge(2, 3, 3);  // C-D: 3
        
        vector<pair<int, int>> mst = graph.findMST();
        
        cout << "Prim's MST edges:" << endl;
        char labels[] = {'A', 'B', 'C', 'D'};
        for (auto [u, v] : mst) {
            cout << labels[u] << "-" << labels[v] << endl;
        }
        cout << "Total MST weight: " << graph.getMSTWeight() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-3">8.3 Union-Find Data Structure</h2>
    
    <p class="academic-text">Union-Find (also called Disjoint Set Union) is a crucial data structure for Kruskal's algorithm. It efficiently tracks which vertices belong to which connected components and can quickly determine if adding an edge would create a cycle.</p>
    
    <div class="definition-box" style="margin: 20px 0;">
        <h3 style="margin-top: 0; color: #1976d2;">ðŸ”— Union-Find Operations</h3>
        <p class="academic-text"><strong>Union-Find</strong> maintains disjoint sets with two key operations:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text"><strong>Find(x):</strong> Determine which set contains element x</li>
            <li class="academic-text"><strong>Union(x, y):</strong> Merge the sets containing x and y</li>
            <li class="academic-text"><strong>Path compression:</strong> Optimize find by flattening tree structure</li>
            <li class="academic-text"><strong>Union by rank:</strong> Optimize union by balancing tree height</li>
        </ul>
    </div>

    <pre class="code-block">// Union-Find Data Structure Implementation
class UnionFind {
private:
    vector<int> parent;
    vector<int> rank;
    
public:
    UnionFind(int n) : parent(n), rank(n, 0) {
        // Initially, each element is its own parent
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
    
    // Find with path compression
    int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }
    
    // Union by rank
    void unite(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        if (rootX != rootY) {
            // Union by rank: attach smaller tree to larger tree
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    
    // Check if two elements are in the same set
    bool connected(int x, int y) {
        return find(x) == find(y);
    }
    
    // Count number of disjoint sets
    int countSets() {
        unordered_set<int> roots;
        for (int i = 0; i < parent.size(); i++) {
            roots.insert(find(i));
        }
        return roots.size();
    }
    
    // Demo function
    static void demo() {
        UnionFind uf(5);
        
        cout << "Initial sets: " << uf.countSets() << endl;
        
        uf.unite(0, 1);  // Connect 0 and 1
        uf.unite(2, 3);  // Connect 2 and 3
        
        cout << "After unions: " << uf.countSets() << endl;
        cout << "0 and 1 connected: " << uf.connected(0, 1) << endl;
        cout << "0 and 2 connected: " << uf.connected(0, 2) << endl;
        
        uf.unite(1, 2);  // Connect the two components
        cout << "Final sets: " << uf.countSets() << endl;
    }
};</pre>

    <h2 class="section-title" id="ch8-4">8.4 Applications in Network Design</h2>
    
    <p class="academic-text">MST algorithms have countless real-world applications in designing efficient networks and infrastructure. Let's explore some practical examples.</p>
    
    <p class="academic-text"><strong>Network Infrastructure Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Computer networks:</strong> Connecting offices with minimum cable cost</li>
        <li class="academic-text"><strong>Power grids:</strong> Connecting power stations to minimize transmission costs</li>
        <li class="academic-text"><strong>Transportation:</strong> Building road networks with minimum construction cost</li>
        <li class="academic-text"><strong>Telecommunications:</strong> Laying fiber optic cables efficiently</li>
    </ul>
    
    <p class="academic-text"><strong>Data Analysis Applications:</strong></p>
    <ul style="margin: 16px 0; padding-left: 24px;">
        <li class="academic-text"><strong>Clustering:</strong> Finding natural groupings in data</li>
        <li class="academic-text"><strong>Image segmentation:</strong> Identifying regions in images</li>
        <li class="academic-text"><strong>Social network analysis:</strong> Finding communities</li>
        <li class="academic-text"><strong>Phylogenetic trees:</strong> Evolutionary relationships</li>
    </ul>

    <pre class="code-block">// Network Design Application
class NetworkDesigner {
private:
    struct Connection {
        int city1, city2;
        double cost;
        string type; // "fiber", "cable", "wireless"
        
        Connection(int c1, int c2, double c, string t) 
            : city1(c1), city2(c2), cost(c), type(t) {}
    };
    
    vector<string> cityNames;
    vector<Connection> possibleConnections;
    
public:
    void addCity(const string& name) {
        cityNames.push_back(name);
    }
    
    void addPossibleConnection(int city1, int city2, double cost, const string& type) {
        possibleConnections.push_back(Connection(city1, city2, cost, type));
    }
    
    // Design minimum cost network using MST
    vector<Connection> designNetwork() {
        vector<Connection> network;
        
        // Sort connections by cost
        sort(possibleConnections.begin(), possibleConnections.end(),
             [](const Connection& a, const Connection& b) {
                 return a.cost < b.cost;
             });
        
        UnionFind uf(cityNames.size());
        
        for (const Connection& conn : possibleConnections) {
            if (uf.find(conn.city1) != uf.find(conn.city2)) {
                network.push_back(conn);
                uf.unite(conn.city1, conn.city2);
                
                if (network.size() == cityNames.size() - 1) break;
            }
        }
        
        return network;
    }
    
    // Calculate total network cost
    double getTotalCost() {
        vector<Connection> network = designNetwork();
        double totalCost = 0;
        for (const Connection& conn : network) {
            totalCost += conn.cost;
        }
        return totalCost;
    }
    
    // Demo function
    static void demo() {
        NetworkDesigner designer;
        
        // Add cities
        designer.addCity("New York");
        designer.addCity("Boston");
        designer.addCity("Philadelphia");
        designer.addCity("Washington DC");
        
        // Add possible connections with costs (in millions)
        designer.addPossibleConnection(0, 1, 15.5, "fiber");    // NY-Boston
        designer.addPossibleConnection(0, 2, 8.2, "fiber");     // NY-Philadelphia
        designer.addPossibleConnection(0, 3, 12.1, "cable");    // NY-Washington
        designer.addPossibleConnection(1, 2, 18.7, "wireless"); // Boston-Philadelphia
        designer.addPossibleConnection(1, 3, 25.3, "cable");    // Boston-Washington
        designer.addPossibleConnection(2, 3, 6.8, "fiber");     // Philadelphia-Washington
        
        vector<Connection> network = designer.designNetwork();
        
        cout << "Optimal network design:" << endl;
        for (const Connection& conn : network) {
            cout << designer.cityNames[conn.city1] << " - " 
                 << designer.cityNames[conn.city2] 
                 << " (" << conn.type << ", $" << conn.cost << "M)" << endl;
        }
        cout << "Total cost: $" << designer.getTotalCost() << "M" << endl;
    }
};</pre>

    <div class="performance-summary">
        <h3 style="color: #2e7d32; margin-top: 0;">ðŸŒ³ MST Algorithm Comparison</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Kruskal's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log E)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for Union-Find</li>
                    <li class="academic-text"><strong>Best for:</strong> Sparse graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Global edge selection</li>
                </ul>
            </div>
            
            <div style="background-color: white; border-radius: 8px; padding: 15px;">
                <h4 style="color: #2e7d32; margin-top: 0;">Prim's Algorithm</h4>
                <ul style="margin: 8px 0 16px 24px;">
                    <li class="academic-text"><strong>Time:</strong> O(E log V)</li>
                    <li class="academic-text"><strong>Space:</strong> O(V) for priority queue</li>
                    <li class="academic-text"><strong>Best for:</strong> Dense graphs</li>
                    <li class="academic-text"><strong>Strategy:</strong> Incremental tree growth</li>
                </ul>
            </div>
        </div>
        
        <div style="background-color: white; border-radius: 8px; padding: 15px; margin-top: 20px;">
            <h4 style="color: #2e7d32; margin-top: 0;">When to Use Which Algorithm</h4>
            <ul style="margin: 8px 0 16px 24px;">
                <li class="academic-text"><strong>Kruskal's:</strong> When edges are given as a list, sparse graphs, or when Union-Find is already available</li>
                <li class="academic-text"><strong>Prim's:</strong> When graph is represented as adjacency list/matrix, dense graphs, or when starting from specific vertex</li>
                <li class="academic-text"><strong>Both produce identical MST weight</strong> - choice depends on implementation convenience and graph density</li>
            </ul>
        </div>
    </div>

    <div class="completion-summary">
        <h3 style="color: #1976d2; margin-top: 0;">ðŸŽ‰ Chapter 8 Complete!</h3>
        <p class="academic-text">You've mastered minimum spanning tree algorithms:</p>
        <ul style="margin: 8px 0 16px 24px;">
            <li class="academic-text">âœ… <strong>Kruskal's Algorithm</strong> - global edge selection with Union-Find</li>
            <li class="academic-text">âœ… <strong>Prim's Algorithm</strong> - incremental tree growth with priority queue</li>
            <li class="academic-text">âœ… <strong>Union-Find Data Structure</strong> - efficient cycle detection and set operations</li>
            <li class="academic-text">âœ… <strong>Network Design Applications</strong> - real-world infrastructure optimization</li>
        </ul>
        
        <p class="academic-text">MST algorithms are fundamental tools for optimization problems involving connectivity. They're used everywhere from computer networks to data clustering to circuit design. Next: topological sorting for handling dependencies and scheduling!</p>
    </div>
</body>
</html>
